<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>WebGL 2 Specification</title>
    <meta name="generator" content="BBEdit 9.1">
    <link rel="stylesheet" type="text/css" href="../../../resources/Khronos-WD.css" />
    <script src="../../../resources/jquery-1.3.2.min.js" type="text/javascript"></script>
    <script src="../../../resources/generateTOC.js" type="text/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class=head>
        <p>
            <a href="http://khronos.org/">
                <img alt=Khronos height=60 src="../../../resources/KhronosGroup-3D.png" width=220>
            </a>
        </p>
    </div>
    <div class=head>
        <p>
            <a href="http://webgl.org/">
                <img alt=WebGL height=72 src="../../../resources/WebGL-Logo.png" width=156>
            </a>
        </p>
    </div>
    <!--end-logo-->
    
    <h1>WebGL 2 Specification</h1>
    <h2 class="no-toc">Editor's Draft 13 September 2013</h2>
    <dl>
        <dt>This version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/">
                    https://www.khronos.org/registry/webgl/specs/latest/2.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl
                </a>
            </dd>
        <dt>Latest version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/">
                    https://www.khronos.org/registry/webgl/specs/latest/2.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl
                </a>
            </dd>
        <dt>Previous version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0.2/">
                    https://www.khronos.org/registry/webgl/specs/1.0.2/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0.2/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/1.0.2/webgl.idl
                </a>
            </dd>
        <dt>Editor:
            <dd>
                <a href="mailto:dino@apple.com">Dean Jackson</a>
                <a href="http://www.apple.com/">(Apple Inc.)</a>
            </dd>
    </dl>
    
    <span style="font-size: x-small; font-style: oblique">Copyright &copy; 2013 Khronos Group</span>

    <hr />
    
    <h2 class="no-toc">Abstract</h2>
    <p>
        This is Version 2.0 of the WebGL Specification.
    </p>
    <p>
        This specification describes an additional rendering context and support
        objects for the
        <a href="http://www.w3.org/TR/html5/the-canvas-element.html"
           title="HTML 5 Canvas Element">
            HTML 5 <span class="prop-name">canvas</span> element <a href="#refsCANVAS">[CANVAS]</a>.
        </a>
        This context allows rendering using an API that conforms closely to the OpenGL ES 3.0 API.
    </p>
    <p>
      This document should be read as an extension to the <a href="https://www.khronos.org/registry/webgl/specs/1.0.2/">
        WebGL 1.0 specification</a>. It will only describe the differences from 1.0.</a>

    <h2 class="no-toc">Status of this document</h2>
    
    <!--begin-status-->
    <p>
        This document is an editor's draft. Do not cite this document as other than work in
        progress.  Public discussion of this specification is welcome on the
        (<a href="https://www.khronos.org/webgl/public-mailing-list/archives/">archived</a>) WebGL
        mailing list <a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a> (see
        <a href="http://www.khronos.org/webgl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->
    
    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>
    <div class="note">        
    <p>
      WebGL™ is an immediate mode 3D rendering API designed for the web. This is Version 2 of the
      WebGL specification. It is derived from OpenGL® ES 3.0, and provides similar rendering
      functionality, but in an HTML context.
    </p>

    <p>
      WebGL 2 is backwards compatible with WebGL 1: existing content will run in WebGL 2 without
      modification. To access the new behavior provided in this specification, the content
      explicitly requests a new context (<a href="#">details below</a>).
    </p>
    </div>

    <h3>Conventions</h3>

    <p>
     Many functions described in this document contain links to OpenGL ES
     man pages. While every effort is made to make these pages match the
     OpenGL ES 3.0 specification <a href="#refsGLES30">[GLES30]</a>, 
     they may contain errors. In the case of a contradiction, the OpenGL
     ES 3.0 specification is the final authority.
    </p>

    <p>
      The remaining sections of this document are intended to be read in conjunction
      with the OpenGL ES 3.0 specification (3.0.2 at the time of this writing, available
      from the <a href="http://www.khronos.org/registry/gles/">Khronos OpenGL ES API Registry</a>).
      Unless otherwise specified, the behavior of each method is defined by the
      OpenGL ES 3.0 specification.  This specification may diverge from OpenGL ES 3.0
      in order to ensure interoperability or security, often defining areas that
      OpenGL ES 3.0 leaves implementation-defined.  These differences are summarized in the
      <a href="#webgl_gl_differences">Differences Between WebGL and OpenGL ES 3.0</a> section.
    </p>

<!-- ======================================================================================================= -->

    <h2>Context Creation and Drawing Buffer Presentation</h2>

    <p>
        Before using the WebGL API, the author must obtain a <code>WebGLRenderingContext</code>
        object for a given HTMLCanvasElement <a href="#refsCANVAS">[CANVAS]</a> as described
        below. This object is used to manage OpenGL state and render to the drawing buffer, which
        must be created at the time of context creation.
    </p>
    
<!-- ======================================================================================================= -->

    <h3>Context Creation</h3>

    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has an
        associated <b><a name="context-canvas">canvas</a></b>, set upon creation, which is
        a <em>canvas</em> <a href="#refsCANVAS">[CANVAS]</a>.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has <b><a name="context-creation-parameters">context
        creation parameters</a></b>, set upon creation, in
        a <a href="#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has <b><a name="actual-context-parameters">actual
        context parameters</a></b>, set each time the drawing buffer is created, in
        a <a href="#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has a <b><a name="webgl-context-lost-flag">webgl
        context lost flag</a></b>, which is initially unset.
    </p>
    <p>
        When the <code>getContext()</code> method of a <code>canvas</code> element is to return a
        new object for
        the <em>contextId</em> <code>webgl</code> <a href="#refsCANVASCONTEXTS">[CANVASCONTEXTS]</a>,
        the user agent must perform the following steps:

        <ol class="nestedlist">

        <li> Create a new <code>WebGLRenderingContext</code> or <code>WebGL2RenderingContext</code> object,
            <em>context</em>. If <code>getContext()</code> was invoked with a second argument, <em>options</em>,
            and <em>options</em> has a <code>version</code> property with the value <code>"2"</code>,
            then <em>context</em> will be a <code>WebGL2RenderingContext</code> object. Otherwise <em>context</em>
            is a <code>WebGLRenderingContext</code> object.

        <li> Let <em>context's</em> <a href="#context-canvas">canvas</a> be the canvas
             the <code>getContext()</code> method is associated with.

        <li> Create a new <code>WebGLContextAttributes</code> object, <em>contextAttributes</em>.

        <li> If <code>getContext()</code> was invoked with a second argument, <em>options</em>, set
             the attributes of <em>contextAttributes</em> from those specified in <em>options</em>.

        <li> <a href="#create-a-drawing-buffer">Create a <em>drawing buffer</em></a> using the settings
             specified in <em>contextAttributes</em>, and associate the <em>drawing buffer</em>
             with <em>context</em>.

        <li> If drawing buffer creation failed, perform the following steps:

          <ol class="nestedlist">

          <li> <a href="#fire-a-webgl-context-creation-error">Fire a WebGL context creation
          error</a> at <em>canvas</em>.

          <li> Return null and terminate these steps.

          </ol>

        <li> Set the attributes of <em>contextAttributes</em> based on the properties of the newly
             created drawing buffer.

        <li> Set <em>context's</em> <a href="#context-creation-parameters">context creation
        parameters</a> to <em>contextAttributes</em>.

        <li> Return <em>context</em>.

        </ol>
    </p>
    
<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

    <!-- ======================================================================================================= -->

    <h3>Types</h3>

    <p>
      The following types are introduced in WebGL 2.0.
    </p>
    <pre class="idl">
typedef long long GLint64;
typedef unsigned long long GLuint64;
</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a></h3>

    <p>
        The <code>WebGLContextAttributes</code> dictionary contains drawing surface attributes and
        is passed as the second parameter to <code>getContext</code>.
    </p>
    <pre class="idl">dictionary <dfn id="WebGLContextAttributes">WebGLContextAttributes</dfn> {
    GLboolean alpha = true;
    GLboolean depth = true;
    GLboolean stencil = false;
    GLboolean antialias = true;
    GLboolean premultipliedAlpha = true;
    GLboolean preserveDrawingBuffer = false;
    GLint version = 1; /* New in WebGL 2.0 */
};</pre>

    <h4>Context creation parameters</h4>

    <p>
      Each of these parameters is described in the WebGL 1.0 spec, other than <code>version</code>,
      the behaviour of which was described above.
    </p>
    <div class="example">
    Here is an ECMAScript example which passes a WebGLContextAttributes argument to
    <code>getContext</code> to request a WebGL 2 rendering context. It assumes the presence of a
    canvas element named "canvas1" on the page.

    <pre>
var canvas = document.getElementById('canvas1');
var context = canvas.getContext('webgl',
                                { antialias: false,
                                  stencil: true,
                                  version: 2 });
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3>WebGLQuery</h3>

    <p>
    </p>
    <pre class="idl">interface <dfn id="WebGLQuery">WebGLQuery</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLSampler</h3>

    <p>
    </p>
    <pre class="idl">interface <dfn id="WebGLSampler">WebGLSampler</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLSync</h3>

    <p>
    </p>
    <pre class="idl">interface <dfn id="WebGLSync">WebGLSync</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLTransformFeedback</h3>

    <p>
    </p>
    <pre class="idl">interface <dfn id="WebGLTransformFeedback">WebGLTransformFeedback</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLVertexArrayObject</h3>

    <p>
    </p>
    <pre class="idl">interface <dfn id="WebGLVertexArrayObject">WebGLVertexArrayObject</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLRENDERINGCONTEXT">The WebGL context</a></h3>

    <p>
        The <code>WebGLRenderingContext</code> represents the API allowing
        OpenGL ES 3.0 style rendering into the canvas element.
    </p>

    <pre class="idl">
[NoInterfaceObject]
interface <dfn id="WebGLRenderingContextBase">WebGLRenderingContextBase</dfn>
{

    /* ClearBufferMask */
    const GLenum DEPTH_BUFFER_BIT               = 0x00000100;
    const GLenum STENCIL_BUFFER_BIT             = 0x00000400;
    const GLenum COLOR_BUFFER_BIT               = 0x00004000;
    
    /* BeginMode */
    const GLenum POINTS                         = 0x0000;
    const GLenum LINES                          = 0x0001;
    const GLenum LINE_LOOP                      = 0x0002;
    const GLenum LINE_STRIP                     = 0x0003;
    const GLenum TRIANGLES                      = 0x0004;
    const GLenum TRIANGLE_STRIP                 = 0x0005;
    const GLenum TRIANGLE_FAN                   = 0x0006;
    
    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* BlendingFactorDest */
    const GLenum ZERO                           = 0;
    const GLenum ONE                            = 1;
    const GLenum SRC_COLOR                      = 0x0300;
    const GLenum ONE_MINUS_SRC_COLOR            = 0x0301;
    const GLenum SRC_ALPHA                      = 0x0302;
    const GLenum ONE_MINUS_SRC_ALPHA            = 0x0303;
    const GLenum DST_ALPHA                      = 0x0304;
    const GLenum ONE_MINUS_DST_ALPHA            = 0x0305;
    
    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    const GLenum DST_COLOR                      = 0x0306;
    const GLenum ONE_MINUS_DST_COLOR            = 0x0307;
    const GLenum SRC_ALPHA_SATURATE             = 0x0308;
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */
    
    /* BlendEquationSeparate */
    const GLenum FUNC_ADD                       = 0x8006;
    const GLenum BLEND_EQUATION                 = 0x8009;
    const GLenum BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
    const GLenum BLEND_EQUATION_ALPHA           = 0x883D;
    
    /* BlendSubtract */
    const GLenum FUNC_SUBTRACT                  = 0x800A;
    const GLenum FUNC_REVERSE_SUBTRACT          = 0x800B;
    
    /* Separate Blend Functions */
    const GLenum BLEND_DST_RGB                  = 0x80C8;
    const GLenum BLEND_SRC_RGB                  = 0x80C9;
    const GLenum BLEND_DST_ALPHA                = 0x80CA;
    const GLenum BLEND_SRC_ALPHA                = 0x80CB;
    const GLenum CONSTANT_COLOR                 = 0x8001;
    const GLenum ONE_MINUS_CONSTANT_COLOR       = 0x8002;
    const GLenum CONSTANT_ALPHA                 = 0x8003;
    const GLenum ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
    const GLenum BLEND_COLOR                    = 0x8005;
    
    /* Buffer Objects */
    const GLenum ARRAY_BUFFER                   = 0x8892;
    const GLenum ELEMENT_ARRAY_BUFFER           = 0x8893;
    const GLenum ARRAY_BUFFER_BINDING           = 0x8894;
    const GLenum ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;
    
    const GLenum STREAM_DRAW                    = 0x88E0;
    const GLenum STATIC_DRAW                    = 0x88E4;
    const GLenum DYNAMIC_DRAW                   = 0x88E8;
    
    const GLenum BUFFER_SIZE                    = 0x8764;
    const GLenum BUFFER_USAGE                   = 0x8765;
    
    const GLenum CURRENT_VERTEX_ATTRIB          = 0x8626;
    
    /* CullFaceMode */
    const GLenum FRONT                          = 0x0404;
    const GLenum BACK                           = 0x0405;
    const GLenum FRONT_AND_BACK                 = 0x0408;
    
    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* EnableCap */
    /* TEXTURE_2D */
    const GLenum CULL_FACE                      = 0x0B44;
    const GLenum BLEND                          = 0x0BE2;
    const GLenum DITHER                         = 0x0BD0;
    const GLenum STENCIL_TEST                   = 0x0B90;
    const GLenum DEPTH_TEST                     = 0x0B71;
    const GLenum SCISSOR_TEST                   = 0x0C11;
    const GLenum POLYGON_OFFSET_FILL            = 0x8037;
    const GLenum SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
    const GLenum SAMPLE_COVERAGE                = 0x80A0;
    
    /* ErrorCode */
    const GLenum NO_ERROR                       = 0;
    const GLenum INVALID_ENUM                   = 0x0500;
    const GLenum INVALID_VALUE                  = 0x0501;
    const GLenum INVALID_OPERATION              = 0x0502;
    const GLenum OUT_OF_MEMORY                  = 0x0505;
    
    /* FrontFaceDirection */
    const GLenum CW                             = 0x0900;
    const GLenum CCW                            = 0x0901;
    
    /* GetPName */
    const GLenum LINE_WIDTH                     = 0x0B21;
    const GLenum ALIASED_POINT_SIZE_RANGE       = 0x846D;
    const GLenum ALIASED_LINE_WIDTH_RANGE       = 0x846E;
    const GLenum CULL_FACE_MODE                 = 0x0B45;
    const GLenum FRONT_FACE                     = 0x0B46;
    const GLenum DEPTH_RANGE                    = 0x0B70;
    const GLenum DEPTH_WRITEMASK                = 0x0B72;
    const GLenum DEPTH_CLEAR_VALUE              = 0x0B73;
    const GLenum DEPTH_FUNC                     = 0x0B74;
    const GLenum STENCIL_CLEAR_VALUE            = 0x0B91;
    const GLenum STENCIL_FUNC                   = 0x0B92;
    const GLenum STENCIL_FAIL                   = 0x0B94;
    const GLenum STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
    const GLenum STENCIL_PASS_DEPTH_PASS        = 0x0B96;
    const GLenum STENCIL_REF                    = 0x0B97;
    const GLenum STENCIL_VALUE_MASK             = 0x0B93;
    const GLenum STENCIL_WRITEMASK              = 0x0B98;
    const GLenum STENCIL_BACK_FUNC              = 0x8800;
    const GLenum STENCIL_BACK_FAIL              = 0x8801;
    const GLenum STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
    const GLenum STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
    const GLenum STENCIL_BACK_REF               = 0x8CA3;
    const GLenum STENCIL_BACK_VALUE_MASK        = 0x8CA4;
    const GLenum STENCIL_BACK_WRITEMASK         = 0x8CA5;
    const GLenum VIEWPORT                       = 0x0BA2;
    const GLenum SCISSOR_BOX                    = 0x0C10;
    /*      SCISSOR_TEST */
    const GLenum COLOR_CLEAR_VALUE              = 0x0C22;
    const GLenum COLOR_WRITEMASK                = 0x0C23;
    const GLenum UNPACK_ALIGNMENT               = 0x0CF5;
    const GLenum PACK_ALIGNMENT                 = 0x0D05;
    const GLenum MAX_TEXTURE_SIZE               = 0x0D33;
    const GLenum MAX_VIEWPORT_DIMS              = 0x0D3A;
    const GLenum SUBPIXEL_BITS                  = 0x0D50;
    const GLenum RED_BITS                       = 0x0D52;
    const GLenum GREEN_BITS                     = 0x0D53;
    const GLenum BLUE_BITS                      = 0x0D54;
    const GLenum ALPHA_BITS                     = 0x0D55;
    const GLenum DEPTH_BITS                     = 0x0D56;
    const GLenum STENCIL_BITS                   = 0x0D57;
    const GLenum POLYGON_OFFSET_UNITS           = 0x2A00;
    /*      POLYGON_OFFSET_FILL */
    const GLenum POLYGON_OFFSET_FACTOR          = 0x8038;
    const GLenum TEXTURE_BINDING_2D             = 0x8069;
    const GLenum SAMPLE_BUFFERS                 = 0x80A8;
    const GLenum SAMPLES                        = 0x80A9;
    const GLenum SAMPLE_COVERAGE_VALUE          = 0x80AA;
    const GLenum SAMPLE_COVERAGE_INVERT         = 0x80AB;
    
    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */
    
    const GLenum COMPRESSED_TEXTURE_FORMATS     = 0x86A3;
    
    /* HintMode */
    const GLenum DONT_CARE                      = 0x1100;
    const GLenum FASTEST                        = 0x1101;
    const GLenum NICEST                         = 0x1102;
    
    /* HintTarget */
    const GLenum GENERATE_MIPMAP_HINT            = 0x8192;
    
    /* DataType */
    const GLenum BYTE                           = 0x1400;
    const GLenum UNSIGNED_BYTE                  = 0x1401;
    const GLenum SHORT                          = 0x1402;
    const GLenum UNSIGNED_SHORT                 = 0x1403;
    const GLenum INT                            = 0x1404;
    const GLenum UNSIGNED_INT                   = 0x1405;
    const GLenum FLOAT                          = 0x1406;
    
    /* PixelFormat */
    const GLenum DEPTH_COMPONENT                = 0x1902;
    const GLenum ALPHA                          = 0x1906;
    const GLenum RGB                            = 0x1907;
    const GLenum RGBA                           = 0x1908;
    const GLenum LUMINANCE                      = 0x1909;
    const GLenum LUMINANCE_ALPHA                = 0x190A;
    
    /* PixelType */
    /*      UNSIGNED_BYTE */
    const GLenum UNSIGNED_SHORT_4_4_4_4         = 0x8033;
    const GLenum UNSIGNED_SHORT_5_5_5_1         = 0x8034;
    const GLenum UNSIGNED_SHORT_5_6_5           = 0x8363;
    
    /* Shaders */
    const GLenum FRAGMENT_SHADER                  = 0x8B30;
    const GLenum VERTEX_SHADER                    = 0x8B31;
    const GLenum MAX_VERTEX_ATTRIBS               = 0x8869;
    const GLenum MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
    const GLenum MAX_VARYING_VECTORS              = 0x8DFC;
    const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
    const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
    const GLenum MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
    const GLenum MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
    const GLenum SHADER_TYPE                      = 0x8B4F;
    const GLenum DELETE_STATUS                    = 0x8B80;
    const GLenum LINK_STATUS                      = 0x8B82;
    const GLenum VALIDATE_STATUS                  = 0x8B83;
    const GLenum ATTACHED_SHADERS                 = 0x8B85;
    const GLenum ACTIVE_UNIFORMS                  = 0x8B86;
    const GLenum ACTIVE_ATTRIBUTES                = 0x8B89;
    const GLenum SHADING_LANGUAGE_VERSION         = 0x8B8C;
    const GLenum CURRENT_PROGRAM                  = 0x8B8D;
    
    /* StencilFunction */
    const GLenum NEVER                          = 0x0200;
    const GLenum LESS                           = 0x0201;
    const GLenum EQUAL                          = 0x0202;
    const GLenum LEQUAL                         = 0x0203;
    const GLenum GREATER                        = 0x0204;
    const GLenum NOTEQUAL                       = 0x0205;
    const GLenum GEQUAL                         = 0x0206;
    const GLenum ALWAYS                         = 0x0207;
    
    /* StencilOp */
    /*      ZERO */
    const GLenum KEEP                           = 0x1E00;
    const GLenum REPLACE                        = 0x1E01;
    const GLenum INCR                           = 0x1E02;
    const GLenum DECR                           = 0x1E03;
    const GLenum INVERT                         = 0x150A;
    const GLenum INCR_WRAP                      = 0x8507;
    const GLenum DECR_WRAP                      = 0x8508;
    
    /* StringName */
    const GLenum VENDOR                         = 0x1F00;
    const GLenum RENDERER                       = 0x1F01;
    const GLenum VERSION                        = 0x1F02;
    
    /* TextureMagFilter */
    const GLenum NEAREST                        = 0x2600;
    const GLenum LINEAR                         = 0x2601;
    
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    const GLenum NEAREST_MIPMAP_NEAREST         = 0x2700;
    const GLenum LINEAR_MIPMAP_NEAREST          = 0x2701;
    const GLenum NEAREST_MIPMAP_LINEAR          = 0x2702;
    const GLenum LINEAR_MIPMAP_LINEAR           = 0x2703;
    
    /* TextureParameterName */
    const GLenum TEXTURE_MAG_FILTER             = 0x2800;
    const GLenum TEXTURE_MIN_FILTER             = 0x2801;
    const GLenum TEXTURE_WRAP_S                 = 0x2802;
    const GLenum TEXTURE_WRAP_T                 = 0x2803;
    
    /* TextureTarget */
    const GLenum TEXTURE_2D                     = 0x0DE1;
    const GLenum TEXTURE                        = 0x1702;
    
    const GLenum TEXTURE_CUBE_MAP               = 0x8513;
    const GLenum TEXTURE_BINDING_CUBE_MAP       = 0x8514;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
    const GLenum MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;
    
    /* TextureUnit */
    const GLenum TEXTURE0                       = 0x84C0;
    const GLenum TEXTURE1                       = 0x84C1;
    const GLenum TEXTURE2                       = 0x84C2;
    const GLenum TEXTURE3                       = 0x84C3;
    const GLenum TEXTURE4                       = 0x84C4;
    const GLenum TEXTURE5                       = 0x84C5;
    const GLenum TEXTURE6                       = 0x84C6;
    const GLenum TEXTURE7                       = 0x84C7;
    const GLenum TEXTURE8                       = 0x84C8;
    const GLenum TEXTURE9                       = 0x84C9;
    const GLenum TEXTURE10                      = 0x84CA;
    const GLenum TEXTURE11                      = 0x84CB;
    const GLenum TEXTURE12                      = 0x84CC;
    const GLenum TEXTURE13                      = 0x84CD;
    const GLenum TEXTURE14                      = 0x84CE;
    const GLenum TEXTURE15                      = 0x84CF;
    const GLenum TEXTURE16                      = 0x84D0;
    const GLenum TEXTURE17                      = 0x84D1;
    const GLenum TEXTURE18                      = 0x84D2;
    const GLenum TEXTURE19                      = 0x84D3;
    const GLenum TEXTURE20                      = 0x84D4;
    const GLenum TEXTURE21                      = 0x84D5;
    const GLenum TEXTURE22                      = 0x84D6;
    const GLenum TEXTURE23                      = 0x84D7;
    const GLenum TEXTURE24                      = 0x84D8;
    const GLenum TEXTURE25                      = 0x84D9;
    const GLenum TEXTURE26                      = 0x84DA;
    const GLenum TEXTURE27                      = 0x84DB;
    const GLenum TEXTURE28                      = 0x84DC;
    const GLenum TEXTURE29                      = 0x84DD;
    const GLenum TEXTURE30                      = 0x84DE;
    const GLenum TEXTURE31                      = 0x84DF;
    const GLenum ACTIVE_TEXTURE                 = 0x84E0;
    
    /* TextureWrapMode */
    const GLenum REPEAT                         = 0x2901;
    const GLenum CLAMP_TO_EDGE                  = 0x812F;
    const GLenum MIRRORED_REPEAT                = 0x8370;
    
    /* Uniform Types */
    const GLenum FLOAT_VEC2                     = 0x8B50;
    const GLenum FLOAT_VEC3                     = 0x8B51;
    const GLenum FLOAT_VEC4                     = 0x8B52;
    const GLenum INT_VEC2                       = 0x8B53;
    const GLenum INT_VEC3                       = 0x8B54;
    const GLenum INT_VEC4                       = 0x8B55;
    const GLenum BOOL                           = 0x8B56;
    const GLenum BOOL_VEC2                      = 0x8B57;
    const GLenum BOOL_VEC3                      = 0x8B58;
    const GLenum BOOL_VEC4                      = 0x8B59;
    const GLenum FLOAT_MAT2                     = 0x8B5A;
    const GLenum FLOAT_MAT3                     = 0x8B5B;
    const GLenum FLOAT_MAT4                     = 0x8B5C;
    const GLenum SAMPLER_2D                     = 0x8B5E;
    const GLenum SAMPLER_CUBE                   = 0x8B60;
    
    /* Vertex Arrays */
    const GLenum VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
    const GLenum VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
    const GLenum VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
    const GLenum VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
    const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
    const GLenum VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
    const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
    
    /* Shader Source */
    const GLenum COMPILE_STATUS                 = 0x8B81;
    
    /* Shader Precision-Specified Types */
    const GLenum LOW_FLOAT                      = 0x8DF0;
    const GLenum MEDIUM_FLOAT                   = 0x8DF1;
    const GLenum HIGH_FLOAT                     = 0x8DF2;
    const GLenum LOW_INT                        = 0x8DF3;
    const GLenum MEDIUM_INT                     = 0x8DF4;
    const GLenum HIGH_INT                       = 0x8DF5;
    
    /* Framebuffer Object. */
    const GLenum FRAMEBUFFER                    = 0x8D40;
    const GLenum RENDERBUFFER                   = 0x8D41;
    
    const GLenum RGBA4                          = 0x8056;
    const GLenum RGB5_A1                        = 0x8057;
    const GLenum RGB565                         = 0x8D62;
    const GLenum DEPTH_COMPONENT16              = 0x81A5;
    const GLenum STENCIL_INDEX                  = 0x1901;
    const GLenum STENCIL_INDEX8                 = 0x8D48;
    const GLenum DEPTH_STENCIL                  = 0x84F9;
    
    const GLenum RENDERBUFFER_WIDTH             = 0x8D42;
    const GLenum RENDERBUFFER_HEIGHT            = 0x8D43;
    const GLenum RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
    const GLenum RENDERBUFFER_RED_SIZE          = 0x8D50;
    const GLenum RENDERBUFFER_GREEN_SIZE        = 0x8D51;
    const GLenum RENDERBUFFER_BLUE_SIZE         = 0x8D52;
    const GLenum RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
    const GLenum RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
    const GLenum RENDERBUFFER_STENCIL_SIZE      = 0x8D55;
    
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
    
    const GLenum COLOR_ATTACHMENT0              = 0x8CE0;
    const GLenum DEPTH_ATTACHMENT               = 0x8D00;
    const GLenum STENCIL_ATTACHMENT             = 0x8D20;
    const GLenum DEPTH_STENCIL_ATTACHMENT       = 0x821A;
    
    const GLenum NONE                           = 0;
    
    const GLenum FRAMEBUFFER_COMPLETE                      = 0x8CD5;
    const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
    const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
    const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
    const GLenum FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;
    
    const GLenum FRAMEBUFFER_BINDING            = 0x8CA6;
    const GLenum RENDERBUFFER_BINDING           = 0x8CA7;
    const GLenum MAX_RENDERBUFFER_SIZE          = 0x84E8;
    
    const GLenum INVALID_FRAMEBUFFER_OPERATION  = 0x0506;
    
    /* WebGL-specific enums */
    const GLenum UNPACK_FLIP_Y_WEBGL            = 0x9240;
    const GLenum UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
    const GLenum CONTEXT_LOST_WEBGL             = 0x9242;
    const GLenum UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
    const GLenum BROWSER_DEFAULT_WEBGL          = 0x9244;

    readonly attribute HTMLCanvasElement canvas;
    readonly attribute GLsizei drawingBufferWidth;
    readonly attribute GLsizei drawingBufferHeight;

    [WebGLHandlesContextLoss] WebGLContextAttributes? getContextAttributes();
    [WebGLHandlesContextLoss] boolean isContextLost();
    
    sequence&lt;DOMString&gt;? getSupportedExtensions();
    object? getExtension(DOMString name);

    void activeTexture(GLenum texture);
    void attachShader(WebGLProgram? program, WebGLShader? shader);
    void bindAttribLocation(WebGLProgram? program, GLuint index, DOMString name);
    void bindBuffer(GLenum target, WebGLBuffer? buffer);
    void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer);
    void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer);
    void bindTexture(GLenum target, WebGLTexture? texture);
    void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void blendEquation(GLenum mode);
    void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
    void blendFunc(GLenum sfactor, GLenum dfactor);
    void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, 
                           GLenum srcAlpha, GLenum dstAlpha);

    void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
    void bufferData(GLenum target, ArrayBufferView data, GLenum usage);
    void bufferData(GLenum target, ArrayBuffer? data, GLenum usage);
    void bufferSubData(GLenum target, GLintptr offset, ArrayBufferView data);
    void bufferSubData(GLenum target, GLintptr offset, ArrayBuffer? data);

    [WebGLHandlesContextLoss] GLenum checkFramebufferStatus(GLenum target);
    void clear(GLbitfield mask);
    void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void clearDepth(GLclampf depth);
    void clearStencil(GLint s);
    void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
    void compileShader(WebGLShader? shader);

    void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat,
                              GLsizei width, GLsizei height, GLint border,
                              ArrayBufferView data);
    void compressedTexSubImage2D(GLenum target, GLint level,
                                 GLint xoffset, GLint yoffset,
                                 GLsizei width, GLsizei height, GLenum format,
                                 ArrayBufferView data);

    void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, 
                        GLint x, GLint y, GLsizei width, GLsizei height, 
                        GLint border);
    void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                           GLint x, GLint y, GLsizei width, GLsizei height);

    WebGLBuffer? createBuffer();
    WebGLFramebuffer? createFramebuffer();
    WebGLProgram? createProgram();
    WebGLRenderbuffer? createRenderbuffer();
    WebGLShader? createShader(GLenum type);
    WebGLTexture? createTexture();

    void cullFace(GLenum mode);

    void deleteBuffer(WebGLBuffer? buffer);
    void deleteFramebuffer(WebGLFramebuffer? framebuffer);
    void deleteProgram(WebGLProgram? program);
    void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer);
    void deleteShader(WebGLShader? shader);
    void deleteTexture(WebGLTexture? texture);

    void depthFunc(GLenum func);
    void depthMask(GLboolean flag);
    void depthRange(GLclampf zNear, GLclampf zFar);
    void detachShader(WebGLProgram? program, WebGLShader? shader);
    void disable(GLenum cap);
    void disableVertexAttribArray(GLuint index);
    void drawArrays(GLenum mode, GLint first, GLsizei count);
    void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset);

    void enable(GLenum cap);
    void enableVertexAttribArray(GLuint index);
    void finish();
    void flush();
    void framebufferRenderbuffer(GLenum target, GLenum attachment, 
                                 GLenum renderbuffertarget, 
                                 WebGLRenderbuffer? renderbuffer);
    void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, 
                              WebGLTexture? texture, GLint level);
    void frontFace(GLenum mode);

    void generateMipmap(GLenum target);

    WebGLActiveInfo? getActiveAttrib(WebGLProgram? program, GLuint index);
    WebGLActiveInfo? getActiveUniform(WebGLProgram? program, GLuint index);
    sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram? program);

    [WebGLHandlesContextLoss] GLint getAttribLocation(WebGLProgram? program, DOMString name);

    any getBufferParameter(GLenum target, GLenum pname);
    any getParameter(GLenum pname);

    [WebGLHandlesContextLoss] GLenum getError();

    any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, 
                                          GLenum pname);
    any getProgramParameter(WebGLProgram? program, GLenum pname);
    DOMString? getProgramInfoLog(WebGLProgram? program);
    any getRenderbufferParameter(GLenum target, GLenum pname);
    any getShaderParameter(WebGLShader? shader, GLenum pname);
    WebGLShaderPrecisionFormat? getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype);
    DOMString? getShaderInfoLog(WebGLShader? shader);

    DOMString? getShaderSource(WebGLShader? shader);

    any getTexParameter(GLenum target, GLenum pname);

    any getUniform(WebGLProgram? program, WebGLUniformLocation? location);

    WebGLUniformLocation? getUniformLocation(WebGLProgram? program, DOMString name);

    any getVertexAttrib(GLuint index, GLenum pname);

    [WebGLHandlesContextLoss] GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname);

    void hint(GLenum target, GLenum mode);
    [WebGLHandlesContextLoss] GLboolean isBuffer(WebGLBuffer? buffer);
    [WebGLHandlesContextLoss] GLboolean isEnabled(GLenum cap);
    [WebGLHandlesContextLoss] GLboolean isFramebuffer(WebGLFramebuffer? framebuffer);
    [WebGLHandlesContextLoss] GLboolean isProgram(WebGLProgram? program);
    [WebGLHandlesContextLoss] GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer);
    [WebGLHandlesContextLoss] GLboolean isShader(WebGLShader? shader);
    [WebGLHandlesContextLoss] GLboolean isTexture(WebGLTexture? texture);
    void lineWidth(GLfloat width);
    void linkProgram(WebGLProgram? program);
    void pixelStorei(GLenum pname, GLint param);
    void polygonOffset(GLfloat factor, GLfloat units);

    void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                    GLenum format, GLenum type, ArrayBufferView? pixels);

    void renderbufferStorage(GLenum target, GLenum internalformat, 
                             GLsizei width, GLsizei height);
    void sampleCoverage(GLclampf value, GLboolean invert);
    void scissor(GLint x, GLint y, GLsizei width, GLsizei height);

    void shaderSource(WebGLShader? shader, DOMString source);

    void stencilFunc(GLenum func, GLint ref, GLuint mask);
    void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
    void stencilMask(GLuint mask);
    void stencilMaskSeparate(GLenum face, GLuint mask);
    void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
    void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);

    void texImage2D(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, GLenum format, 
                    GLenum type, ArrayBufferView? pixels);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, ImageData? pixels);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLImageElement image); // May throw DOMException
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLCanvasElement canvas); // May throw DOMException
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLVideoElement video); // May throw DOMException

    void texParameterf(GLenum target, GLenum pname, GLfloat param);
    void texParameteri(GLenum target, GLenum pname, GLint param);

    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLsizei width, GLsizei height, 
                       GLenum format, GLenum type, ArrayBufferView? pixels);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, ImageData? pixels);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLImageElement image); // May throw DOMException
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLCanvasElement canvas); // May throw DOMException
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLVideoElement video); // May throw DOMException

    void uniform1f(WebGLUniformLocation? location, GLfloat x);
    void uniform1fv(WebGLUniformLocation? location, Float32Array v);
    void uniform1fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform1i(WebGLUniformLocation? location, GLint x);
    void uniform1iv(WebGLUniformLocation? location, Int32Array v);
    void uniform1iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
    void uniform2f(WebGLUniformLocation? location, GLfloat x, GLfloat y);
    void uniform2fv(WebGLUniformLocation? location, Float32Array v);
    void uniform2fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform2i(WebGLUniformLocation? location, GLint x, GLint y);
    void uniform2iv(WebGLUniformLocation? location, Int32Array v);
    void uniform2iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
    void uniform3f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z);
    void uniform3fv(WebGLUniformLocation? location, Float32Array v);
    void uniform3fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform3i(WebGLUniformLocation? location, GLint x, GLint y, GLint z);
    void uniform3iv(WebGLUniformLocation? location, Int32Array v);
    void uniform3iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
    void uniform4f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void uniform4fv(WebGLUniformLocation? location, Float32Array v);
    void uniform4fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform4i(WebGLUniformLocation? location, GLint x, GLint y, GLint z, GLint w);
    void uniform4iv(WebGLUniformLocation? location, Int32Array v);
    void uniform4iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);

    void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, 
                          sequence&lt;GLfloat&gt; value);
    void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, 
                          sequence&lt;GLfloat&gt; value);
    void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, 
                          sequence&lt;GLfloat&gt; value);

    void useProgram(WebGLProgram? program);
    void validateProgram(WebGLProgram? program);

    void vertexAttrib1f(GLuint indx, GLfloat x);
    void vertexAttrib1fv(GLuint indx, Float32Array values);
    void vertexAttrib1fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
    void vertexAttrib2fv(GLuint indx, Float32Array values);
    void vertexAttrib2fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
    void vertexAttrib3fv(GLuint indx, Float32Array values);
    void vertexAttrib3fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void vertexAttrib4fv(GLuint indx, Float32Array values);
    void vertexAttrib4fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttribPointer(GLuint indx, GLint size, GLenum type, 
                             GLboolean normalized, GLsizei stride, GLintptr offset);

    void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
};

interface <dfn id="WebGLRenderingContext">WebGLRenderingContext</dfn> implements WebGLRenderingContextBase
{
};

[NoInterfaceObject]
interface <dfn id="WebGL2RenderingContextBase">WebGL2RenderingContextBase</dfn> implements WebGLRenderingContextBase
{
  const GLenum READ_BUFFER                                   = 0x0C02;
  const GLenum UNPACK_ROW_LENGTH                             = 0x0CF2;
  const GLenum UNPACK_SKIP_ROWS                              = 0x0CF3;
  const GLenum UNPACK_SKIP_PIXELS                            = 0x0CF4;
  const GLenum PACK_ROW_LENGTH                               = 0x0D02;
  const GLenum PACK_SKIP_ROWS                                = 0x0D03;
  const GLenum PACK_SKIP_PIXELS                              = 0x0D04;
  const GLenum COLOR                                         = 0x1800;
  const GLenum DEPTH                                         = 0x1801;
  const GLenum STENCIL                                       = 0x1802;
  const GLenum RED                                           = 0x1903;
  const GLenum RGB8                                          = 0x8051;
  const GLenum RGBA8                                         = 0x8058;
  const GLenum RGB10_A2                                      = 0x8059;
  const GLenum TEXTURE_BINDING_3D                            = 0x806A;
  const GLenum UNPACK_SKIP_IMAGES                            = 0x806D;
  const GLenum UNPACK_IMAGE_HEIGHT                           = 0x806E;
  const GLenum TEXTURE_3D                                    = 0x806F;
  const GLenum TEXTURE_WRAP_R                                = 0x8072;
  const GLenum MAX_3D_TEXTURE_SIZE                           = 0x8073;
  const GLenum UNSIGNED_INT_2_10_10_10_REV                   = 0x8368;
  const GLenum MAX_ELEMENTS_VERTICES                         = 0x80E8;
  const GLenum MAX_ELEMENTS_INDICES                          = 0x80E9;
  const GLenum TEXTURE_MIN_LOD                               = 0x813A;
  const GLenum TEXTURE_MAX_LOD                               = 0x813B;
  const GLenum TEXTURE_BASE_LEVEL                            = 0x813C;
  const GLenum TEXTURE_MAX_LEVEL                             = 0x813D;
  const GLenum MIN                                           = 0x8007;
  const GLenum MAX                                           = 0x8008;
  const GLenum DEPTH_COMPONENT24                             = 0x81A6;
  const GLenum MAX_TEXTURE_LOD_BIAS                          = 0x84FD;
  const GLenum TEXTURE_COMPARE_MODE                          = 0x884C;
  const GLenum TEXTURE_COMPARE_FUNC                          = 0x884D;
  const GLenum CURRENT_QUERY                                 = 0x8865;
  const GLenum QUERY_RESULT                                  = 0x8866;
  const GLenum QUERY_RESULT_AVAILABLE                        = 0x8867;
  const GLenum BUFFER_MAPPED                                 = 0x88BC;
  const GLenum BUFFER_MAP_POINTER                            = 0x88BD;
  const GLenum STREAM_READ                                   = 0x88E1;
  const GLenum STREAM_COPY                                   = 0x88E2;
  const GLenum STATIC_READ                                   = 0x88E5;
  const GLenum STATIC_COPY                                   = 0x88E6;
  const GLenum DYNAMIC_READ                                  = 0x88E9;
  const GLenum DYNAMIC_COPY                                  = 0x88EA;
  const GLenum MAX_DRAW_BUFFERS                              = 0x8824;
  const GLenum DRAW_BUFFER0                                  = 0x8825;
  const GLenum DRAW_BUFFER1                                  = 0x8826;
  const GLenum DRAW_BUFFER2                                  = 0x8827;
  const GLenum DRAW_BUFFER3                                  = 0x8828;
  const GLenum DRAW_BUFFER4                                  = 0x8829;
  const GLenum DRAW_BUFFER5                                  = 0x882A;
  const GLenum DRAW_BUFFER6                                  = 0x882B;
  const GLenum DRAW_BUFFER7                                  = 0x882C;
  const GLenum DRAW_BUFFER8                                  = 0x882D;
  const GLenum DRAW_BUFFER9                                  = 0x882E;
  const GLenum DRAW_BUFFER10                                 = 0x882F;
  const GLenum DRAW_BUFFER11                                 = 0x8830;
  const GLenum DRAW_BUFFER12                                 = 0x8831;
  const GLenum DRAW_BUFFER13                                 = 0x8832;
  const GLenum DRAW_BUFFER14                                 = 0x8833;
  const GLenum DRAW_BUFFER15                                 = 0x8834;
  const GLenum MAX_FRAGMENT_UNIFORM_COMPONENTS               = 0x8B49;
  const GLenum MAX_VERTEX_UNIFORM_COMPONENTS                 = 0x8B4A;
  const GLenum SAMPLER_3D                                    = 0x8B5F;
  const GLenum SAMPLER_2D_SHADOW                             = 0x8B62;
  const GLenum FRAGMENT_SHADER_DERIVATIVE_HINT               = 0x8B8B;
  const GLenum PIXEL_PACK_BUFFER                             = 0x88EB;
  const GLenum PIXEL_UNPACK_BUFFER                           = 0x88EC;
  const GLenum PIXEL_PACK_BUFFER_BINDING                     = 0x88ED;
  const GLenum PIXEL_UNPACK_BUFFER_BINDING                   = 0x88EF;
  const GLenum FLOAT_MAT2x3                                  = 0x8B65;
  const GLenum FLOAT_MAT2x4                                  = 0x8B66;
  const GLenum FLOAT_MAT3x2                                  = 0x8B67;
  const GLenum FLOAT_MAT3x4                                  = 0x8B68;
  const GLenum FLOAT_MAT4x2                                  = 0x8B69;
  const GLenum FLOAT_MAT4x3                                  = 0x8B6A;
  const GLenum SRGB                                          = 0x8C40;
  const GLenum SRGB8                                         = 0x8C41;
  const GLenum SRGB8_ALPHA8                                  = 0x8C43;
  const GLenum COMPARE_REF_TO_TEXTURE                        = 0x884E;
  const GLenum RGBA32F                                       = 0x8814;
  const GLenum RGB32F                                        = 0x8815;
  const GLenum RGBA16F                                       = 0x881A;
  const GLenum RGB16F                                        = 0x881B;
  const GLenum VERTEX_ATTRIB_ARRAY_INTEGER                   = 0x88FD;
  const GLenum MAX_ARRAY_TEXTURE_LAYERS                      = 0x88FF;
  const GLenum MIN_PROGRAM_TEXEL_OFFSET                      = 0x8904;
  const GLenum MAX_PROGRAM_TEXEL_OFFSET                      = 0x8905;
  const GLenum MAX_VARYING_COMPONENTS                        = 0x8B4B;
  const GLenum TEXTURE_2D_ARRAY                              = 0x8C1A;
  const GLenum TEXTURE_BINDING_2D_ARRAY                      = 0x8C1D;
  const GLenum R11F_G11F_B10F                                = 0x8C3A;
  const GLenum UNSIGNED_INT_10F_11F_11F_REV                  = 0x8C3B;
  const GLenum RGB9_E5                                       = 0x8C3D;
  const GLenum UNSIGNED_INT_5_9_9_9_REV                      = 0x8C3E;
  const GLenum TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH         = 0x8C76;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_MODE                = 0x8C7F;
  const GLenum MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS    = 0x8C80;
  const GLenum TRANSFORM_FEEDBACK_VARYINGS                   = 0x8C83;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_START               = 0x8C84;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_SIZE                = 0x8C85;
  const GLenum TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN         = 0x8C88;
  const GLenum RASTERIZER_DISCARD                            = 0x8C89;
  const GLenum MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A;
  const GLenum MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS       = 0x8C8B;
  const GLenum INTERLEAVED_ATTRIBS                           = 0x8C8C;
  const GLenum SEPARATE_ATTRIBS                              = 0x8C8D;
  const GLenum TRANSFORM_FEEDBACK_BUFFER                     = 0x8C8E;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_BINDING             = 0x8C8F;
  const GLenum RGBA32UI                                      = 0x8D70;
  const GLenum RGB32UI                                       = 0x8D71;
  const GLenum RGBA16UI                                      = 0x8D76;
  const GLenum RGB16UI                                       = 0x8D77;
  const GLenum RGBA8UI                                       = 0x8D7C;
  const GLenum RGB8UI                                        = 0x8D7D;
  const GLenum RGBA32I                                       = 0x8D82;
  const GLenum RGB32I                                        = 0x8D83;
  const GLenum RGBA16I                                       = 0x8D88;
  const GLenum RGB16I                                        = 0x8D89;
  const GLenum RGBA8I                                        = 0x8D8E;
  const GLenum RGB8I                                         = 0x8D8F;
  const GLenum RED_INTEGER                                   = 0x8D94;
  const GLenum RGB_INTEGER                                   = 0x8D98;
  const GLenum RGBA_INTEGER                                  = 0x8D99;
  const GLenum SAMPLER_2D_ARRAY                              = 0x8DC1;
  const GLenum SAMPLER_2D_ARRAY_SHADOW                       = 0x8DC4;
  const GLenum SAMPLER_CUBE_SHADOW                           = 0x8DC5;
  const GLenum UNSIGNED_INT_VEC2                             = 0x8DC6;
  const GLenum UNSIGNED_INT_VEC3                             = 0x8DC7;
  const GLenum UNSIGNED_INT_VEC4                             = 0x8DC8;
  const GLenum INT_SAMPLER_2D                                = 0x8DCA;
  const GLenum INT_SAMPLER_3D                                = 0x8DCB;
  const GLenum INT_SAMPLER_CUBE                              = 0x8DCC;
  const GLenum INT_SAMPLER_2D_ARRAY                          = 0x8DCF;
  const GLenum UNSIGNED_INT_SAMPLER_2D                       = 0x8DD2;
  const GLenum UNSIGNED_INT_SAMPLER_3D                       = 0x8DD3;
  const GLenum UNSIGNED_INT_SAMPLER_CUBE                     = 0x8DD4;
  const GLenum UNSIGNED_INT_SAMPLER_2D_ARRAY                 = 0x8DD7;
  const GLenum BUFFER_ACCESS_FLAGS                           = 0x911F;
  const GLenum BUFFER_MAP_LENGTH                             = 0x9120;
  const GLenum BUFFER_MAP_OFFSET                             = 0x9121;
  const GLenum DEPTH_COMPONENT32F                            = 0x8CAC;
  const GLenum DEPTH32F_STENCIL8                             = 0x8CAD;
  const GLenum FLOAT_32_UNSIGNED_INT_24_8_REV                = 0x8DAD;
  const GLenum FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING         = 0x8210;
  const GLenum FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE         = 0x8211;
  const GLenum FRAMEBUFFER_ATTACHMENT_RED_SIZE               = 0x8212;
  const GLenum FRAMEBUFFER_ATTACHMENT_GREEN_SIZE             = 0x8213;
  const GLenum FRAMEBUFFER_ATTACHMENT_BLUE_SIZE              = 0x8214;
  const GLenum FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE             = 0x8215;
  const GLenum FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE             = 0x8216;
  const GLenum FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE           = 0x8217;
  const GLenum FRAMEBUFFER_DEFAULT                           = 0x8218;
  const GLenum FRAMEBUFFER_UNDEFINED                         = 0x8219;
  const GLenum DEPTH_STENCIL_ATTACHMENT                      = 0x821A;
  const GLenum DEPTH_STENCIL                                 = 0x84F9;
  const GLenum UNSIGNED_INT_24_8                             = 0x84FA;
  const GLenum DEPTH24_STENCIL8                              = 0x88F0;
  const GLenum UNSIGNED_NORMALIZED                           = 0x8C17;
  const GLenum DRAW_FRAMEBUFFER_BINDING                      = 0x8CA6; /* Same as FRAMEBUFFER_BINDING */
  const GLenum READ_FRAMEBUFFER                              = 0x8CA8;
  const GLenum DRAW_FRAMEBUFFER                              = 0x8CA9;
  const GLenum READ_FRAMEBUFFER_BINDING                      = 0x8CAA;
  const GLenum RENDERBUFFER_SAMPLES                          = 0x8CAB;
  const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER          = 0x8CD4;
  const GLenum MAX_COLOR_ATTACHMENTS                         = 0x8CDF;
  const GLenum COLOR_ATTACHMENT1                             = 0x8CE1;
  const GLenum COLOR_ATTACHMENT2                             = 0x8CE2;
  const GLenum COLOR_ATTACHMENT3                             = 0x8CE3;
  const GLenum COLOR_ATTACHMENT4                             = 0x8CE4;
  const GLenum COLOR_ATTACHMENT5                             = 0x8CE5;
  const GLenum COLOR_ATTACHMENT6                             = 0x8CE6;
  const GLenum COLOR_ATTACHMENT7                             = 0x8CE7;
  const GLenum COLOR_ATTACHMENT8                             = 0x8CE8;
  const GLenum COLOR_ATTACHMENT9                             = 0x8CE9;
  const GLenum COLOR_ATTACHMENT10                            = 0x8CEA;
  const GLenum COLOR_ATTACHMENT11                            = 0x8CEB;
  const GLenum COLOR_ATTACHMENT12                            = 0x8CEC;
  const GLenum COLOR_ATTACHMENT13                            = 0x8CED;
  const GLenum COLOR_ATTACHMENT14                            = 0x8CEE;
  const GLenum COLOR_ATTACHMENT15                            = 0x8CEF;
  const GLenum FRAMEBUFFER_INCOMPLETE_MULTISAMPLE            = 0x8D56;
  const GLenum MAX_SAMPLES                                   = 0x8D57;
  const GLenum HALF_FLOAT                                    = 0x140B;
  const GLenum MAP_READ_BIT                                  = 0x0001;
  const GLenum MAP_WRITE_BIT                                 = 0x0002;
  const GLenum MAP_INVALIDATE_RANGE_BIT                      = 0x0004;
  const GLenum MAP_INVALIDATE_BUFFER_BIT                     = 0x0008;
  const GLenum MAP_FLUSH_EXPLICIT_BIT                        = 0x0010;
  const GLenum MAP_UNSYNCHRONIZED_BIT                        = 0x0020;
  const GLenum RG                                            = 0x8227;
  const GLenum RG_INTEGER                                    = 0x8228;
  const GLenum R8                                            = 0x8229;
  const GLenum RG8                                           = 0x822B;
  const GLenum R16F                                          = 0x822D;
  const GLenum R32F                                          = 0x822E;
  const GLenum RG16F                                         = 0x822F;
  const GLenum RG32F                                         = 0x8230;
  const GLenum R8I                                           = 0x8231;
  const GLenum R8UI                                          = 0x8232;
  const GLenum R16I                                          = 0x8233;
  const GLenum R16UI                                         = 0x8234;
  const GLenum R32I                                          = 0x8235;
  const GLenum R32UI                                         = 0x8236;
  const GLenum RG8I                                          = 0x8237;
  const GLenum RG8UI                                         = 0x8238;
  const GLenum RG16I                                         = 0x8239;
  const GLenum RG16UI                                        = 0x823A;
  const GLenum RG32I                                         = 0x823B;
  const GLenum RG32UI                                        = 0x823C;
  const GLenum VERTEX_ARRAY_BINDING                          = 0x85B5;
  const GLenum R8_SNORM                                      = 0x8F94;
  const GLenum RG8_SNORM                                     = 0x8F95;
  const GLenum RGB8_SNORM                                    = 0x8F96;
  const GLenum RGBA8_SNORM                                   = 0x8F97;
  const GLenum SIGNED_NORMALIZED                             = 0x8F9C;
  const GLenum PRIMITIVE_RESTART_FIXED_INDEX                 = 0x8D69;
  const GLenum COPY_READ_BUFFER                              = 0x8F36;
  const GLenum COPY_WRITE_BUFFER                             = 0x8F37;
  const GLenum COPY_READ_BUFFER_BINDING                      = 0x8F36; /* Same as COPY_READ_BUFFER */
  const GLenum COPY_WRITE_BUFFER_BINDING                     = 0x8F37; /* Same as COPY_WRITE_BUFFER */
  const GLenum UNIFORM_BUFFER                                = 0x8A11;
  const GLenum UNIFORM_BUFFER_BINDING                        = 0x8A28;
  const GLenum UNIFORM_BUFFER_START                          = 0x8A29;
  const GLenum UNIFORM_BUFFER_SIZE                           = 0x8A2A;
  const GLenum MAX_VERTEX_UNIFORM_BLOCKS                     = 0x8A2B;
  const GLenum MAX_FRAGMENT_UNIFORM_BLOCKS                   = 0x8A2D;
  const GLenum MAX_COMBINED_UNIFORM_BLOCKS                   = 0x8A2E;
  const GLenum MAX_UNIFORM_BUFFER_BINDINGS                   = 0x8A2F;
  const GLenum MAX_UNIFORM_BLOCK_SIZE                        = 0x8A30;
  const GLenum MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS        = 0x8A31;
  const GLenum MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS      = 0x8A33;
  const GLenum UNIFORM_BUFFER_OFFSET_ALIGNMENT               = 0x8A34;
  const GLenum ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH          = 0x8A35;
  const GLenum ACTIVE_UNIFORM_BLOCKS                         = 0x8A36;
  const GLenum UNIFORM_TYPE                                  = 0x8A37;
  const GLenum UNIFORM_SIZE                                  = 0x8A38;
  const GLenum UNIFORM_NAME_LENGTH                           = 0x8A39;
  const GLenum UNIFORM_BLOCK_INDEX                           = 0x8A3A;
  const GLenum UNIFORM_OFFSET                                = 0x8A3B;
  const GLenum UNIFORM_ARRAY_STRIDE                          = 0x8A3C;
  const GLenum UNIFORM_MATRIX_STRIDE                         = 0x8A3D;
  const GLenum UNIFORM_IS_ROW_MAJOR                          = 0x8A3E;
  const GLenum UNIFORM_BLOCK_BINDING                         = 0x8A3F;
  const GLenum UNIFORM_BLOCK_DATA_SIZE                       = 0x8A40;
  const GLenum UNIFORM_BLOCK_NAME_LENGTH                     = 0x8A41;
  const GLenum UNIFORM_BLOCK_ACTIVE_UNIFORMS                 = 0x8A42;
  const GLenum UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES          = 0x8A43;
  const GLenum UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER     = 0x8A44;
  const GLenum UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER   = 0x8A46;
  const GLenum INVALID_INDEX                                 = 0xFFFFFFFFu; /* TODO: valid GLenum? */
  const GLenum MAX_VERTEX_OUTPUT_COMPONENTS                  = 0x9122;
  const GLenum MAX_FRAGMENT_INPUT_COMPONENTS                 = 0x9125;
  const GLenum MAX_SERVER_WAIT_TIMEOUT                       = 0x9111;
  const GLenum OBJECT_TYPE                                   = 0x9112;
  const GLenum SYNC_CONDITION                                = 0x9113;
  const GLenum SYNC_STATUS                                   = 0x9114;
  const GLenum SYNC_FLAGS                                    = 0x9115;
  const GLenum SYNC_FENCE                                    = 0x9116;
  const GLenum SYNC_GPU_COMMANDS_COMPLETE                    = 0x9117;
  const GLenum UNSIGNALED                                    = 0x9118;
  const GLenum SIGNALED                                      = 0x9119;
  const GLenum ALREADY_SIGNALED                              = 0x911A;
  const GLenum TIMEOUT_EXPIRED                               = 0x911B;
  const GLenum CONDITION_SATISFIED                           = 0x911C;
  const GLenum WAIT_FAILED                                   = 0x911D;
  const GLenum SYNC_FLUSH_COMMANDS_BIT                       = 0x00000001;
  const GLenum TIMEOUT_IGNORED                               = 0xFFFFFFFFFFFFFFFFull;  /* TODO: valid GLenum? */
  const GLenum VERTEX_ATTRIB_ARRAY_DIVISOR                   = 0x88FE;
  const GLenum ANY_SAMPLES_PASSED                            = 0x8C2F;
  const GLenum ANY_SAMPLES_PASSED_CONSERVATIVE               = 0x8D6A;
  const GLenum SAMPLER_BINDING                               = 0x8919;
  const GLenum RGB10_A2UI                                    = 0x906F;
  const GLenum TEXTURE_SWIZZLE_R                             = 0x8E42;
  const GLenum TEXTURE_SWIZZLE_G                             = 0x8E43;
  const GLenum TEXTURE_SWIZZLE_B                             = 0x8E44;
  const GLenum TEXTURE_SWIZZLE_A                             = 0x8E45;
  const GLenum GREEN                                         = 0x1904;
  const GLenum BLUE                                          = 0x1905;
  const GLenum INT_2_10_10_10_REV                            = 0x8D9F;
  const GLenum TRANSFORM_FEEDBACK                            = 0x8E22;
  const GLenum TRANSFORM_FEEDBACK_PAUSED                     = 0x8E23;
  const GLenum TRANSFORM_FEEDBACK_ACTIVE                     = 0x8E24;
  const GLenum TRANSFORM_FEEDBACK_BINDING                    = 0x8E25;
  const GLenum COMPRESSED_R11_EAC                            = 0x9270;
  const GLenum COMPRESSED_SIGNED_R11_EAC                     = 0x9271;
  const GLenum COMPRESSED_RG11_EAC                           = 0x9272;
  const GLenum COMPRESSED_SIGNED_RG11_EAC                    = 0x9273;
  const GLenum COMPRESSED_RGB8_ETC2                          = 0x9274;
  const GLenum COMPRESSED_SRGB8_ETC2                         = 0x9275;
  const GLenum COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2      = 0x9276;
  const GLenum COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2     = 0x9277;
  const GLenum COMPRESSED_RGBA8_ETC2_EAC                     = 0x9278;
  const GLenum COMPRESSED_SRGB8_ALPHA8_ETC2_EAC              = 0x9279;
  const GLenum TEXTURE_IMMUTABLE_FORMAT                      = 0x912F;
  const GLenum MAX_ELEMENT_INDEX                             = 0x8D6B;
  const GLenum NUM_SAMPLE_COUNTS                             = 0x9380;
  const GLenum TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF;

  /* Buffer objects */
  void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);

  /* Framebuffer objects */
  void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
  void framebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
  any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
  void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
  void invalidateSubFramebuffer (GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height);
  void readBuffer(GLenum mode);
  void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

  /* Texture objects */
  void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
  void texStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
  void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
  /* TODO: think about texImage3D and texSubImage3D taking HTML data (images, video) */
  void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
  void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, ArrayBufferView? pixels);
  void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, ArrayBufferView data);
  void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, ArrayBufferView data);

  /* Programs and shaders */
  [WebGLHandlesContextLoss] GLint getFragDataLocation(WebGLProgram? program, DOMString name);

  /* Uniforms and attributes */
  void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);

  /* TODO: these will have to be exposed differently -- for example,
     by changing the return type of getVertexAttrib based on the
     most recently set type for the vertex attrib */
  // void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params);
  // void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params);

  void uniform1ui(WebGLUniformLocation? location, GLuint v0);
  void uniform2ui(WebGLUniformLocation? location, GLuint v0, GLuint v1);
  void uniform3ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
  void uniform4ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
  void uniform1uiv(WebGLUniformLocation? location, sequence&lt;GLuint&gt; value);
  void uniform2uiv(WebGLUniformLocation? location, sequence&lt;GLuint&gt; value);
  void uniform3uiv(WebGLUniformLocation? location, sequence&lt;GLuint&gt; value);
  void uniform4uiv(WebGLUniformLocation? location, sequence&lt;GLuint&gt; value);
  void uniformMatrix2x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32Array value);
  void uniformMatrix2x3fv(WebGLUniformLocation? location, GLboolean transpose, sequence&lt;GLfloat&gt; value);
  void uniformMatrix3x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32Array value);
  void uniformMatrix3x2fv(WebGLUniformLocation? location, GLboolean transpose, sequence&lt;GLfloat&gt; value);
  void uniformMatrix2x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32Array value);
  void uniformMatrix2x4fv(WebGLUniformLocation? location, GLboolean transpose, sequence&lt;GLfloat&gt; value);
  void uniformMatrix4x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32Array value);
  void uniformMatrix4x2fv(WebGLUniformLocation? location, GLboolean transpose, sequence&lt;GLfloat&gt; value);
  void uniformMatrix3x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32Array value);
  void uniformMatrix3x4fv(WebGLUniformLocation? location, GLboolean transpose, sequence&lt;GLfloat&gt; value);
  void uniformMatrix4x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32Array value);
  void uniformMatrix4x3fv(WebGLUniformLocation? location, GLboolean transpose, sequence&lt;GLfloat&gt; value);
  /* TODO: this will be exposed as a couple of additional entries in
     the return type table for getUniform */
  // void glGetUniformuiv (GLuint program, GLint location, GLuint* params);
  void vertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
  void vertexAttribI4iv(GLuint index, sequence&lt;GLint&gt; v);
  void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
  void vertexAttribI4uiv(GLuint index, sequence&lt;GLuint&gt; v);

  /* Writing to the drawing buffer */
  void vertexAttribDivisor(GLuint index, GLuint divisor);
  void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount);
  void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount);
  /* TODO(kbr): argue against exposing this because it can't safely
     offer better performance than drawElements */
  void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset);

  /* Multiple Render Targets */
  void drawBuffers(sequence&lt;GLenum&gt; buffers);
  /* TODO: consider collapsing these four entry points into
     one. However, that may not be possible due to Web IDL's
     overloading rules. */
  void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32Array value);
  void clearBufferiv(GLenum buffer, GLint drawbuffer, sequence&lt;GLint&gt; value);
  void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32Array value);
  void clearBufferuiv(GLenum buffer, GLint drawbuffer, sequence&lt;GLuint&gt; value);
  void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32Array value);
  void clearBufferfv(GLenum buffer, GLint drawbuffer, sequence&lt;GLfloat&gt; value);
  void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);

  /* Query Objects */
  /* TODO: discuss further the exact form of this API */
  WebGLQuery? createQuery();
  void deleteQuery(WebGLQuery? query);
  [WebGLHandlesContextLoss] GLboolean isQuery(WebGLQuery? query);
  void beginQuery(GLenum target, WebGLQuery? query);
  void endQuery(GLenum target);
  /* TODO: document return type */
  any getQuery(GLenum target, GLenum pname);
  /* TODO: document return type */
  any getQueryParameter(WebGLQuery? query, GLenum pname);

  /* Sampler Objects */
  WebGLSampler? createSampler();
  void deleteSampler(WebGLSampler? sampler);
  [WebGLHandlesContextLoss] GLboolean isSampler(WebGLSampler? sampler);
  void bindSampler(GLuint unit, WebGLSampler? sampler);
  void samplerParameteri(WebGLSampler? sampler, GLenum pname, GLint param);
  void samplerParameteriv(WebGLSampler? sampler, GLenum pname, Int32Array param);
  void samplerParameteriv(WebGLSampler? sampler, GLenum pname, sequence&lt;GLint&gt; param);
  void samplerParameterf(WebGLSampler? sampler, GLenum pname, GLfloat param);
  void samplerParameterfv(WebGLSampler? sampler, GLenum pname, Float32Array param);
  void samplerParameterfv(WebGLSampler? sampler, GLenum pname, sequence&lt;GLfloat&gt; param);

  /* TODO: document return type */
  any getSamplerParameter(WebGLSampler? sampler, GLenum pname);

  /* Sync objects */
  WebGLSync? fenceSync(GLenum condition, GLbitfield flags);
  GLboolean isSync(WebGLSync? sync);
  void deleteSync(WebGLSync? sync);
  GLenum clientWaitSync(WebGLSync? sync, GLbitfield flags, GLuint64 timeout);
  void waitSync(WebGLSync? sync, GLbitfield flags, GLuint64 timeout);
  /* TODO: document return type */
  any getSyncParameter(WebGLSync? sync, GLenum pname);

  /* Transform Feedback */
  WebGLTransformFeedback? createTransformFeedback();
  void deleteTransformFeedback(WebGLTransformFeedback?);
  [WebGLHandlesContextLoss] GLboolean isTransformFeedback(WebGLTransformFeedback?);
  void bindTransformFeedback (GLenum target, GLuint id);
  void beginTransformFeedback(GLenum primitiveMode);
  void endTransformFeedback();
  void transformFeedbackVaryings(WebGLProgram? program, GLsizei count, sequence&lt;DOMString&gt; varyings, GLenum bufferMode);
  WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram? program, GLuint index);
  void pauseTransformFeedback();
  void resumeTransformFeedback();

  /* Uniform Buffer Objects and Transform Feedback Buffers */
  void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer);
  void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size);
  /* TODO: figure out whether to overload getParameter, add getIndexedParameter, or some other solution */
  // void getIntegeri_v (GLenum target, GLuint index, GLint* data);
  sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram? program, sequence&lt;DOMString&gt; uniformNames);
  sequence&lt;GLint&gt;? getActiveUniforms(WebGLProgram? program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname);
  GLuint getUniformBlockIndex(WebGLProgram? program, DOMString uniformBlockName);
  /* TODO: document return type; make sure unnecessary enums are deleted */
  any getActiveUniformBlockParameter(WebGLProgram? program, GLuint uniformBlockIndex, GLenum pname);
  /* TODO: if there were a fake enum for GL_UNIFORM_BLOCK_NAME, then this could be folded into getActiveUniformBlockParameter */
  DOMString? getActiveUniformBlockName(WebGLProgram? program, GLuint uniformBlockIndex);
  void uniformBlockBinding(WebGLProgram? program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);

  /* Vertex Array Objects */
  WebGLVertexArrayObject? createVertexArray();
  void deleteVertexArray(WebGLVertexArrayObject? vertexArray);
  [WebGLHandlesContextLoss] GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray);
  void bindVertexArray(WebGLVertexArrayObject? array);

  /* TODO:
   *  - Consider adding getBufferSubData replacing MapBufferRange, etc.
   *  - Figure out what to do about glMapBufferRange, glFlushMappedBufferRange, glUnmapBuffer
   *    - If exposing these, think about glGetBufferPointerv
   *  - Is it necessary to expose glGetInteger64v, glGetInteger64i_v, and glGetBufferParameteri64v?
   *    - Or are they subsumed into other queries' signatures?
   *  - Deliberately not exposing glGetProgramBinary, glProgramBinary, glProgramParameteri
   */
};

interface <dfn id="WebGL2RenderingContext">WebGL2RenderingContext</dfn> implements WebGL2RenderingContextBase
{
};

</pre>

<!-- ======================================================================================================= -->

    <h4>Setting and getting state</h4>

    <dl class="methods">
        <dt class="idl-code"><a name="GETPARAMETER">any getParameter</a>(GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glGet.xml">
                (glGet OpenGL ES 3.0 man page)
            </a>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glGetString.xml">
                (glGetString OpenGL ES 3.0 man page)
            </a>
        <dd>
            Return the value for the passed pname. As well as supporting all
            the pname/type values from WebGL 1.0, the following parameters are supported:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>COPY_READ_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>COPY_WRITE_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>DRAW_BINDING</td><td>GLenum</td></tr>
                <tr><td>DRAW_FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>FRAGMENT_SHADER_DERIVATIVE_HINT</td><td>GLenum</td></tr>
                <tr><td>IMPLEMENTATION_COLOR_READ_FORMAT</td><td>GLenum</td></tr>
                <tr><td>IMPLEMENTATION_COLOR_READ_TYPE</td><td>GLenum</td></tr>
                <tr><td>MAX_3D_TEXTURE_SIZE</td><td>GLint</td></tr>
                <tr><td>MAX_ARRAY_TEXTURE_LAYERS</td><td>GLint</td></tr>
                <tr><td>MAX_COLOR_ATTACHMENTS</td><td>GLint</td></tr>
                <tr><td>MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_COMBINED_UNIFORM_BLOCKS</td><td>GLint</td></tr>
                <tr><td>MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_DRAW_BUFFERS</td><td>GLint</td></tr>
                <tr><td>MAX_ELEMENT_INDEX</td><td>GLint</td></tr>
                <tr><td>MAX_ELEMENTS_INDICES</td><td>GLint</td></tr>
                <tr><td>MAX_ELEMENTS_VERTICES</td><td>GLint</td></tr>
                <tr><td>MAX_FRAGMENT_INPUT_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_BLOCKS</td><td>GLint</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_PROGRAM_TEXEL_OFFSET</td><td>GLint</td></tr>
                <tr><td>MAX_SAMPLES</td><td>GLint</td></tr>
                <tr><td>MAX_SERVER_WAIT_TIMEOUT</td><td>GLuint64</td></tr>
                <tr><td>MAX_TEXTURE_LOD_BIAS</td><td>GLint</td></tr>
                <tr><td>MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS</td><td>GLint</td></tr>
                <tr><td>MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_UNIFORM_BLOCK_SIZE</td><td>GLint</td></tr>
                <tr><td>MAX_UNIFORM_BUFFER_BINDINGS</td><td>GLint</td></tr>
                <tr><td>MAX_VARYING_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_OUTPUT_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_BLOCKS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MIN_PROGRAM_TEXEL_OFFSET</td><td>GLint</td></tr>
                <tr><td>PACK_IMAGE_HEIGHT</td><td>GLint</td></tr>
                <tr><td>PACK_ROW_LENGTH</td><td>GLint</td></tr>
                <tr><td>PACK_SKIP_IMAGES</td><td>GLint</td></tr>
                <tr><td>PACK_SKIP_PIXELS</td><td>GLint</td></tr>
                <tr><td>PACK_SKIP_ROWS</td><td>GLint</td></tr>
                <tr><td>PIXEL_PACK_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>PIXEL_UNPACK_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>PRIMITIVE_RESTART_FIXED_INDEX</td><td>GLboolean</td></tr>
                <tr><td>READ_BUFFER</td><td>GLenum</td></tr>
                <tr><td>READ_FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>SAMPLE_ALPHA_TO_COVERAGE</td><td>GLboolean</td></tr>
                <tr><td>SAMPLE_COVERAGE</td><td>GLboolean</td></tr>
                <tr><td>SAMPLER_BINDING</td><td>WebGLSampler</td></tr>
                <tr><td>TEXTURE_BINDING_2D_ARRAY</td><td>WebGLTexture</td></tr>
                <tr><td>TEXTURE_BINDING_3D</td><td>WebGLTexture</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_ACTIVE</td><td>GLboolean</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_PAUSED</td><td>GLboolean</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_BUFFER_SIZE</td><td>GLint</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_BUFFER_START</td><td>GLint</td></tr>
                <tr><td>UNIFORM_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>UNIFORM_BUFFER_OFFSET_ALIGNMENT</td><td>GLint</td></tr>
                <tr><td>UNIFORM_BUFFER_SIZE</td><td>GLint</td></tr>
                <tr><td>UNIFORM_BUFFER_START</td><td>GLint</td></tr>
                <tr><td>UNPACK_IMAGE_HEIGHT</td><td>GLint</td></tr>
                <tr><td>UNPACK_ROW_LENGTH</td><td>GLint</td></tr>
                <tr><td>UNPACK_SKIP_IMAGES</td><td>GLboolean</td></tr>
                <tr><td>UNPACK_SKIP_PIXELS</td><td>GLboolean</td></tr>
                <tr><td>UNPACK_SKIP_ROWS</td><td>GLboolean</td></tr>
                <tr><td>VERTEX_ARRAY_BINDING</td><td>WebGLVertexArrayObject</td></tr>
            </table><br>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Buffer objects</h4>

    <dl class="methods">
      <!--
      <dt>
        <p class="idl-code">
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-2.9.5">OpenGL ES 3.0 &sect;2.9.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glCopyBufferSubData.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      -->
      <dt>
        <p class="idl-code">void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-2.9.5">OpenGL ES 3.0.2 &sect;2.9.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glCopyBufferSubData.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Framebuffer objects</h4>

    <dl class="methods">
      <dt>
        <p class="idl-code">void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-4.3.2">OpenGL ES 3.0.2 &sect;4.3.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glBlitFramebuffer.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void framebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-4.4">OpenGL ES 3.0.2 &sect;4.4</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glFramebufferTextureLayer.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-6.1.15">OpenGL ES 3.0.2 &sect;6.1.15</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glGetInternalformativ.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-4.5">OpenGL ES 3.0.2 &sect;4.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glInvalidateFramebuffer.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void invalidateSubFramebuffer (GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-4.5">OpenGL ES 3.0.2 &sect;4.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glInvalidateSubFramebuffer.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void readBuffer(GLenum mode);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-4.3.1">OpenGL ES 3.0.2 &sect;4.3.1</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glReadBuffer.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf#nameddest=section-4.4.2">OpenGL ES 3.0.2 &sect;4.4.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/xhtml/glRenderBufferStorageMultisample.xml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Texture objects</h4>

<!-- ======================================================================================================= -->

    <h4>Programs and Shaders</h4>

<!-- ======================================================================================================= -->

    <h4>Uniforms and attributes</h4>

<!-- ======================================================================================================= -->

    <h4>Writing to the drawing buffer</h4>

<!-- ======================================================================================================= -->

    <h4>Multiple render targets</h4>

<!-- ======================================================================================================= -->

    <h4>Query objects</h4>

<!-- ======================================================================================================= -->

    <h4>Sampler objects</h4>

<!-- ======================================================================================================= -->

    <h4>Sync objects</h4>

<!-- ======================================================================================================= -->

    <h4>Sync objects</h4>

<!-- ======================================================================================================= -->

    <h4>Transform feedback</h4>

<!-- ======================================================================================================= -->

    <h4>Uniform Buffer objects</h4>

<!-- ======================================================================================================= -->

    <h4>Vertex Array objects</h4>

<!-- ======================================================================================================= -->

    <h2><a name="webgl_1_2_differences">Other differences Between WebGL 2.0 and WebGL 1.0</a></h2>

    <div class="note editor">
        Needs update for WebGL 2.0
    </div>

    <ul>
      <li>Compressed textures are supported.</li>
    </ul>

<!-- ======================================================================================================= -->

    <h2><a name="webgl_gl_differences">Differences Between WebGL and OpenGL ES 3.0</a></h2>

    <div class="note editor">
        Needs update for WebGL 2.0
    </div>

    <p>
        This section describes changes made to the WebGL API relative to the
        OpenGL ES 3.0 API to improve portability across various operating
        systems and devices.
    </p>

<!-- ======================================================================================================= -->

    <h2>References</h2>
    
    <h3>Normative references</h3>
    <dl>
        <dt id="refsWEBGL10">[WEBGL10]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webgl/specs/1.0/">
            WebGL Specification 1.0.2</a></cite>, 
            C. Marrin 2013.
        </dd>
        <dt id="refsGLES30">[GLES30]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.2.pdf">
            OpenGL&reg; ES Version 3.0.2</a></cite>, 
            B. Lipchak 2013.
        </dd>
        <dt id="refsGLES20GLSL">[GLES30GLSL]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.4.pdf">
            The OpenGL&reg; ES Shading Language Version 3.00</a></cite>, 
            R. Simpson, March 2013.
        </dd>
        <dt id="refsREGISTRY">[REGISTRY]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webgl/extensions/">
            WebGL Extension Registry</a></cite>
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">
            Web IDL: W3C Editor’s Draft</a></cite>, 
            C. McCormack.
        </dd>
    </dl>

</body>
</html>
