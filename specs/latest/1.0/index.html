<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>WebGL Specification</title>
    <meta name="generator" content="BBEdit 9.1">
    <link rel="stylesheet" type="text/css" href="../../../resources/Khronos-WD.css" />
    <script src="../../../resources/jquery-1.3.2.min.js" type="application/javascript"></script>
    <script src="../../../resources/generateTOC.js" type="application/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class="head">
        <div class="left">
            <p>
                <a href="http://webgl.org/">
                    <img alt=WebGL width=240 height=100 src="../../../resources/WebGL-Logo.png"/>
                </a>
            </p>
        </div>
        <div class="right">
            <p>
                <a href="http://khronos.org/">
                    <img alt=Khronos width=336 height=80  src="../../../resources/Khronos_100px_June18.png"/>
                </a>
            </p>
        </div>
    </div>
    <div style="clear: both;"></div>
    <!--end-logo-->

    <h1>WebGL Specification</h1>
    <h2 class="no-toc">Editor's Draft <span id="LastEditDate"></span></h2>
    <dl>
        <dt>This version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/">
                    https://www.khronos.org/registry/webgl/specs/latest/1.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/1.0/webgl.idl
                </a>
            </dd>
        <dt>Latest version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/">
                    https://www.khronos.org/registry/webgl/specs/latest/1.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/1.0/webgl.idl
                </a>
            </dd>
        <dt>Previous version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0.3/">
                    https://www.khronos.org/registry/webgl/specs/1.0.3/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0.3/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/1.0.3/webgl.idl
                </a>
            </dd>
        <dt>Editors:
            <dd>
                <a href="mailto:dino@apple.com">Dean Jackson</a>
                <a href="http://www.apple.com/">(Apple Inc.)</a>
            </dd>
            <dd>
                <a href="mailto:jgilbert@mozilla.com">Jeff Gilbert</a>
                <a href="https://www.mozilla.org/">(Mozilla Corp.)</a>
            </dd>
    </dl>

    <span style="font-size: x-small; font-style: oblique">Copyright &copy; 2015 Khronos Group</span>

    <hr />

    <h2 class="no-toc">Abstract</h2>
    <p>
        This specification describes an additional rendering context and support
        objects for the
        <a href="https://www.w3.org/TR/html5/scripting-1.html#the-canvas-element"
           title="HTML 5 Canvas Element">
            HTML 5 <span class="prop-name">canvas</span> element <a href="#refsCANVAS">[CANVAS]</a>.
        </a>
        This context allows rendering using an API that conforms closely to the OpenGL ES 2.0 API.
    </p>

    <h2 class="no-toc">Status of this document</h2>

    <!--begin-status-->
    <p>
        This document is an editor's draft. Do not cite this document as other than work in
        progress.
    </p>
    <!--end-status-->

    <h2 class="no-toc">Feedback</h2>
    <p>
        Public discussion of this specification is welcome on
        the <a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a> mailing list
        (<a href="http://www.khronos.org/webgl/public-mailing-list/">instructions</a>, <a href="https://www.khronos.org/webgl/public-mailing-list/archives/">archives</a>).
    </p>
    <p>
        Please file bugs against the specification or its conformance tests in
        the <a href="https://github.com/KhronosGroup/WebGL/issues">issue tracker</a>. Pull requests
        are welcome against the <a href="https://github.com/KhronosGroup/WebGL">Github
        repository</a>.
    </p>

    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>
    <div class="note">
    <p>
      WebGL™ is an immediate mode 3D rendering API designed for the
      web.  It is derived from OpenGL® ES 2.0, and provides similar
      rendering functionality, but in an HTML context.  WebGL is
      designed as a rendering context for the HTML Canvas element.
      The HTML Canvas provides a destination for programmatic
      rendering in web pages, and allows for performing that rendering
      using different rendering APIs.  The only such interface
      described as part of the Canvas specification is the 2D canvas
      rendering context, CanvasRenderingContext2D. This document
      describes another such interface, WebGLRenderingContext, which
      presents the WebGL API.
    </p>

    <p>
      The immediate mode nature of the API is a divergence from most
      web APIs.  Given the many use cases of 3D graphics, WebGL
      chooses the approach of providing flexible primitives that can
      be applied to any use case.  Libraries can provide an API on top
      of WebGL that is more tailored to specific areas, thus adding a
      convenience layer to WebGL that can accelerate and simplify development.
      However, because of its OpenGL ES 2.0 heritage, it should be
      straightforward for developers familiar with modern desktop
      OpenGL or OpenGL ES 2.0 development to transition to WebGL
      development.
    </p>
    </div>

    <h3>Conventions</h3>

    <p>
     Many functions described in this document contain links to OpenGL ES
     man pages. While every effort is made to make these pages match the
     OpenGL ES 2.0 specification <a href="#refsGLES20">[GLES20]</a>,
     they may contain errors. In the case of a contradiction, the OpenGL
     ES 2.0 specification is the final authority.
    </p>

    <p>
      The remaining sections of this document are intended to be read in conjunction
      with the OpenGL ES 2.0 specification (2.0.25 at the time of this writing, available
      from the <a href="http://www.khronos.org/registry/gles/">Khronos OpenGL ES API Registry</a>).
      Unless otherwise specified, the behavior of each method is defined by the
      OpenGL ES 2.0 specification.  This specification may diverge from OpenGL ES 2.0
      in order to ensure interoperability or security, often defining areas that
      OpenGL ES 2.0 leaves implementation-defined.  These differences are summarized in the
      <a href="#webgl_gl_differences">Differences Between WebGL and OpenGL ES 2.0</a> section.
    </p>

<!-- ======================================================================================================= -->

    <h2>Context Creation and Drawing Buffer Presentation</h2>

    <p>
        Before using the WebGL API, the author must obtain a <code>WebGLRenderingContext</code>
        object for a given HTMLCanvasElement <a href="#refsCANVAS">[CANVAS]</a> or
        OffscreenCanvas <a href="#refsOFFSCREENCANVAS">[OFFSCREENCANVAS]</a> as described
        below. This object is used to manage OpenGL state and render to the drawing buffer, which
        must be created at the time of context creation.
    </p>

<!-- ======================================================================================================= -->

    <h3>Context Creation</h3>

    <p>
        Each <code>WebGLRenderingContext</code> has an
        associated <b><a name="context-canvas">canvas</a></b>, set upon creation, which is
        a <em>canvas</em> <a href="#refsCANVAS">[CANVAS]</a> or <em>offscreen
        canvas</em> <a href="#refsOFFSCREENCANVAS">[OFFSCREENCANVAS]</a>.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> has <b><a name="context-creation-parameters">context
        creation parameters</a></b>, set upon creation, in
        a <a href="#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> has <b><a name="actual-context-parameters">actual
        context parameters</a></b>, set each time the drawing buffer is created, in
        a <a href="#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> has a <b><a name="webgl-context-lost-flag">webgl
        context lost flag</a></b>, which is initially unset.
    </p>
    <p>
        When the <code>getContext()</code> method of a <code>canvas</code> element
        or <code>offscreen canvas</code> object is to return a new object for
        the <em>contextId</em> <code>webgl</code> <a href="#refsCANVASCONTEXTS">[CANVASCONTEXTS]</a>,
        the user agent must perform the following steps:

        <ol class="nestedlist">

        <li> Create a new <code>WebGLRenderingContext</code> object, <em>context</em>.

        <li> Let <em>context's</em> <a href="#context-canvas">canvas</a> be the canvas or offscreen
             canvas the <code>getContext()</code> method is associated with.

        <li> Create a new <code>WebGLContextAttributes</code> object, <em>contextAttributes</em>.

        <li> If <code>getContext()</code> was invoked with a second argument, <em>options</em>, set
             the attributes of <em>contextAttributes</em> from those specified in <em>options</em>.

        <li> <a href="#create-a-drawing-buffer">Create a <em>drawing buffer</em></a> using the settings
             specified in <em>contextAttributes</em>, and associate the <em>drawing buffer</em>
             with <em>context</em>.

        <li> If drawing buffer creation failed, perform the following steps:

          <ol class="nestedlist">

          <li> <a href="#fire-a-webgl-context-creation-error">Fire a WebGL context creation
          error</a> at <em>canvas</em>.

          <li> Return null and terminate these steps.

          </ol>

        <li> Create a new <code>WebGLContextAttributes</code> object, <em>actualAttributes</em>.

        <li> Set the attributes of <em>actualAttributes</em> based on the properties of the newly
             created drawing buffer.

        <li> Set <em>context's</em> <a href="#context-creation-parameters">context creation
        parameters</a> to <em>contextAttributes</em>.

        <li> Set <em>context's</em> <a href="#actual-context-parameters">actual context
        parameters</a> to <em>actualAttributes</em>.

        <li> Return <em>context</em>.

        </ol>
    </p>
    <div class="note">
    <p>
      The canvas context type 'experimental-webgl' has historically been used to provide access to
      WebGL implementations which are not yet complete or conformant.
    </p>
    </div>
    <p>
      If the user agent supports both the <code>webgl</code> and <code>experimental-webgl</code>
      canvas context types, they shall be treated as aliases. For example, if a call
      to <code>getContext('webgl')</code> successfully creates a WebGLRenderingContext, a subsequent
      call to <code>getContext('experimental-webgl')</code> shall return the same context object.
    </p>

<!-- ======================================================================================================= -->

    <h3><a name="THE_DRAWING_BUFFER">The Drawing Buffer</a></h3>

    <p>
        The drawing buffer into which the API calls are rendered shall be defined upon creation of
        the WebGLRenderingContext object. The following description defines how
        to <b><a name="create-a-drawing-buffer">create a drawing buffer</a></b>.
    </p>
    <p>
        The table below shows all the buffers which make up the drawing buffer, along with their
        minimum sizes and whether they are defined or not by default. The size of this drawing
        buffer shall be determined by the <code>width</code> and <code>height</code> attributes of
        the HTMLCanvasElement or OffscreenCanvas. The table below also shows the value to which
        these buffers shall be cleared when first created, when the size is changed, or after
        presentation when the <code>preserveDrawingBuffer</code> context creation attribute
        is <code>false</code>.
    </p>
    <table class="foo">
        <tr><th>Buffer</th><th>Clear value</th><th>Minimum size</th><th>Defined by default?</th></tr>
        <tr><td>Color</td><td>(0, 0, 0, 0)</td><td>8 bits per component</td><td>yes</td></tr>
        <tr><td>Depth</td><td>1.0</td><td>16 bit integer</td><td>yes</td></tr>
        <tr><td>Stencil</td><td>0</td><td>8 bits</td><td>no</td></tr>
    </table>
    <br>
    <p>
        <code>HTMLCanvasElement.width</code> and <code>.height</code> values less than 1 are treated as 1.
        A 0x0 canvas will yield a 1x1 drawingBufferWidth/Height.
    </p>
    <p>
        If the requested width or height cannot be satisfied, either when the drawing buffer is first
        created or when the <code>width</code> and <code>height</code> attributes of the
        <code>HTMLCanvasElement</code> or <code>OffscreenCanvas</code> are changed, a drawing buffer
        with smaller dimensions shall be created. The dimensions actually used are implementation
        dependent and there is no guarantee that a buffer with the same aspect ratio will be
        created. The actual drawing buffer size can be obtained from
        the <code>drawingBufferWidth</code> and <code>drawingBufferHeight</code> attributes.
    </p>
    <p>
        A WebGL implementation must not perform any automatic scaling of the size of the drawing
        buffer on high-definition displays. The context's <code>drawingBufferWidth</code>
        and <code>drawingBufferHeight</code> must match the canvas's <code>width</code>
        and <code>height</code> attributes as closely as possible, modulo implementation-dependent
        constraints.
    </p>
    <div class="note">
        <p>
            The constraint above does not change the amount of space the canvas element consumes on
            the web page, even on a high-definition display. The
            canvas's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#attr-canvas-width">intrinsic
            dimensions</a> <a href="#refsCANVAS">[CANVAS]</a> equal the size of its coordinate
            space, with the numbers interpreted in CSS pixels, and CSS pixels
            are <a href="http://www.w3.org/TR/CSS21/syndata.html#length-units">resolution-independent</a> <a href="#refsCSS">[CSS]</a>.
        </p>
        <p>
            A WebGL application can achieve a 1:1 ratio between drawing buffer pixels and on-screen
            pixels on high-definition displays by examining properties
            like <code>window.devicePixelRatio</code>, scaling the canvas's <code>width</code>
            and <code>height</code> by that factor, and setting its CSS width and height to the
            original width and height. An application can simulate the effect of running on a
            higher-resolution display simply by scaling up the canvas's <code>width</code>
            and <code>height</code> properties.
        </p>
    </div>
    <p>
        The optional <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> object may be used
        to change whether or not the buffers are defined. It can also be used to define whether the
        color buffer will include an alpha channel. If defined, the alpha channel is used by the
        HTML compositor to combine the color buffer with the rest of the page. The
        WebGLContextAttributes object is only used on the first call to
        <code>getContext</code>. No facility is provided to change the attributes of the drawing
        buffer after its creation.
    </p>
    <p>
        The <code>depth</code>, <code>stencil</code> and <code>antialias</code> attributes, when set
        to true, are requests, not requirements. The WebGL implementation should make a best effort
        to honor them. When any of these attributes is set to false, however, the WebGL
        implementation must not provide the associated functionality. Combinations of attributes not
        supported by the WebGL implementation or graphics hardware shall not cause a failure to
        create a WebGLRenderingContext. The <a href="#actual-context-parameters">actual context
        parameters</a> are set to the attributes of the created drawing buffer. The
        <code>alpha</code>, <code>premultipliedAlpha</code> and <code>preserveDrawingBuffer</code>
        attributes must be obeyed by the WebGL implementation.
    </p>
    <p>
        WebGL presents its drawing buffer to the HTML page compositor immediately before a
        compositing operation, but only if at least one of the following has occurred since the
        previous compositing operation:
        <ul>
            <li>Context creation</li>
            <li>Canvas resize</li>
            <li>
                <code>clear</code>, <code>drawArrays</code>, or <code>drawElements</code> has been
                called while the drawing buffer is the currently bound framebuffer
            </li>
        </ul>
    </p>
    <p>
        Before the drawing buffer is presented for compositing the implementation shall ensure that
        all rendering operations have been flushed to the drawing buffer. By default, after
        compositing the contents of the drawing buffer shall be cleared to their default values, as
        shown in the table above.
    </p>
    <p>
        This default behavior can be changed by setting the <code>preserveDrawingBuffer</code>
        attribute of the <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> object. If
        this flag is true, the contents of the drawing buffer shall be preserved until the author
        either clears or overwrites them. If this flag is false, attempting to perform operations
        using this context as a source image after the rendering function has returned can lead to
        undefined behavior. This includes <code>readPixels</code> or <code>toDataURL</code> calls,
        using this context as the source image of another context's <code>texImage2D</code> or
        <code>drawImage</code> call, or creating
        an <a href="https://html.spec.whatwg.org/multipage/webappapis.html#imagebitmap">ImageBitmap</a> <a href="#refsHTML">[HTML]</a>
        from this context's canvas.
    </p>
    <div class="note">
        <p>
            While it is sometimes desirable to preserve the drawing buffer, it can cause significant
            performance loss on some platforms. Whenever possible this flag should remain false
            and other techniques used. Techniques like synchronous drawing buffer access (e.g.,
            calling <code>readPixels</code> or <code>toDataURL</code> in the same function that
            renders to the drawing buffer) can be used to get the contents of the drawing buffer.
            If the author needs to render to the same drawing buffer over a series of calls, a
            <a href="#WEBGL_FRAMEBUFFER">Framebuffer Object</a> can be used.
        </p>
        <p>
            Implementations may optimize away the required implicit clear operation of the Drawing
            Buffer as long as a guarantee can be made that the author cannot gain access to buffer
            contents from another process. For instance, if the author performs an explicit
            clear then the implicit clear is not needed.
        </p>
    </div>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGL_VIEWPORT">The WebGL Viewport</a></h3>

    <p>
        OpenGL manages a rectangular viewport as part of its state which defines the placement of
        the rendering results in the drawing buffer. Upon creation of WebGL
        context <em>context</em>, the viewport is initialized to a rectangle with origin at (0, 0)
        and width and height equal to (context.drawingBufferWidth, context.drawingBufferHeight).
    </p>
    <p>
        A WebGL implementation <em>shall not</em> affect the state of the OpenGL viewport in response to
        resizing of the canvas element.
    </p>
    <div class="example">
        Note that if a WebGL program does not contain logic to set the viewport, it will not properly
        handle the case where the canvas is resized. The following ECMAScript example illustrates how
        a WebGL program might resize the canvas programmatically.

        <pre>
var canvas = document.getElementById('canvas1');
var gl = canvas.getContext('webgl');
canvas.width = newWidth;
canvas.height = newHeight;
gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        </pre>
    </div>
    <p>
        <em>Rationale</em>: automatically setting the viewport will interfere with applications that set
        it manually. Applications are expected to use <code>onresize</code> handlers to respond to
        changes in size of the canvas and set the OpenGL viewport in turn.
    </p>

<!-- ======================================================================================================= -->

    <h3><a name="PREMULTIPLIED_ALPHA">Premultiplied Alpha, Canvas APIs and texImage2D</a></h3>

    <p>
        The OpenGL API allows the application to modify the blending modes used during rendering,
        and for this reason allows control over how alpha values in the drawing buffer are
        interpreted; see the <code>premultipliedAlpha</code> parameter in
        the <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> section.
    </p>
    <p>
        The HTML Canvas APIs <code>toDataURL</code> and <code>drawImage</code> must respect
        the <code>premultipliedAlpha</code> context creation parameter. When <code>toDataURL</code>
        is called against a Canvas into which WebGL content is being rendered, then if the requested
        image format does not specify premultiplied alpha and the WebGL context has
        the <code>premultipliedAlpha</code> parameter set to true, then the pixel values must be
        de-multiplied; i.e., the color channels are divided by the alpha channel. <b>Note</b> that
        this operation is lossy.
    </p>
    <p>
        Passing a WebGL-rendered Canvas to the <code>drawImage</code> method
        of <code>CanvasRenderingContext2D</code> may or may not need to modify the the rendered
        WebGL content during the drawing operation, depending on the premultiplication needs of the
        <code>CanvasRenderingContext2D</code> implementation.
    </p>
    <p>
        When passing a WebGL-rendered Canvas to the <code>texImage2D</code> API, then depending on
        the setting of the <code>premultipliedAlpha</code> context creation parameter of the passed
        canvas and the <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel store parameter of the
        destination WebGL context, the pixel data may need to be changed to or from premultiplied
        form.
    </p>

<!-- ======================================================================================================= -->

    <h2>WebGL Resources</h2>

    <p>
        OpenGL manages several types of resources as part of its state. These are identified
        by integer object names and are obtained from OpenGL by various creation calls.
        In contrast WebGL represents these resources as DOM objects. Each object is derived
        from the WebGLObject interface. Currently supported resources are:
        textures, buffers (i.e., VBOs), framebuffers, renderbuffers, shaders and
        programs. The WebGLRenderingContext interface has a method to create a
        WebGLObject subclass for each type. Data from the underlying graphics library are
        stored in these objects and are fully managed by them.
        The DOM object will stay alive not only as long as the author retains an explicit reference
        to it, but also as long as it is in use by the underlying graphics library.
        When the DOM object is destroyed, it marks its resources for deletion.
        If authors wish to mark an object for deletion prior to the DOM object being destroyed,
        they may explicitly call the respective delete function. (e.g. deleteTexture)
    </p>

<!-- ======================================================================================================= -->

    <h2>Security</h2>

    <p>
    </p>

<!-- ======================================================================================================= -->

    <h3>Resource Restrictions</h3>

    <p>
        WebGL resources such as textures and vertex buffer objects (VBOs) must always
        contain initialized data, even if they were created without initial user
        data values.  Creating a resource without initial values is commonly used to
        reserve space for a texture or VBO, which is then modified using <code>texSubImage</code> or
        <code>bufferSubData</code> calls.  If initial data is not provided to these calls, the WebGL
        implementation must initialize their contents to 0; depth resources must be cleared to
        the default 1.0 clear depth.  This may require creating a zeroed temporary buffer the size
        of a requested VBO, so that it can be initialized correctly.  All other forms of loading
        data into a texture or VBO involve either ArrayBuffers or DOM objects such as images, and
        are therefore already required to be initialized.
    </p>

    <p>
        When WebGL resources are accessed by shaders through a call such as
        <code>drawElements</code> or <code>drawArrays</code>, the WebGL implementation must ensure
        that the shader cannot access either out of bounds or uninitialized data.
        See <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range Checking</a>
        for restrictions which must be enforced by the WebGL implementation.
    </p>

<!-- ======================================================================================================= -->

    <h3><a name="ORIGIN_RESTRICTIONS">Origin Restrictions</a></h3>

    <p>
        In order to prevent information leakage, WebGL disallows uploading as textures:
        <ul>
        <li> Image or video elements whose origin is not the same as the origin of the Document that
             contains the WebGLRenderingContext's canvas element
        <li> Canvas elements whose bitmap's <i>origin-clean</i> flag is set to false
        <li> ImageBitmap objects whose bitmap's <i>origin-clean</i> flag is set to false
        </ul>
    </p>
    <p>
        If the <code>texImage2D</code> or <code>texSubImage2D</code> method is called with otherwise
        correct arguments and an <code>HTMLImageElement</code>, <code>HTMLVideoElement</code>,
        <code>HTMLCanvasElement</code>, or <code>ImageBitmap</code> violating these restrictions, a
        <code>SECURITY_ERR</code> exception must be thrown.
    </p>
    <div class="note">
        <p>
            WebGL necessarily imposes stronger restrictions on the use of cross-domain media than other
            APIs such as the 2D canvas rendering context, because shaders can be used to indirectly
            deduce the contents of textures which have been uploaded to the GPU.
        </p>
        <p>
            WebGL applications may utilize images and videos that come from other domains, with the
            cooperation of the server hosting the media,
            using <a href="http://www.w3.org/TR/cors/">Cross-Origin Resource
            Sharing</a> <a href="#refsCORS">[CORS]</a>. In order to use such media, the application
            needs to explicitly request permission to do so, and the server needs to explicitly grant
            permission. Successful CORS-enabled fetches of image and video elements from other
            domains <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#origin-0">cause
            the origin of these elements</a> to be set to that of the containing
            Document <a href="#refsHTML">[HTML]</a>.
        </p>
        <div class="example">
            <p>
                The following ECMAScript example demonstrates how to issue a CORS request for an
                image coming from another domain. The image is fetched from the server without any
                credentials, i.e., cookies.
            </p>
<pre>
var gl = ...;
var image = new Image();

// The onload handler should be set to a function which uploads the HTMLImageElement
// using texImage2D or texSubImage2D.
image.onload = ...;

image.crossOrigin = "anonymous";

image.src = "http://other-domain.com/image.jpg";
</pre>
        </div>
        <p>
            Note that these rules imply that the <i>origin-clean</i> flag for a canvas rendered
            using WebGL will never be set to false.
        </p>
        <p>
            For more information on issuing CORS requests for image and video elements, consult:
            <ul>
            <li> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#cors-settings-attribute">CORS settings attributes</a> <a href="#refsHTML">[HTML]</a>
            <li> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content-1.html#the-img-element">The <code>img</code> element</a> <a href="#refsHTML">[HTML]</a>
            <li> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#media-elements">Media elements</a> <a href="#refsHTML">[HTML]</a>
            </ul>
        </p>
    </div>

<!-- ======================================================================================================= -->

    <h3><a name="SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a></h3>

    <p>
        A WebGL implementation must only accept shaders which conform to The OpenGL ES Shading
        Language, Version 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a>, and which do not exceed
        the minimum functionality mandated in Sections 4 and 5 of Appendix A.  In particular:

        <ul>
        <li> A shader referencing state variables or functions that are available in other versions
             of GLSL, such as that found in versions of OpenGL for the desktop, must not be allowed
             to load. </li>
        <li> <code>for</code> loops must conform to the structural constraints in Appendix A. </li>
        <li> <code>while</code> and <code>do-while</code> loops are disallowed, since they are
             optional in Appendix A.</li>
        <li> Appendix A mandates certain forms of indexing of arrays; for example, within fragment
             shaders, indexing is only mandated with a <i>constant-index-expression</i>
             (see <a href="#refsGLES20GLSL">[GLES20GLSL]</a> for the definition of this term). In
             the WebGL API, only the forms of indexing mandated in Appendix A are supported. </li>
        </ul>
    </p>
    <p>
        In addition to the reserved identifiers in the aforementioned specification, identifiers
        starting with "webgl_" and "_webgl_" are reserved for use by WebGL. A shader which declares
        a function, variable, structure name, or structure field starting with these prefixes must
        not be allowed to load.
    </p>

<!-- ======================================================================================================= -->

    <h3>Defense Against Denial of Service</h3>
    <div class="note">
    <p>
    It is possible to create, either intentionally or unintentionally, combinations of shaders and
    geometry that take an undesirably long time to render. This issue is analogous to that of
    long-running scripts, for which user agents already have safeguards. However, long-running draw
    calls can cause loss of interactivity for the entire window system, not just the user agent.
    </p>

    <p>
    In the general case it is not possible to impose limits on the structure of incoming shaders to
    guard against this problem. Experimentation has shown that even very strict structural limits
    are insufficient to prevent long rendering times, and such limits would prevent shader authors
    from implementing common algorithms.
    </p>

    <p>
    User agents should implement safeguards to prevent excessively long rendering times and
    associated loss of interactivity. Suggested safeguards include:
    </p>

    <ul>

    <li> Splitting up draw calls with large numbers of elements into smaller draw calls.

    <li> Timing individual draw calls and forbidding further rendering from a page if a certain
         timeout is exceeded.

    <li> Using any watchdog facilities available at the user level, graphics API level, or operating
         system level to limit the duration of draw calls.

    <li> Separating the graphics rendering of the user agent into a distinct operating system
         process which can be terminated and restarted without losing application state.

    </ul>

    <p>
    The supporting infrastructure at the OS and graphics API layer is expected to improve over time,
    which is why the exact nature of these safeguards is not specified.
    </p>
    </div>
<!-- ======================================================================================================= -->

    <h3><a name="OUT_OF_RANGE_ARRAY_ACCESSES">Out-of-Range Array Accesses</a></h3>

    <p>
        Shaders must not be allowed to read or write array elements that lie outside of the application's own
        data.  This includes any variable of array type, as well as vector or matrix types such as
        <code>vec3</code> or <code>mat4</code> when accessed using array subscripting syntax. If
        detected during compilation, such accesses must generate an error and prevent the shader
        from compiling. Otherwise, at runtime, out-of-range reads shall return any of the following values:
    </p>
    <ul>
    <li>Values from anywhere within the storage accessible to the program.</li>
    <li>Zero values, or (0,0,0,x) vectors for vector reads where x is a
        valid value represented in the type of the vector components and may
        be any of:
        <ul>
          <li>0, 1, or the maximum representable positive integer value, for
          signed or unsigned integer components</li>
          <li>0.0 or 1.0, for floating-point components</li>
        </ul>
        </li>
    </ul>
    <p>
      Out-of-range writes are either discarded or modify an
        unspecified value in the storage accessible to the program.
    </p>
    <div class="note">
        <p>
            This behavior replicates that defined in <a href="#refsKHRROBUSTACCESS">[KHRROBUSTACCESS]</a>.
        </p>
        <p>
            See <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a> for more information
            on restrictions which simplify static analysis of the array indexing operations in shaders.
        </p>
    </div>
<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

<!-- ======================================================================================================= -->

    <h3>Types</h3>

    <p>
        The following types are used in all interfaces in the following section.
    </p>
    <pre class="idl">
typedef unsigned long  GLenum;
typedef boolean        GLboolean;
typedef unsigned long  GLbitfield;
typedef byte           GLbyte;         /* 'byte' should be a signed 8 bit type. */
typedef short          GLshort;
typedef long           GLint;
typedef long           GLsizei;
typedef long long      GLintptr;
typedef long long      GLsizeiptr;
// Ideally the typedef below would use 'unsigned byte', but that doesn't currently exist in Web IDL.
typedef octet          GLubyte;        /* 'octet' should be an unsigned 8 bit type. */
typedef unsigned short GLushort;
typedef unsigned long  GLuint;
typedef unrestricted float GLfloat;
typedef unrestricted float GLclampf;

// The power preference settings are documented in the WebGLContextAttributes
// section of the specification.
enum WebGLPowerPreference { "default", "low-power", "high-performance" };
</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a></h3>

    <p>
        The <code>WebGLContextAttributes</code> dictionary contains drawing surface attributes and
        is passed as the second parameter to <code>getContext</code>.
    </p>
    <!-- The capitalization rules here match those of the crossOrigin
    attribute, which was added to HTMLMediaElement on behalf of
    WebGL. -->
    <pre class="idl">dictionary <dfn id="WebGLContextAttributes">WebGLContextAttributes</dfn> {
    boolean alpha = true;
    boolean depth = true;
    boolean stencil = false;
    boolean antialias = true;
    boolean premultipliedAlpha = true;
    boolean preserveDrawingBuffer = false;
    WebGLPowerPreference powerPreference = "default";
    boolean failIfMajorPerformanceCaveat = false;
    boolean desynchronized = false;
};</pre>

    <h4>Context creation parameters</h4>

    <p>
        The following list describes each attribute in the WebGLContextAttributes object and its
        use. The default value for each attribute is shown above. The default value is used either
        if no second parameter is passed to <code>getContext</code>, or if a user object is passed
        which has no attribute of the given name.
    </p>
    <dl>
        <dt><span class=prop-value>alpha</span></dt>
            <dd>
                If the value is true, the drawing buffer has an alpha channel for the purposes of
                performing OpenGL destination alpha operations and compositing with the page. If the
                value is false, no alpha buffer is available.
            </dd>
        <dt> <span class=prop-value>depth</span>
            <dd>
                If the value is true, the drawing buffer has a depth buffer of at least 16 bits. If
                the value is false, no depth buffer is available.
           </dd>
        <dt> <span class=prop-value>stencil</span>
            <dd>
                If the value is true, the drawing buffer has a stencil buffer of at least 8 bits. If
                the value is false, no stencil buffer is available.
            </dd>
        <dt> <span class=prop-value>antialias</span>
            <dd>
                If the value is true and the implementation supports antialiasing the drawing buffer
                will perform antialiasing using its choice of technique (multisample/supersample)
                and quality. If the value is false or the implementation does not support
                antialiasing, no antialiasing is performed.
            </dd>
        <dt> <span class=prop-value>premultipliedAlpha</span>
            <dd>
                If the value is true the page compositor will assume the drawing buffer contains
                colors with premultiplied alpha. If the value is false the page compositor will
                assume that colors in the drawing buffer are not premultiplied. This flag is ignored
                if the <strong>alpha</strong> flag is
                false. See <a href="#PREMULTIPLIED_ALPHA">Premultiplied Alpha</a> for more
                information on the effects of the <code>premultipliedAlpha</code> flag.
            </dd>
        <dt> <span class=prop-value>preserveDrawingBuffer</span>
            <dd>
                If false, once the drawing buffer is presented as described in
                the<a href="#THE_DRAWING_BUFFER">Drawing Buffer</a> section, the contents of the
                drawing buffer are cleared to their default values.  All elements of the drawing
                buffer (color, depth and stencil) are cleared.  If the value is true the buffers
                will not be cleared and will preserve their values until cleared or overwritten by
                the author.
                <blockquote>
                <em>
                    On some hardware setting the <code>preserveDrawingBuffer</code> flag
                    to true can have significant performance implications.
                </em>
                </blockquote>
            </dd>
        <dt><span class=prop-value>powerPreference</span></dt>
            <dd>
              <p>
                Provides a hint to the user agent indicating what configuration of GPU is suitable
                for this WebGL context. This may influence which GPU is used in a system with
                multiple GPUs. For example, a dual-GPU system might have one GPU that consumes
                less power at the expense of rendering performance. Note that this property is
                only a hint and a WebGL implementation may choose to ignore it.
              </p>
              <p>
                WebGL implementations use context lost and restored events to regulate power and
                memory consumption, <em>regardless</em> of the value of this attribute.
              </p>
              <p>
                The allowed values are:
              </p>
              <dl><dd>
                  <p>
                    <em>default</em>
                  </p>
                  <p>
                    Let the user agent decide which GPU configuration is most suitable. This is the
                    default value.
                  </p>
                  <p>
                    <em>high-performance</em>
                  </p>
                  <p>
                    Indicates a request for a GPU configuration that prioritizes rendering
                    performance over power consumption.
                    Developers are encouraged to only specify this value if they believe it
                    is absolutely necessary, since it may significantly decrease battery life on
                    mobile devices.
                    Implementations may decide to initially respect this request and,
                    after some time, lose the context and restore a new context ignoring the
                    request.
                  </p>
                  <div class="note">
                    <p>
                      Applications that request <code>high-performance</code> should test and
                      maintain robust context loss handling, as User Agents are very likely to decide
                      to lose background <code>high-performance</code> contexts.
                    </p>
                  </div>
                  <p>
                    <em>low-power</em>
                  </p>
                  <p>
                    Indicates a request for a GPU configuration that prioritizes power saving over
                    rendering performance. Generally, content should use this if it is unlikely to
                    be constrained by drawing performance; for example, if it renders only one frame
                    per second, draws only relatively simple geometry with simple shaders, or uses a
                    small HTML canvas element. Developers are encouraged to use this value if their
                    content allows, since it may significantly improve battery life on mobile
                    devices.
                  </p>
              </dd></dl>
            </dd>
        <dt> <span class=prop-value>failIfMajorPerformanceCaveat</span></dt>
            <dd>
              If the value is true, context creation will fail if the implementation determines
              that the performance of the created WebGL context would be dramatically lower
              than that of a native application making equivalent OpenGL calls. This could happen
              for a number of reasons, including:
              <ul>
                <li>An implementation might switch to a software rasterizer if the user's GPU
                    driver is known to be unstable.
                <li>An implementation might require reading back the framebuffer from GPU memory
                    to system memory before compositing it with the rest of the page,
                    significantly reducing performance.
              </ul>
              Applications that don't require high performance should leave this parameter at its
              default value of <code>false</code>. Applications that require high performance may
              set this parameter to <code>true</code>, and if context creation fails then the
              application may prefer to use a fallback rendering path such as a 2D canvas context.
              Alternatively the application can retry WebGL context creation with this parameter
              set to <code>false</code>, with the knowledge that a reduced-fidelity rendering mode
              should be used to improve performance.
            </dd>
        <dt> <span class=prop-value>desynchronized</span></dt>
            <dd>
              <p>
                If the value is true, then the user agent may optimize the rendering of the canvas
                to reduce the latency, as measured from input events to rasterization, by
                desynchronizing the canvas paint cycle from the event loop, bypassing the ordinary
                user agent rendering algorithm, or both. Insofar as this mode involves bypassing the
                usual paint mechanisms, rasterization, or both, it might introduce visible tearing
                artifacts.
              </p>
              <div class="note">
                <p>
                  The user agent usually renders on a buffer which is not being displayed, quickly
                  swapping it and the one being scanned out for presentation; the former buffer is
                  called back buffer and the latter <i>front buffer</i>. A popular technique for
                  reducing latency is called front buffer rendering, also known as <i>single
                  buffer</i> rendering, where rendering happens inparallel and racily with the
                  scanning out process. This technique reduces the latency at the price of
                  potentially introducing tearing artifacts and can be used to implement in total or
                  part of the <code>desynchronized</code>
                  boolean. <a href="#refsMULTIPLEBUFFERING">[MULTIPLEBUFFERING]</a>
                </p>
                <p>
                  The <code>desynchronized</code> boolean can be useful when implementing certain
                  kinds of applications, such as drawing applications, where the latency between
                  input and rasterization is critical.
                </p>
              </div>
            </dd>
    </dl>
    <div class="example">
    Here is an ECMAScript example which passes a WebGLContextAttributes argument
    to <code>getContext</code>.  It assumes the presence of a canvas element named "canvas1" on the
    page.

    <pre>
var canvas = document.getElementById('canvas1');
var context = canvas.getContext('webgl',
                                { antialias: false,
                                  stencil: true });
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3>WebGLObject</h3>

    <p>
        The <code>WebGLObject</code> interface is the parent interface for all GL objects.
    </p>
    <p>
        Each <code>WebGLObject</code> has
        an <b><a name="webgl-object-invalidated-flag">invalidated</a></b> flag, which is initially unset.
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLObject">WebGLObject</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLBuffer</h3>

    <p>
        The <code>WebGLBuffer</code> interface represents an OpenGL Buffer Object. The
        underlying object is created as if by calling glGenBuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenBuffers.xml">man page</a>)</span>
        , bound as if by calling glBindBuffer
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindBuffer.xml">man page</a>)</span>
        and marked for deletion as if by calling glDeleteBuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteBuffers.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLBuffer">WebGLBuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGL_FRAMEBUFFER">WebGLFramebuffer</a></h3>

    <p>
        The <code>WebGLFramebuffer</code> interface represents an OpenGL Framebuffer Object. The
        underlying object is created as if by calling glGenFramebuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenFramebuffers.xml">man page</a>)</span>
        , bound as if by calling glBindFramebuffer
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindFramebuffer.xml">man page</a>)</span>
        and marked for deletion as if by calling glDeleteFramebuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteFramebuffers.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLFramebuffer">WebGLFramebuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLProgram</h3>

    <p>
        The <code>WebGLProgram</code> interface represents an OpenGL Program Object. The
        underlying object is created as if by calling glCreateProgram
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateProgram.xml">man page</a>)</span>
        , used as if by calling glUseProgram
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUseProgram.xml">man page</a>)</span>
        and marked for deletion as if by calling glDeleteProgram
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteProgram.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLProgram">WebGLProgram</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLRenderbuffer</h3>

    <p>
        The <code>WebGLRenderbuffer</code> interface represents an OpenGL Renderbuffer Object. The
        underlying object is created as if by calling glGenRenderbuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenRenderbuffers.xml">man page</a>)</span>
        , bound as if by calling glBindRenderbuffer
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindRenderbuffer.xml">man page</a>)</span>
        and marked for deletion as if by calling glDeleteRenderbuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteRenderbuffers.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLRenderbuffer">WebGLRenderbuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLShader</h3>

    <p>
        The <code>WebGLShader</code> interface represents an OpenGL Shader Object. The
        underlying object is created as if by calling glCreateShader
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateShader.xml">man page</a>)</span>
        , attached to a Program as if by calling glAttachShader
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glAttachShader.xml">man page</a>)</span>
        and marked for deletion as if by calling glDeleteShader
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteShader.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLShader">WebGLShader</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLTexture</h3>

    <p>
        The <code>WebGLTexture</code> interface represents an OpenGL Texture Object. The
        underlying object is created as if by calling glGenTextures
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenTextures.xml">man page</a>)</span>
        , bound as if by calling glBindTexture
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindTexture.xml">man page</a>)</span>
        and marked for deletion as if by calling glDeleteTextures
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteTextures.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLTexture">WebGLTexture</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLUniformLocation</h3>

    <p>
        The <code>WebGLUniformLocation</code> interface represents the location of a uniform variable
        in a shader program.
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLUniformLocation">WebGLUniformLocation</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLActiveInfo</h3>

    <p>
        The <code>WebGLActiveInfo</code> interface represents the information returned
        from the getActiveAttrib and getActiveUniform calls.
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLActiveInfo">WebGLActiveInfo</dfn> {
    readonly attribute GLint size;
    readonly attribute GLenum type;
    readonly attribute DOMString name;
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-size">
                    size
                </a>
            </code>
            of type <code>GLint</code>
        <dd>
            The size of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-type">
                    type
                </a>
            </code>
            of type <code>GLenum</code>
        <dd>
            The data type of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-name">
                    name
                </a>
            </code>
            of type <code>DOMString</code>
        <dd>
            The name of the requested variable.
    </dl>

<!-- ======================================================================================================= -->

    <h3>WebGLShaderPrecisionFormat</h3>

    <p>
        The <code>WebGLShaderPrecisionFormat</code> interface represents the information returned
        from the getShaderPrecisionFormat call.
    </p>
    <pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="WebGLShaderPrecisionFormat">WebGLShaderPrecisionFormat</dfn> {
    readonly attribute GLint rangeMin;
    readonly attribute GLint rangeMax;
    readonly attribute GLint precision;
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLShaderPrecisionFormat-rangeMin">
                    rangeMin
                </a>
            </code>
            of type <code>GLint</code>
        <dd>
            The base 2 log of the absolute value of the minimum value that can be represented.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLShaderPrecisionFormat-rangeMax">
                    rangeMax
                </a>
            </code>
            of type <code>GLint</code>
        <dd>
            The base 2 log of the absolute value of the maximum value that can be represented.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLShaderPrecisionFormat-precision">
                    precision
                </a>
            </code>
            of type <code>GLint</code>
        <dd>
            The number of bits of precision that can be represented. For integer formats this value
            is always 0.
    </dl>

<!-- ======================================================================================================= -->

    <h3><a name="ARRAYBUFFER">ArrayBuffer</a> and <a name="TYPEDARRAY">Typed Arrays</a></h3>

    <p>
        Vertex, index, texture, and other data is transferred to the WebGL implementation using
        <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arraybuffer-constructor">ArrayBuffer</a>s,
        <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-constructors">Typed Arrays</a> and
        <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-dataview-objects">DataView</a>s
        as defined in the <a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript specification</a>
        <a href="#refsECMASCRIPT">[ECMASCRIPT]</a>.
    </p>
    <p>
        Typed Arrays support the creation of interleaved, heterogeneous vertex data; uploading of
        distinct blocks of data into a large vertex buffer object; and most other use cases required
        by OpenGL programs.
    </p>

    <div class="example">
    Here is an ECMAScript example showing access to the same ArrayBuffer using different types of
    typed arrays. In this case the buffer contains a floating point vertex position (x, y, z)
    followed by a color as 4 unsigned bytes (r, g, b, a).

    <pre>
var numVertices = 100; // for example

// Compute the size needed for the buffer, in bytes and floats
var vertexSize = 3 * Float32Array.BYTES_PER_ELEMENT +
     4 * Uint8Array.BYTES_PER_ELEMENT;
var vertexSizeInFloats = vertexSize / Float32Array.BYTES_PER_ELEMENT;

// Allocate the buffer
var buf = new ArrayBuffer(numVertices * vertexSize);

// Map this buffer to a Float32Array to access the positions
var positionArray = new Float32Array(buf);

// Map the same buffer to a Uint8Array to access the color
var colorArray = new Uint8Array(buf);

// Set up the initial offset of the vertices and colors within the buffer
var positionIdx = 0;
var colorIdx = 3 * Float32Array.BYTES_PER_ELEMENT;

// Initialize the buffer
for (var i = 0; i < numVertices; i++) {
    positionArray[positionIdx] = ...;
    positionArray[positionIdx + 1] = ...;
    positionArray[positionIdx + 2] = ...;
    colorArray[colorIdx] = ...;
    colorArray[colorIdx + 1] = ...;
    colorArray[colorIdx + 2] = ...;
    colorArray[colorIdx + 3] = ...;
    positionIdx += vertexSizeInFloats;
    colorIdx += vertexSize;
}
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLRENDERINGCONTEXT">The WebGL context</a></h3>

    <p>
        The <code>WebGLRenderingContext</code> represents the API allowing
        OpenGL ES 2.0 style rendering into the canvas element.
    </p>
    <p>
        Before performing the implementation of any method of the <code>WebGLRenderingContext</code>
        interface or any method of an interface returned by the <code>getExtension</code> method,
        the following steps must be performed:

        <ol class="nestedlist">

        <li> If the <code>[WebGLHandlesContextLoss]</code> extended attribute appears on the called
        method, perform the implementation of the called method, return its result and terminate
        these steps. </li>

        <li> Let <em>use default return value</em> be false. </li>

        <li> If the <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set,
        let <em>use default return value</em> be true.

            <ol class="nestedlist">

            <li> Otherwise, if any argument to the method is a <code>WebGLObject</code> with
            its <a href="#webgl-object-invalidated-flag">invalidated flag</a> set, generate
            an <code>INVALID_OPERATION</code> error and let <em>use default return value</em> be
            true. </li>

            </ol>

        </li>

        <li> If <em>use default return value</em> is true, perform the following steps:

            <ol class="nestedlist">

            <li> If the return type of the called method is <code>any</code> or any nullable type,
            return null. </li>

            <li> Terminate this algorithm without calling the method implementation. </li>

            </ol>

        </li>

        <li> Otherwise, perform the implementation of the called method and return its result. </li>

        </ol>
    </p>
    <p>
    See <a href="#CONTEXT_LOST">the context lost event</a> for further details.
    </p>
    <pre class="idl">
typedef (ImageBitmap or
         ImageData or
         HTMLImageElement or
         HTMLCanvasElement or
         HTMLVideoElement or
         OffscreenCanvas) TexImageSource;

typedef ([AllowShared] Float32Array or sequence&lt;GLfloat&gt;) Float32List;
typedef ([AllowShared] Int32Array or sequence&lt;GLint&gt;) Int32List;

interface mixin <dfn id="WebGLRenderingContextBase">WebGLRenderingContextBase</dfn>
{

    /* ClearBufferMask */
    const GLenum DEPTH_BUFFER_BIT               = 0x00000100;
    const GLenum STENCIL_BUFFER_BIT             = 0x00000400;
    const GLenum COLOR_BUFFER_BIT               = 0x00004000;

    /* BeginMode */
    const GLenum POINTS                         = 0x0000;
    const GLenum LINES                          = 0x0001;
    const GLenum LINE_LOOP                      = 0x0002;
    const GLenum LINE_STRIP                     = 0x0003;
    const GLenum TRIANGLES                      = 0x0004;
    const GLenum TRIANGLE_STRIP                 = 0x0005;
    const GLenum TRIANGLE_FAN                   = 0x0006;

    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */

    /* BlendingFactorDest */
    const GLenum ZERO                           = 0;
    const GLenum ONE                            = 1;
    const GLenum SRC_COLOR                      = 0x0300;
    const GLenum ONE_MINUS_SRC_COLOR            = 0x0301;
    const GLenum SRC_ALPHA                      = 0x0302;
    const GLenum ONE_MINUS_SRC_ALPHA            = 0x0303;
    const GLenum DST_ALPHA                      = 0x0304;
    const GLenum ONE_MINUS_DST_ALPHA            = 0x0305;

    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    const GLenum DST_COLOR                      = 0x0306;
    const GLenum ONE_MINUS_DST_COLOR            = 0x0307;
    const GLenum SRC_ALPHA_SATURATE             = 0x0308;
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */

    /* BlendEquationSeparate */
    const GLenum FUNC_ADD                       = 0x8006;
    const GLenum BLEND_EQUATION                 = 0x8009;
    const GLenum BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
    const GLenum BLEND_EQUATION_ALPHA           = 0x883D;

    /* BlendSubtract */
    const GLenum FUNC_SUBTRACT                  = 0x800A;
    const GLenum FUNC_REVERSE_SUBTRACT          = 0x800B;

    /* Separate Blend Functions */
    const GLenum BLEND_DST_RGB                  = 0x80C8;
    const GLenum BLEND_SRC_RGB                  = 0x80C9;
    const GLenum BLEND_DST_ALPHA                = 0x80CA;
    const GLenum BLEND_SRC_ALPHA                = 0x80CB;
    const GLenum CONSTANT_COLOR                 = 0x8001;
    const GLenum ONE_MINUS_CONSTANT_COLOR       = 0x8002;
    const GLenum CONSTANT_ALPHA                 = 0x8003;
    const GLenum ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
    const GLenum BLEND_COLOR                    = 0x8005;

    /* Buffer Objects */
    const GLenum ARRAY_BUFFER                   = 0x8892;
    const GLenum ELEMENT_ARRAY_BUFFER           = 0x8893;
    const GLenum ARRAY_BUFFER_BINDING           = 0x8894;
    const GLenum ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;

    const GLenum STREAM_DRAW                    = 0x88E0;
    const GLenum STATIC_DRAW                    = 0x88E4;
    const GLenum DYNAMIC_DRAW                   = 0x88E8;

    const GLenum BUFFER_SIZE                    = 0x8764;
    const GLenum BUFFER_USAGE                   = 0x8765;

    const GLenum CURRENT_VERTEX_ATTRIB          = 0x8626;

    /* CullFaceMode */
    const GLenum FRONT                          = 0x0404;
    const GLenum BACK                           = 0x0405;
    const GLenum FRONT_AND_BACK                 = 0x0408;

    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */

    /* EnableCap */
    /* TEXTURE_2D */
    const GLenum CULL_FACE                      = 0x0B44;
    const GLenum BLEND                          = 0x0BE2;
    const GLenum DITHER                         = 0x0BD0;
    const GLenum STENCIL_TEST                   = 0x0B90;
    const GLenum DEPTH_TEST                     = 0x0B71;
    const GLenum SCISSOR_TEST                   = 0x0C11;
    const GLenum POLYGON_OFFSET_FILL            = 0x8037;
    const GLenum SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
    const GLenum SAMPLE_COVERAGE                = 0x80A0;

    /* ErrorCode */
    const GLenum NO_ERROR                       = 0;
    const GLenum INVALID_ENUM                   = 0x0500;
    const GLenum INVALID_VALUE                  = 0x0501;
    const GLenum INVALID_OPERATION              = 0x0502;
    const GLenum OUT_OF_MEMORY                  = 0x0505;

    /* FrontFaceDirection */
    const GLenum CW                             = 0x0900;
    const GLenum CCW                            = 0x0901;

    /* GetPName */
    const GLenum LINE_WIDTH                     = 0x0B21;
    const GLenum ALIASED_POINT_SIZE_RANGE       = 0x846D;
    const GLenum ALIASED_LINE_WIDTH_RANGE       = 0x846E;
    const GLenum CULL_FACE_MODE                 = 0x0B45;
    const GLenum FRONT_FACE                     = 0x0B46;
    const GLenum DEPTH_RANGE                    = 0x0B70;
    const GLenum DEPTH_WRITEMASK                = 0x0B72;
    const GLenum DEPTH_CLEAR_VALUE              = 0x0B73;
    const GLenum DEPTH_FUNC                     = 0x0B74;
    const GLenum STENCIL_CLEAR_VALUE            = 0x0B91;
    const GLenum STENCIL_FUNC                   = 0x0B92;
    const GLenum STENCIL_FAIL                   = 0x0B94;
    const GLenum STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
    const GLenum STENCIL_PASS_DEPTH_PASS        = 0x0B96;
    const GLenum STENCIL_REF                    = 0x0B97;
    const GLenum STENCIL_VALUE_MASK             = 0x0B93;
    const GLenum STENCIL_WRITEMASK              = 0x0B98;
    const GLenum STENCIL_BACK_FUNC              = 0x8800;
    const GLenum STENCIL_BACK_FAIL              = 0x8801;
    const GLenum STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
    const GLenum STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
    const GLenum STENCIL_BACK_REF               = 0x8CA3;
    const GLenum STENCIL_BACK_VALUE_MASK        = 0x8CA4;
    const GLenum STENCIL_BACK_WRITEMASK         = 0x8CA5;
    const GLenum VIEWPORT                       = 0x0BA2;
    const GLenum SCISSOR_BOX                    = 0x0C10;
    /*      SCISSOR_TEST */
    const GLenum COLOR_CLEAR_VALUE              = 0x0C22;
    const GLenum COLOR_WRITEMASK                = 0x0C23;
    const GLenum UNPACK_ALIGNMENT               = 0x0CF5;
    const GLenum PACK_ALIGNMENT                 = 0x0D05;
    const GLenum MAX_TEXTURE_SIZE               = 0x0D33;
    const GLenum MAX_VIEWPORT_DIMS              = 0x0D3A;
    const GLenum SUBPIXEL_BITS                  = 0x0D50;
    const GLenum RED_BITS                       = 0x0D52;
    const GLenum GREEN_BITS                     = 0x0D53;
    const GLenum BLUE_BITS                      = 0x0D54;
    const GLenum ALPHA_BITS                     = 0x0D55;
    const GLenum DEPTH_BITS                     = 0x0D56;
    const GLenum STENCIL_BITS                   = 0x0D57;
    const GLenum POLYGON_OFFSET_UNITS           = 0x2A00;
    /*      POLYGON_OFFSET_FILL */
    const GLenum POLYGON_OFFSET_FACTOR          = 0x8038;
    const GLenum TEXTURE_BINDING_2D             = 0x8069;
    const GLenum SAMPLE_BUFFERS                 = 0x80A8;
    const GLenum SAMPLES                        = 0x80A9;
    const GLenum SAMPLE_COVERAGE_VALUE          = 0x80AA;
    const GLenum SAMPLE_COVERAGE_INVERT         = 0x80AB;

    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */

    const GLenum COMPRESSED_TEXTURE_FORMATS     = 0x86A3;

    /* HintMode */
    const GLenum DONT_CARE                      = 0x1100;
    const GLenum FASTEST                        = 0x1101;
    const GLenum NICEST                         = 0x1102;

    /* HintTarget */
    const GLenum GENERATE_MIPMAP_HINT            = 0x8192;

    /* DataType */
    const GLenum BYTE                           = 0x1400;
    const GLenum UNSIGNED_BYTE                  = 0x1401;
    const GLenum SHORT                          = 0x1402;
    const GLenum UNSIGNED_SHORT                 = 0x1403;
    const GLenum INT                            = 0x1404;
    const GLenum UNSIGNED_INT                   = 0x1405;
    const GLenum FLOAT                          = 0x1406;

    /* PixelFormat */
    const GLenum DEPTH_COMPONENT                = 0x1902;
    const GLenum ALPHA                          = 0x1906;
    const GLenum RGB                            = 0x1907;
    const GLenum RGBA                           = 0x1908;
    const GLenum LUMINANCE                      = 0x1909;
    const GLenum LUMINANCE_ALPHA                = 0x190A;

    /* PixelType */
    /*      UNSIGNED_BYTE */
    const GLenum UNSIGNED_SHORT_4_4_4_4         = 0x8033;
    const GLenum UNSIGNED_SHORT_5_5_5_1         = 0x8034;
    const GLenum UNSIGNED_SHORT_5_6_5           = 0x8363;

    /* Shaders */
    const GLenum FRAGMENT_SHADER                  = 0x8B30;
    const GLenum VERTEX_SHADER                    = 0x8B31;
    const GLenum MAX_VERTEX_ATTRIBS               = 0x8869;
    const GLenum MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
    const GLenum MAX_VARYING_VECTORS              = 0x8DFC;
    const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
    const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
    const GLenum MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
    const GLenum MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
    const GLenum SHADER_TYPE                      = 0x8B4F;
    const GLenum DELETE_STATUS                    = 0x8B80;
    const GLenum LINK_STATUS                      = 0x8B82;
    const GLenum VALIDATE_STATUS                  = 0x8B83;
    const GLenum ATTACHED_SHADERS                 = 0x8B85;
    const GLenum ACTIVE_UNIFORMS                  = 0x8B86;
    const GLenum ACTIVE_ATTRIBUTES                = 0x8B89;
    const GLenum SHADING_LANGUAGE_VERSION         = 0x8B8C;
    const GLenum CURRENT_PROGRAM                  = 0x8B8D;

    /* StencilFunction */
    const GLenum NEVER                          = 0x0200;
    const GLenum LESS                           = 0x0201;
    const GLenum EQUAL                          = 0x0202;
    const GLenum LEQUAL                         = 0x0203;
    const GLenum GREATER                        = 0x0204;
    const GLenum NOTEQUAL                       = 0x0205;
    const GLenum GEQUAL                         = 0x0206;
    const GLenum ALWAYS                         = 0x0207;

    /* StencilOp */
    /*      ZERO */
    const GLenum KEEP                           = 0x1E00;
    const GLenum REPLACE                        = 0x1E01;
    const GLenum INCR                           = 0x1E02;
    const GLenum DECR                           = 0x1E03;
    const GLenum INVERT                         = 0x150A;
    const GLenum INCR_WRAP                      = 0x8507;
    const GLenum DECR_WRAP                      = 0x8508;

    /* StringName */
    const GLenum VENDOR                         = 0x1F00;
    const GLenum RENDERER                       = 0x1F01;
    const GLenum VERSION                        = 0x1F02;

    /* TextureMagFilter */
    const GLenum NEAREST                        = 0x2600;
    const GLenum LINEAR                         = 0x2601;

    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    const GLenum NEAREST_MIPMAP_NEAREST         = 0x2700;
    const GLenum LINEAR_MIPMAP_NEAREST          = 0x2701;
    const GLenum NEAREST_MIPMAP_LINEAR          = 0x2702;
    const GLenum LINEAR_MIPMAP_LINEAR           = 0x2703;

    /* TextureParameterName */
    const GLenum TEXTURE_MAG_FILTER             = 0x2800;
    const GLenum TEXTURE_MIN_FILTER             = 0x2801;
    const GLenum TEXTURE_WRAP_S                 = 0x2802;
    const GLenum TEXTURE_WRAP_T                 = 0x2803;

    /* TextureTarget */
    const GLenum TEXTURE_2D                     = 0x0DE1;
    const GLenum TEXTURE                        = 0x1702;

    const GLenum TEXTURE_CUBE_MAP               = 0x8513;
    const GLenum TEXTURE_BINDING_CUBE_MAP       = 0x8514;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
    const GLenum MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;

    /* TextureUnit */
    const GLenum TEXTURE0                       = 0x84C0;
    const GLenum TEXTURE1                       = 0x84C1;
    const GLenum TEXTURE2                       = 0x84C2;
    const GLenum TEXTURE3                       = 0x84C3;
    const GLenum TEXTURE4                       = 0x84C4;
    const GLenum TEXTURE5                       = 0x84C5;
    const GLenum TEXTURE6                       = 0x84C6;
    const GLenum TEXTURE7                       = 0x84C7;
    const GLenum TEXTURE8                       = 0x84C8;
    const GLenum TEXTURE9                       = 0x84C9;
    const GLenum TEXTURE10                      = 0x84CA;
    const GLenum TEXTURE11                      = 0x84CB;
    const GLenum TEXTURE12                      = 0x84CC;
    const GLenum TEXTURE13                      = 0x84CD;
    const GLenum TEXTURE14                      = 0x84CE;
    const GLenum TEXTURE15                      = 0x84CF;
    const GLenum TEXTURE16                      = 0x84D0;
    const GLenum TEXTURE17                      = 0x84D1;
    const GLenum TEXTURE18                      = 0x84D2;
    const GLenum TEXTURE19                      = 0x84D3;
    const GLenum TEXTURE20                      = 0x84D4;
    const GLenum TEXTURE21                      = 0x84D5;
    const GLenum TEXTURE22                      = 0x84D6;
    const GLenum TEXTURE23                      = 0x84D7;
    const GLenum TEXTURE24                      = 0x84D8;
    const GLenum TEXTURE25                      = 0x84D9;
    const GLenum TEXTURE26                      = 0x84DA;
    const GLenum TEXTURE27                      = 0x84DB;
    const GLenum TEXTURE28                      = 0x84DC;
    const GLenum TEXTURE29                      = 0x84DD;
    const GLenum TEXTURE30                      = 0x84DE;
    const GLenum TEXTURE31                      = 0x84DF;
    const GLenum ACTIVE_TEXTURE                 = 0x84E0;

    /* TextureWrapMode */
    const GLenum REPEAT                         = 0x2901;
    const GLenum CLAMP_TO_EDGE                  = 0x812F;
    const GLenum MIRRORED_REPEAT                = 0x8370;

    /* Uniform Types */
    const GLenum FLOAT_VEC2                     = 0x8B50;
    const GLenum FLOAT_VEC3                     = 0x8B51;
    const GLenum FLOAT_VEC4                     = 0x8B52;
    const GLenum INT_VEC2                       = 0x8B53;
    const GLenum INT_VEC3                       = 0x8B54;
    const GLenum INT_VEC4                       = 0x8B55;
    const GLenum BOOL                           = 0x8B56;
    const GLenum BOOL_VEC2                      = 0x8B57;
    const GLenum BOOL_VEC3                      = 0x8B58;
    const GLenum BOOL_VEC4                      = 0x8B59;
    const GLenum FLOAT_MAT2                     = 0x8B5A;
    const GLenum FLOAT_MAT3                     = 0x8B5B;
    const GLenum FLOAT_MAT4                     = 0x8B5C;
    const GLenum SAMPLER_2D                     = 0x8B5E;
    const GLenum SAMPLER_CUBE                   = 0x8B60;

    /* Vertex Arrays */
    const GLenum VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
    const GLenum VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
    const GLenum VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
    const GLenum VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
    const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
    const GLenum VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
    const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

    /* Read Format */
    const GLenum IMPLEMENTATION_COLOR_READ_TYPE   = 0x8B9A;
    const GLenum IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;

    /* Shader Source */
    const GLenum COMPILE_STATUS                 = 0x8B81;

    /* Shader Precision-Specified Types */
    const GLenum LOW_FLOAT                      = 0x8DF0;
    const GLenum MEDIUM_FLOAT                   = 0x8DF1;
    const GLenum HIGH_FLOAT                     = 0x8DF2;
    const GLenum LOW_INT                        = 0x8DF3;
    const GLenum MEDIUM_INT                     = 0x8DF4;
    const GLenum HIGH_INT                       = 0x8DF5;

    /* Framebuffer Object. */
    const GLenum FRAMEBUFFER                    = 0x8D40;
    const GLenum RENDERBUFFER                   = 0x8D41;

    const GLenum RGBA4                          = 0x8056;
    const GLenum RGB5_A1                        = 0x8057;
    const GLenum RGB565                         = 0x8D62;
    const GLenum DEPTH_COMPONENT16              = 0x81A5;
    const GLenum STENCIL_INDEX8                 = 0x8D48;
    const GLenum DEPTH_STENCIL                  = 0x84F9;

    const GLenum RENDERBUFFER_WIDTH             = 0x8D42;
    const GLenum RENDERBUFFER_HEIGHT            = 0x8D43;
    const GLenum RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
    const GLenum RENDERBUFFER_RED_SIZE          = 0x8D50;
    const GLenum RENDERBUFFER_GREEN_SIZE        = 0x8D51;
    const GLenum RENDERBUFFER_BLUE_SIZE         = 0x8D52;
    const GLenum RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
    const GLenum RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
    const GLenum RENDERBUFFER_STENCIL_SIZE      = 0x8D55;

    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

    const GLenum COLOR_ATTACHMENT0              = 0x8CE0;
    const GLenum DEPTH_ATTACHMENT               = 0x8D00;
    const GLenum STENCIL_ATTACHMENT             = 0x8D20;
    const GLenum DEPTH_STENCIL_ATTACHMENT       = 0x821A;

    const GLenum NONE                           = 0;

    const GLenum FRAMEBUFFER_COMPLETE                      = 0x8CD5;
    const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
    const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
    const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
    const GLenum FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;

    const GLenum FRAMEBUFFER_BINDING            = 0x8CA6;
    const GLenum RENDERBUFFER_BINDING           = 0x8CA7;
    const GLenum MAX_RENDERBUFFER_SIZE          = 0x84E8;

    const GLenum INVALID_FRAMEBUFFER_OPERATION  = 0x0506;

    /* WebGL-specific enums */
    const GLenum UNPACK_FLIP_Y_WEBGL            = 0x9240;
    const GLenum UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
    const GLenum CONTEXT_LOST_WEBGL             = 0x9242;
    const GLenum UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
    const GLenum BROWSER_DEFAULT_WEBGL          = 0x9244;

    [Exposed=Window] readonly attribute (HTMLCanvasElement or OffscreenCanvas) canvas;
    [Exposed=Worker] readonly attribute OffscreenCanvas canvas;
    readonly attribute GLsizei drawingBufferWidth;
    readonly attribute GLsizei drawingBufferHeight;

    [WebGLHandlesContextLoss] WebGLContextAttributes? getContextAttributes();
    [WebGLHandlesContextLoss] boolean isContextLost();

    sequence&lt;DOMString&gt;? getSupportedExtensions();
    object? getExtension(DOMString name);

    void activeTexture(GLenum texture);
    void attachShader(WebGLProgram program, WebGLShader shader);
    void bindAttribLocation(WebGLProgram program, GLuint index, DOMString name);
    void bindBuffer(GLenum target, WebGLBuffer? buffer);
    void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer);
    void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer);
    void bindTexture(GLenum target, WebGLTexture? texture);
    void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void blendEquation(GLenum mode);
    void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
    void blendFunc(GLenum sfactor, GLenum dfactor);
    void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB,
                           GLenum srcAlpha, GLenum dstAlpha);

    [WebGLHandlesContextLoss] GLenum checkFramebufferStatus(GLenum target);
    void clear(GLbitfield mask);
    void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void clearDepth(GLclampf depth);
    void clearStencil(GLint s);
    void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
    void compileShader(WebGLShader shader);

    void copyTexImage2D(GLenum target, GLint level, GLenum internalformat,
                        GLint x, GLint y, GLsizei width, GLsizei height,
                        GLint border);
    void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                           GLint x, GLint y, GLsizei width, GLsizei height);

    WebGLBuffer? createBuffer();
    WebGLFramebuffer? createFramebuffer();
    WebGLProgram? createProgram();
    WebGLRenderbuffer? createRenderbuffer();
    WebGLShader? createShader(GLenum type);
    WebGLTexture? createTexture();

    void cullFace(GLenum mode);

    void deleteBuffer(WebGLBuffer? buffer);
    void deleteFramebuffer(WebGLFramebuffer? framebuffer);
    void deleteProgram(WebGLProgram? program);
    void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer);
    void deleteShader(WebGLShader? shader);
    void deleteTexture(WebGLTexture? texture);

    void depthFunc(GLenum func);
    void depthMask(GLboolean flag);
    void depthRange(GLclampf zNear, GLclampf zFar);
    void detachShader(WebGLProgram program, WebGLShader shader);
    void disable(GLenum cap);
    void disableVertexAttribArray(GLuint index);
    void drawArrays(GLenum mode, GLint first, GLsizei count);
    void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset);

    void enable(GLenum cap);
    void enableVertexAttribArray(GLuint index);
    void finish();
    void flush();
    void framebufferRenderbuffer(GLenum target, GLenum attachment,
                                 GLenum renderbuffertarget,
                                 WebGLRenderbuffer? renderbuffer);
    void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget,
                              WebGLTexture? texture, GLint level);
    void frontFace(GLenum mode);

    void generateMipmap(GLenum target);

    WebGLActiveInfo? getActiveAttrib(WebGLProgram program, GLuint index);
    WebGLActiveInfo? getActiveUniform(WebGLProgram program, GLuint index);
    sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram program);

    [WebGLHandlesContextLoss] GLint getAttribLocation(WebGLProgram program, DOMString name);

    any getBufferParameter(GLenum target, GLenum pname);
    any getParameter(GLenum pname);

    [WebGLHandlesContextLoss] GLenum getError();

    any getFramebufferAttachmentParameter(GLenum target, GLenum attachment,
                                          GLenum pname);
    any getProgramParameter(WebGLProgram program, GLenum pname);
    DOMString? getProgramInfoLog(WebGLProgram program);
    any getRenderbufferParameter(GLenum target, GLenum pname);
    any getShaderParameter(WebGLShader shader, GLenum pname);
    WebGLShaderPrecisionFormat? getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype);
    DOMString? getShaderInfoLog(WebGLShader shader);

    DOMString? getShaderSource(WebGLShader shader);

    any getTexParameter(GLenum target, GLenum pname);

    any getUniform(WebGLProgram program, WebGLUniformLocation location);

    WebGLUniformLocation? getUniformLocation(WebGLProgram program, DOMString name);

    any getVertexAttrib(GLuint index, GLenum pname);

    [WebGLHandlesContextLoss] GLintptr getVertexAttribOffset(GLuint index, GLenum pname);

    void hint(GLenum target, GLenum mode);
    [WebGLHandlesContextLoss] GLboolean isBuffer(WebGLBuffer? buffer);
    [WebGLHandlesContextLoss] GLboolean isEnabled(GLenum cap);
    [WebGLHandlesContextLoss] GLboolean isFramebuffer(WebGLFramebuffer? framebuffer);
    [WebGLHandlesContextLoss] GLboolean isProgram(WebGLProgram? program);
    [WebGLHandlesContextLoss] GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer);
    [WebGLHandlesContextLoss] GLboolean isShader(WebGLShader? shader);
    [WebGLHandlesContextLoss] GLboolean isTexture(WebGLTexture? texture);
    void lineWidth(GLfloat width);
    void linkProgram(WebGLProgram program);
    void pixelStorei(GLenum pname, GLint param);
    void polygonOffset(GLfloat factor, GLfloat units);

    void renderbufferStorage(GLenum target, GLenum internalformat,
                             GLsizei width, GLsizei height);
    void sampleCoverage(GLclampf value, GLboolean invert);
    void scissor(GLint x, GLint y, GLsizei width, GLsizei height);

    void shaderSource(WebGLShader shader, DOMString source);

    void stencilFunc(GLenum func, GLint ref, GLuint mask);
    void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
    void stencilMask(GLuint mask);
    void stencilMaskSeparate(GLenum face, GLuint mask);
    void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
    void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);

    void texParameterf(GLenum target, GLenum pname, GLfloat param);
    void texParameteri(GLenum target, GLenum pname, GLint param);

    void uniform1f(WebGLUniformLocation? location, GLfloat x);
    void uniform2f(WebGLUniformLocation? location, GLfloat x, GLfloat y);
    void uniform3f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z);
    void uniform4f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);

    void uniform1i(WebGLUniformLocation? location, GLint x);
    void uniform2i(WebGLUniformLocation? location, GLint x, GLint y);
    void uniform3i(WebGLUniformLocation? location, GLint x, GLint y, GLint z);
    void uniform4i(WebGLUniformLocation? location, GLint x, GLint y, GLint z, GLint w);

    void useProgram(WebGLProgram? program);
    void validateProgram(WebGLProgram program);

    void vertexAttrib1f(GLuint index, GLfloat x);
    void vertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
    void vertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
    void vertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);

    void vertexAttrib1fv(GLuint index, Float32List values);
    void vertexAttrib2fv(GLuint index, Float32List values);
    void vertexAttrib3fv(GLuint index, Float32List values);
    void vertexAttrib4fv(GLuint index, Float32List values);

    void vertexAttribPointer(GLuint index, GLint size, GLenum type,
                             GLboolean normalized, GLsizei stride, GLintptr offset);

    void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
};

interface mixin <dfn id="WebGLRenderingContextOverloads">WebGLRenderingContextOverloads</dfn>
{
    void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
    void bufferData(GLenum target, [AllowShared] BufferSource? data, GLenum usage);
    void bufferSubData(GLenum target, GLintptr offset, [AllowShared] BufferSource data);

    void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat,
                              GLsizei width, GLsizei height, GLint border,
                              [AllowShared] ArrayBufferView data);
    void compressedTexSubImage2D(GLenum target, GLint level,
                                 GLint xoffset, GLint yoffset,
                                 GLsizei width, GLsizei height, GLenum format,
                                 [AllowShared] ArrayBufferView data);

    void readPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                    GLenum format, GLenum type, [AllowShared] ArrayBufferView? pixels);

    void texImage2D(GLenum target, GLint level, GLint internalformat,
                    GLsizei width, GLsizei height, GLint border, GLenum format,
                    GLenum type, [AllowShared] ArrayBufferView? pixels);
    void texImage2D(GLenum target, GLint level, GLint internalformat,
                    GLenum format, GLenum type, TexImageSource source); // May throw DOMException

    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                       GLsizei width, GLsizei height,
                       GLenum format, GLenum type, [AllowShared] ArrayBufferView? pixels);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                       GLenum format, GLenum type, TexImageSource source); // May throw DOMException

    void uniform1fv(WebGLUniformLocation? location, Float32List v);
    void uniform2fv(WebGLUniformLocation? location, Float32List v);
    void uniform3fv(WebGLUniformLocation? location, Float32List v);
    void uniform4fv(WebGLUniformLocation? location, Float32List v);

    void uniform1iv(WebGLUniformLocation? location, Int32List v);
    void uniform2iv(WebGLUniformLocation? location, Int32List v);
    void uniform3iv(WebGLUniformLocation? location, Int32List v);
    void uniform4iv(WebGLUniformLocation? location, Int32List v);

    void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List value);
    void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List value);
    void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List value);
};

[Exposed=(Window,Worker)]
interface <dfn id="WebGLRenderingContext">WebGLRenderingContext</dfn>
{
};
WebGLRenderingContext includes WebGLRenderingContextBase;
WebGLRenderingContext includes WebGLRenderingContextOverloads;
</pre>

<!-- ======================================================================================================= -->

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-canvas">
                    canvas
                </a>
            </code>
            of type <code>(HTMLCanvasElement or OffscreenCanvas)</code>
        <dd>
            A reference to the canvas element or OffscreenCanvas object which created this context.

        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-drawingBufferWidth">
                    drawingBufferWidth
                </a>
            </code>
            of type <code>GLsizei</code>
        <dd>
            The actual width of the drawing buffer. May be different from the
            <code>width</code> attribute of the <code>HTMLCanvasElement</code> if
            the implementation is unable to satisfy the requested widthor height.

        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-drawingBufferHeight">
                    drawingBufferHeight
                </a>
            </code>
            of type <code>GLsizei</code>
        <dd>
            The actual height of the drawing buffer. May be different from the
            <code>height</code> attribute of the <code>HTMLCanvasElement</code> if
            the implementation is unable to satisfy the requested width or height.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Getting information about the context</h4>

    <dl class="methods">
        <dt class="idl-code">[WebGLHandlesContextLoss] WebGLContextAttributes? getContextAttributes()
        <dd>
            If the <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set, returns
            null. Otherwise, returns a copy of the <a href="#actual-context-parameters">actual
            context parameters</a>.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Setting and getting state</h4>

    <p>
        OpenGL ES 2.0 maintains state values for use in rendering. All the calls in this
        group behave identically to their OpenGL counterparts unless otherwise noted.
    </p>

    <dl class="methods">
        <dt class="idl-code">void activeTexture(GLenum texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7">OpenGL ES 2.0 &sect;3.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glActiveTexture.xml">man page</a>)</span>
        <dt class="idl-code">void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendColor.xml">man page</a>)</span>
        <dt class="idl-code">void blendEquation(GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendEquation.xml">man page</a>)</span>
        <dt class="idl-code">void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendEquationSeparate.xml">man page</a>)</span>
        <dt class="idl-code">void blendFunc(GLenum sfactor, GLenum dfactor)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendFunc.xml">man page</a>)</span>
            <dd>
                See <a href="#CONSTANT_COLOR_BLEND">Blending With Constant Color</a> for limitations imposed
                by WebGL.
        <dt class="idl-code">void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendFuncSeparate.xml">man page</a>)</span>
            <dd>
                See <a href="#CONSTANT_COLOR_BLEND">Blending With Constant Color</a> for limitations imposed
                by WebGL.
        <dt class="idl-code">void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearColor.xml">man page</a>)</span>
        <dt class="idl-code">void clearDepth(GLclampf depth)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearDepthf.xml">man page</a>)</span>
            <dd>
                <code>depth</code> value is clamped to the range 0 to 1.
        <dt class="idl-code">void clearStencil(GLint s)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearStencil.xml">man page</a>)</span>
        <dt class="idl-code">void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glColorMask.xml">man page</a>)</span>
        <dt class="idl-code">void cullFace(GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.1">OpenGL ES 2.0 &sect;3.5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCullFace.xml">man page</a>)</span>
        <dt class="idl-code">void depthFunc(GLenum func)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.5">OpenGL ES 2.0 &sect;4.1.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthFunc.xml">man page</a>)</span>
        <dt class="idl-code">void depthMask(GLboolean flag)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthMask.xml">man page</a>)</span>
        <dt class="idl-code">void depthRange(GLclampf zNear, GLclampf zFar)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.12.1">OpenGL ES 2.0 &sect;2.12.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthRangef.xml">man page</a>)</span>
            <dd>
                <code>zNear</code> and <code>zFar</code> values are clamped to the range 0 to 1 and
                <code>zNear</code> must be less than or equal to <code>zFar</code>; see
                <a href="#VIEWPORT_DEPTH_RANGE">Viewport Depth Range</a>.
        <dt class="idl-code">void disable(GLenum cap)
            <span class="gl-spec">(<a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDisable.xml">man page</a>)</span>
        <dt class="idl-code">void enable(GLenum cap)
            <span class="gl-spec">(<a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glEnable.xml">man page</a>)</span>
        <dt class="idl-code">void frontFace(GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.1">OpenGL ES 2.0 &sect;3.5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFrontFace.xml">man page</a>)</span>
        <dt class="idl-code"><a name="GETPARAMETER">any getParameter</a>(GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGet.xml">
                (glGet OpenGL ES 2.0 man page)
            </a>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetString.xml">
                (glGetString OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>ACTIVE_TEXTURE</td><td>GLenum</td></tr>
                <tr><td>ALIASED_LINE_WIDTH_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ALIASED_POINT_SIZE_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ALPHA_BITS</td><td>GLint</td></tr>
                <tr><td>ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>BLEND</td><td>GLboolean</td></tr>
                <tr><td>BLEND_COLOR</td><td>Float32Array (with 4 values)</td></tr>
                <tr><td>BLEND_DST_ALPHA</td><td>GLenum</td></tr>
                <tr><td>BLEND_DST_RGB</td><td>GLenum</td></tr>
                <tr><td>BLEND_EQUATION_ALPHA</td><td>GLenum</td></tr>
                <tr><td>BLEND_EQUATION_RGB</td><td>GLenum</td></tr>
                <tr><td>BLEND_SRC_ALPHA</td><td>GLenum</td></tr>
                <tr><td>BLEND_SRC_RGB</td><td>GLenum</td></tr>
                <tr><td>BLUE_BITS</td><td>GLint</td></tr>
                <tr><td>COLOR_CLEAR_VALUE</td><td>Float32Array (with 4 values)</td></tr>
                <tr><td>COLOR_WRITEMASK</td><td>sequence&lt;GLboolean&gt; (with 4 values)</td></tr>
                <tr><td>COMPRESSED_TEXTURE_FORMATS</td><td>Uint32Array</td></tr>
                <tr><td>CULL_FACE</td><td>GLboolean</td></tr>
                <tr><td>CULL_FACE_MODE</td><td>GLenum</td></tr>
                <tr><td>CURRENT_PROGRAM</td><td>WebGLProgram</td></tr>
                <tr><td>DEPTH_BITS</td><td>GLint</td></tr>
                <tr><td>DEPTH_CLEAR_VALUE</td><td>GLfloat</td></tr>
                <tr><td>DEPTH_FUNC</td><td>GLenum</td></tr>
                <tr><td>DEPTH_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>DEPTH_TEST</td><td>GLboolean</td></tr>
                <tr><td>DEPTH_WRITEMASK</td><td>GLboolean</td></tr>
                <tr><td>DITHER</td><td>GLboolean</td></tr>
                <tr><td>ELEMENT_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>FRONT_FACE</td><td>GLenum</td></tr>
                <tr><td>GENERATE_MIPMAP_HINT</td><td>GLenum</td></tr>
                <tr><td>GREEN_BITS</td><td>GLint</td></tr>
                <tr><td>IMPLEMENTATION_COLOR_READ_FORMAT</td><td>GLenum</td></tr>
                <tr><td>IMPLEMENTATION_COLOR_READ_TYPE</td><td>GLenum</td></tr>
                <tr><td>LINE_WIDTH</td><td>GLfloat</td></tr>
                <tr><td>MAX_COMBINED_TEXTURE_IMAGE_UNITS</td><td>GLint</td></tr>
                <tr><td>MAX_CUBE_MAP_TEXTURE_SIZE</td><td>GLint</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_VECTORS</td><td>GLint</td></tr>
                <tr><td>MAX_RENDERBUFFER_SIZE</td><td>GLint</td></tr>
                <tr><td>MAX_TEXTURE_IMAGE_UNITS</td><td>GLint</td></tr>
                <tr><td>MAX_TEXTURE_SIZE</td><td>GLint</td></tr>
                <tr><td>MAX_VARYING_VECTORS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_ATTRIBS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_TEXTURE_IMAGE_UNITS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_VECTORS</td><td>GLint</td></tr>
                <tr><td>MAX_VIEWPORT_DIMS</td><td>Int32Array (with 2 elements)</td></tr>
                <tr><td>PACK_ALIGNMENT</td><td>GLint</td></tr>
                <tr><td>POLYGON_OFFSET_FACTOR</td><td>GLfloat</td></tr>
                <tr><td>POLYGON_OFFSET_FILL</td><td>GLboolean</td></tr>
                <tr><td>POLYGON_OFFSET_UNITS</td><td>GLfloat</td></tr>
                <tr><td>RED_BITS</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_BINDING</td><td>WebGLRenderbuffer</td></tr>
                <tr><td>RENDERER</td><td>DOMString</td></tr>
                <tr><td>SAMPLE_ALPHA_TO_COVERAGE</td><td>GLboolean</td></tr>
                <tr><td>SAMPLE_BUFFERS</td><td>GLint</td></tr>
                <tr><td>SAMPLE_COVERAGE</td><td>GLboolean</td></tr>
                <tr><td>SAMPLE_COVERAGE_INVERT</td><td>GLboolean</td></tr>
                <tr><td>SAMPLE_COVERAGE_VALUE</td><td>GLfloat</td></tr>
                <tr><td>SAMPLES</td><td>GLint</td></tr>
                <tr><td>SCISSOR_BOX</td><td>Int32Array (with 4 elements)</td></tr>
                <tr><td>SCISSOR_TEST</td><td>GLboolean</td></tr>
                <tr><td>SHADING_LANGUAGE_VERSION</td><td>DOMString</td></tr>
                <tr><td>STENCIL_BACK_FAIL</td><td>GLenum</td></tr>
                <tr><td>STENCIL_BACK_FUNC</td><td>GLenum</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_FAIL</td><td>GLenum</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_PASS</td><td>GLenum</td></tr>
                <tr><td>STENCIL_BACK_REF</td><td>GLint</td></tr>
                <tr><td>STENCIL_BACK_VALUE_MASK</td><td>GLuint</td></tr>
                <tr><td>STENCIL_BACK_WRITEMASK</td><td>GLuint</td></tr>
                <tr><td>STENCIL_BITS</td><td>GLint</td></tr>
                <tr><td>STENCIL_CLEAR_VALUE</td><td>GLint</td></tr>
                <tr><td>STENCIL_FAIL</td><td>GLenum</td></tr>
                <tr><td>STENCIL_FUNC</td><td>GLenum</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_FAIL</td><td>GLenum</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_PASS</td><td>GLenum</td></tr>
                <tr><td>STENCIL_REF</td><td>GLint</td></tr>
                <tr><td>STENCIL_TEST</td><td>GLboolean</td></tr>
                <tr><td>STENCIL_VALUE_MASK</td><td>GLuint</td></tr>
                <tr><td>STENCIL_WRITEMASK</td><td>GLuint</td></tr>
                <tr><td>SUBPIXEL_BITS</td><td>GLint</td></tr>
                <tr><td>TEXTURE_BINDING_2D</td><td>WebGLTexture</td></tr>
                <tr><td>TEXTURE_BINDING_CUBE_MAP</td><td>WebGLTexture</td></tr>
                <tr><td>UNPACK_ALIGNMENT</td><td>GLint</td></tr>
                <tr><td>UNPACK_COLORSPACE_CONVERSION_WEBGL</td><td>GLenum</td></tr>
                <tr><td>UNPACK_FLIP_Y_WEBGL</td><td>GLboolean</td></tr>
                <tr><td>UNPACK_PREMULTIPLY_ALPHA_WEBGL</td><td>GLboolean</td></tr>
                <tr><td>VENDOR</td><td>DOMString</td></tr>
                <tr><td>VERSION</td><td>DOMString</td></tr>
                <tr><td>VIEWPORT</td><td>Int32Array (with 4 elements)</td></tr>
            </table><br>
            <p>All queries returning sequences or typed arrays return a new object each time.</p>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
            <p>If <em>pname</em> is <code>IMPLEMENTATION_COLOR_READ_FORMAT</code>
            or <code>IMPLEMENTATION_COLOR_READ_TYPE</code>, and the currently bound framebuffer is
            not <em>framebuffer complete</em>, generates an <code>INVALID_OPERATION</code> error and
            returns null.
            <p>The following <em>pname</em> arguments return a string describing some aspect of the current WebGL implementation:</p>
            <table>
              <tr><td>VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;1.0&lt;optional&gt;&lt;space&gt;&lt;vendor-specific information&gt;&lt;/optional&gt;</code>.</td></tr>
              <tr><td>SHADING_LANGUAGE_VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;1.0&lt;optional&gt;&lt;space&gt;&lt;vendor-specific information&gt;&lt;/optional&gt;</code>.</td></tr>
              <tr><td>VENDOR</td>
                  <td>Returns the company responsible for this WebGL implementation. This name does not change from release to release.</td></tr>
              <tr><td>RENDERER</td>
                  <td>Returns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.</td></tr>
            </table><br>
            <p>See <a href="#EXTENSION_QUERIES">Extension Queries</a> for information on querying the
            available extensions in the current WebGL implementation.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLenum getError()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.5">OpenGL ES 2.0 &sect;2.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetError.xml">man page</a>)</span>
            <dd>
                If the context's <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set,
                returns <code class="enum">CONTEXT_LOST_WEBGL</code> the first time this method is
                called. Afterward, returns <code class="enum">NO_ERROR</code> until the context has
                been restored.
        <dt class="idl-code">void hint(GLenum target, GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.2">OpenGL ES 2.0 &sect;5.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glHint.xml">man page</a>)</span>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isEnabled(GLenum cap)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.1">OpenGL ES 2.0 &sect;6.1.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsEnabled.xml">man page</a>)</span>
        <dd>
            For any <code>isEnabled</code> query, the same boolean value can be obtained via
            <code>getParameter</code>.
            <br><br>
            Returns false if the context's <a href="#webgl-context-lost-flag">webgl context lost
            flag</a> is set.
        <dt class="idl-code">void lineWidth(GLfloat width)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.4">OpenGL ES 2.0 &sect;3.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glLineWidth.xml">man page</a>)</span>
        <dd>
            See <a href="#NAN_LINE_WIDTH">NaN Line Width</a> for restrictions specified for WebGL.
        </dd>
        <dt class="idl-code">void pixelStorei(GLenum pname, GLint param)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.6.1">OpenGL ES 2.0 &sect;3.6.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glPixelStorei.xml">man page</a>)</span>
            <dd>
                In addition to the parameters in the OpenGL ES 2.0 specification, the WebGL
                specification accepts the parameters <code>UNPACK_FLIP_Y_WEBGL</code>,
                <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>
                and <code>UNPACK_COLORSPACE_CONVERSION_WEBGL</code>. See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel
                Storage Parameters</a> for documentation of these parameters.
        <dt class="idl-code">void polygonOffset(GLfloat factor, GLfloat units)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.2">OpenGL ES 2.0 &sect;3.5.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glPolygonOffset.xml">man page</a>)</span>
        <dt class="idl-code">void sampleCoverage(GLclampf value, GLboolean invert)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.3">OpenGL ES 2.0 &sect;4.1.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glSampleCoverage.xml">man page</a>)</span>
        <dt class="idl-code">void stencilFunc(GLenum func, GLint ref, GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilFunc.xml">man page</a>)</span>
        <dt class="idl-code">void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilFuncSeparate.xml">man page</a>)</span>
            <dd>
                See <a href="#STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a> for information
                on WebGL specific limitations to the allowable argument values.
        <dt class="idl-code">void stencilMask(GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilMask.xml">man page</a>)</span>
            <dd>
                See <a href="#STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a> for information
                on WebGL specific limitations to the allowable mask values.
        <dt class="idl-code">void stencilMaskSeparate(GLenum face, GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilMaskSeparate.xml">man page</a>)</span>
        <dt class="idl-code">void stencilOp(GLenum fail, GLenum zfail, GLenum zpass)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilOp.xml">man page</a>)</span>
        <dt class="idl-code">void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilOpSeparate.xml">man page</a>)</span>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Viewing and clipping</h4>

    <p>
        Drawing commands can only modify pixels inside the currently bound framebuffer. In
        addition, the viewport and the scissor box affect drawing.
    </p>

    <p>
        The viewport specifies the affine transformation of x and y from normalized device
        coordinates to window coordinates. The size of the viewport is initially determined
        as specified in section <a href="#WEBGL_VIEWPORT">The WebGL Viewport</a>.
        The scissor box defines a rectangle which constrains drawing. When the scissor test is
        enabled only pixels that lie within the scissor box can be modified by drawing commands
        including <code>clear</code>, and primitives can only be drawn inside the intersection
        of the viewport, the currently bound framebuffer, and the scissor box. When the scissor
        test is not enabled primitives can only be drawn inside the intersection of the viewport
        and the currently bound framebuffer.
    </p>

    <dl class="methods">
        <dt class="idl-code">void scissor(GLint x, GLint y, GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.2">OpenGL ES 2.0 &sect;4.1.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glScissor.xml">man page</a>)</span>

        <dt class="idl-code">void viewport(GLint x, GLint y, GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.12.1">OpenGL ES 2.0 &sect;2.12.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glViewport.xml">man page</a>)</span>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Buffer objects</h4>

    <p>
        Buffer objects (sometimes referred to as VBOs) hold vertex attribute data for the GLSL
        shaders.
    </p>

    <dl class="methods">
        <dt class="idl-code">void bindBuffer(GLenum target, WebGLBuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindBuffer.xml">man page</a>)</span>
        <dd>
            If <code>buffer</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Binds the given WebGLBuffer object to the given binding point (target), either
            ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER. If the buffer is null then any buffer currently
            bound to this target is unbound. A given WebGLBuffer object may only be bound to one of
            the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime. An attempt to bind a
            buffer object to the other target will generate an <code>INVALID_OPERATION</code> error, and the
            current binding will remain untouched.
            An attempt to bind an object marked for deletion will generate an
            <code>INVALID_OPERATION</code> error, and the current binding will remain untouched.

        <dt class="idl-code">void bufferData(GLenum target, GLsizeiptr size, GLenum usage)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferData.xml">man page</a>)</span>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target. The
            buffer is initialized to 0.

        <dt class="idl-code">void bufferData(GLenum target, [AllowShared] BufferSource? data, GLenum usage)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferData.xml">man page</a>)</span>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target to the
            size of the passed data, then write the contents of data to the buffer object.
            <br><br>
            If the passed data is null then an <code>INVALID_VALUE</code> error is generated.
        <dt><p class="idl-code">void bufferSubData(GLenum target, GLintptr offset, [AllowShared] BufferSource data)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferSubData.xml">man page</a>)</span></p>
        <dd>
            For the WebGLBuffer object bound to the passed target write the passed data starting at
            the passed offset. If the data would be written past the end of the buffer object
            an <code>INVALID_VALUE</code> error is generated. If <code>data</code> is null then
            an <code>INVALID_VALUE</code> error is generated.

        <dt class="idl-code">WebGLBuffer? createBuffer()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenBuffers.xml">glGenBuffers</a>)</span>
        <dd>
            Create a WebGLBuffer object and initialize it with a buffer object name as if by
            calling glGenBuffers.

        <dt class="idl-code">void deleteBuffer(WebGLBuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteBuffers.xml">glDeleteBuffers</a>)</span>
        <dd>
            If <code>buffer</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>
            Mark for deletion the buffer object contained in the passed WebGLBuffer, as if by
            calling glDeleteBuffers.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">any getBufferParameter(GLenum target, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetBufferParameteriv.xml">glGetBufferParameteriv</a>)</span>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>BUFFER_SIZE</td><td>GLint</td></tr>
                <tr><td>BUFFER_USAGE</td><td>GLenum</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isBuffer(WebGLBuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.6">OpenGL ES 2.0 &sect;6.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsBuffer.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLBuffer is valid and false otherwise. <br><br>

            Returns false if the buffer was generated by a
            different <code>WebGLRenderingContext</code> than this one. <br><br>

            Returns false if the buffer's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Framebuffer objects</h4>

    <p>
        Framebuffer objects provide an alternative rendering target to the drawing buffer. They
        are a collection of color, alpha, depth and stencil buffers and are often used to
        render an image that will later be used as a texture.
    </p>

    <dl class="methods">
        <dt class="idl-code">void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindFramebuffer.xml">man page</a>)</span>
        <dd>
            If <code>framebuffer</code> was generated by a
            different <code>WebGLRenderingContext</code> than this one, generates
            an <code>INVALID_OPERATION</code> error. <br><br>

            Bind the given <code class="interface">WebGLFramebuffer</code> object to the given binding point
            (<code class="param">target</code>), which must be <code class="enum">FRAMEBUFFER</code>.
            If <code class="param">framebuffer</code> is null, the default framebuffer provided by the context
            is bound and attempts to modify or query state on <code class="param">target</code> <code class="enum">FRAMEBUFFER</code>
            will generate an <code class="error">INVALID_OPERATION</code> error.
            An attempt to bind an object marked for deletion will generate an
            <code>INVALID_OPERATION</code> error, and the current binding will remain untouched.

        <dt class="idl-code"><a name="CHECK_FRAMEBUFFER_STATUS">[WebGLHandlesContextLoss] GLenum checkFramebufferStatus</a>(GLenum target)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.5">OpenGL ES 2.0 &sect;4.4.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCheckFramebufferStatus.xml">man page</a>)</span>
        <dd>
            Returns <code class="enum">FRAMEBUFFER_UNSUPPORTED</code> if the
            context's <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set.

        <dt class="idl-code">WebGLFramebuffer? createFramebuffer()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenFramebuffers.xml">glGenFramebuffers</a>)</span>
        <dd>
            Create a WebGLFramebuffer object and initialize it with a framebuffer object name as if by
            calling glGenFramebuffers.

        <dt class="idl-code">void deleteFramebuffer(WebGLFramebuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteFramebuffers.xml">glDeleteFramebuffers</a>)</span>
        <dd>
            If <code>framebuffer</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Mark for deletion the framebuffer object contained in the passed WebGLFramebuffer, as if
            by calling glDeleteFramebuffers.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">void framebufferRenderbuffer(GLenum target, GLenum attachment,
                                 GLenum renderbuffertarget,
                                 WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFramebufferRenderbuffer.xml">man page</a>)</span></dt>
        <dd>
            If <code>renderbuffer</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>
        <dt class="idl-code">void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget,
                              WebGLTexture? texture, GLint level)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFramebufferTexture2D.xml">man page</a>)</span>
        <dd>
            If <code>texture</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>
        <dt class="idl-code">any getFramebufferAttachmentParameter(GLenum target, GLenum attachment,
                                          GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetFramebufferAttachmentParameteriv.xml">glGetFramebufferAttachmentParameteriv</a>)</span>
        <dd>
            Return the value for the passed pname given the passed target and attachment. The type
            returned is the natural type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</td><td>GLenum</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</td><td>WebGLRenderbuffer or WebGLTexture</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</td><td>GLint</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</td><td>GLint</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isFramebuffer(WebGLFramebuffer? framebuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.7">OpenGL ES 2.0 &sect;6.1.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsFramebuffer.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLFramebuffer is valid and false otherwise. <br><br>

            Returns false if the framebuffer was generated by a
            different <code>WebGLRenderingContext</code> than this one. <br><br>

            Returns false if the framebuffer's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Renderbuffer objects</h4>

    <p>
        Renderbuffer objects are used to provide storage for the individual buffers used in a
        framebuffer object.
    </p>

    <dl class="methods">
        <dt class="idl-code">void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindRenderbuffer.xml">man page</a>)</span>
        <dd>
            If <code>renderbuffer</code> was generated by a
            different <code>WebGLRenderingContext</code> than this one, generates
            an <code>INVALID_OPERATION</code> error. <br><br>

            Bind the given <code class="interface">WebGLRenderbuffer</code> object to the given binding point
            (<code class="param">target</code>), which must be <code class="enum">RENDERBUFFER</code>.
            If <code class="param">renderbuffer</code> is null the renderbuffer object currently bound to
            this <code class="param">target</code> is unbound.
            An attempt to bind an object marked for deletion will generate an
            <code>INVALID_OPERATION</code> error, and the current binding will remain untouched.

        <dt class="idl-code">WebGLRenderbuffer? createRenderbuffer()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenRenderbuffers.xml">glGenRenderbuffers</a>)</span>
        <dd>
            Create a WebGLRenderbuffer object and initialize it with a renderbuffer object name as if by
            calling glGenRenderbuffers.

        <dt class="idl-code">void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteRenderbuffers.xml">glDeleteRenderbuffers</a>)</span>
        <dd>
            If <code>renderbuffer</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>
            Mark for deletion the renderbuffer object contained in the passed WebGLRenderbuffer, as
            if by calling glDeleteRenderbuffers.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">any getRenderbufferParameter(GLenum target, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetRenderbufferParameteriv.xml">glGetRenderbufferParameteriv</a>)</span>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>RENDERBUFFER_WIDTH</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_HEIGHT</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_INTERNAL_FORMAT</td><td>GLenum</td></tr>
                <tr><td>RENDERBUFFER_RED_SIZE</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_GREEN_SIZE</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_BLUE_SIZE</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_ALPHA_SIZE</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_DEPTH_SIZE</td><td>GLint</td></tr>
                <tr><td>RENDERBUFFER_STENCIL_SIZE</td><td>GLint</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.7">OpenGL ES 2.0 &sect;6.1.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsRenderbuffer.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLRenderbuffer is valid and false otherwise. <br><br>

            Returns false if the renderbuffer was generated by a
            different <code>WebGLRenderingContext</code> than this one. <br><br>

            Returns false if the renderbuffer's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code">void renderbufferStorage(GLenum target, GLenum internalformat,
                             GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glRenderbufferStorage.xml">man page</a>)</span>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Texture objects</h4>

    <p>
        Texture objects provide storage and state for texturing operations. If no WebGLTexture is bound
        (e.g., passing null or 0 to bindTexture) then attempts to modify or query the texture object shall
        generate an <code>INVALID_OPERATION</code> error. This is indicated in the functions below.
    </p>

    <dl class="methods">
        <dt class="idl-code">void bindTexture(GLenum target, WebGLTexture? texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindTexture.xml">man page</a>)</span>
        <dd>
            If <code>texture</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            An attempt to bind an object marked for deletion will generate an
            <code>INVALID_OPERATION</code> error, and the current binding will remain untouched.

        <dt><p class="idl-code"><a name="COMPRESSEDTEXIMAGE2D">void compressedTexImage2D</a>(GLenum target, GLint level, GLenum internalformat,
                    GLsizei width, GLsizei height, GLint border, [AllowShared] ArrayBufferView pixels)
                <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.3">OpenGL ES 2.0 &sect;3.7.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompressedTexImage2D.xml">man page</a>)</span></p>
            <p class="idl-code"><a name="COMPRESSEDTEXSUBIMAGE2D">void compressedTexSubImage2D</a>(GLenum target, GLint level,
                    GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, [AllowShared] ArrayBufferView pixels)
                <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.3">OpenGL ES 2.0 &sect;3.7.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompressedTexSubImage2D.xml">man page</a>)</span></p>
        <dd>
            If an attempt is made to call these functions with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            The core WebGL specification does not define any supported compressed texture formats.
            By default, these methods generate an <code>INVALID_ENUM</code> error and return
            immediately. See <a href="#COMPRESSED_TEXTURE_SUPPORT">Compressed Texture Support</a>.

        <dt class="idl-code">void copyTexImage2D(GLenum target, GLint level, GLenum internalformat,
                        GLint x, GLint y, GLsizei width, GLsizei height,
                        GLint border)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCopyTexImage2D.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            This function behaves as if <code>texImage2D</code> were called with null data, followed
            by <code>copyTexSubImage2D</code>.
            As in <code>copyTexSubImage2D</code>, for any source pixels lying outside the
            framebuffer, the corresponding destination texels are left untouched, and so they retain
            their zero-initialized contents as if <code>texImage2D</code> was called with null data.
            This has the combined effect that, for source pixels lying outside the
            framebuffer, corresponding destination pixels will have all channels of the associated
            texels initialized to 0;
            see <a href="#READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the Framebuffer</a>. <br><br>

            If this function attempts to read from a complete framebuffer with a missing attachment,
            an <code>INVALID_OPERATION</code> error is generated
            per <a href="#READING_FROM_MISSING_ATTACHMENT">Reading from a Missing Attachment</a>.
        <dt class="idl-code">void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                           GLint x, GLint y, GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCopyTexSubImage2D.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            For any pixel lying outside the frame buffer, the corresponding destination pixel remains untouched;
            see <a href="#READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the Framebuffer</a>. <br><br>

            If this function attempts to read from a complete framebuffer with a missing attachment,
            an <code>INVALID_OPERATION</code> error is generated
            per <a href="#READING_FROM_MISSING_ATTACHMENT">Reading from a Missing Attachment</a>.
        <dt class="idl-code">WebGLTexture? createTexture()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenTextures.xml">man page</a>)</span>
        <dd>
            Create a WebGLTexture object and initialize it with a texture object name as if by
            calling glGenTextures.

        <dt class="idl-code">void deleteTexture(WebGLTexture? texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteTextures.xml">man page</a>)</span>
        <dd>
            If <code>texture</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>
            Mark for deletion the texture object contained in the passed WebGLTexture, as if by
            calling glDeleteTextures.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">void generateMipmap(GLenum target)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.11">OpenGL ES 2.0 &sect;3.7.11</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenerateMipmap.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        <dt class="idl-code">any getTexParameter(GLenum target, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetTexParameter.xml">man page</a>)</span>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>TEXTURE_MAG_FILTER</td><td>GLenum</td></tr>
                <tr><td>TEXTURE_MIN_FILTER</td><td>GLenum</td></tr>
                <tr><td>TEXTURE_WRAP_S</td><td>GLenum</td></tr>
                <tr><td>TEXTURE_WRAP_T</td><td>GLenum</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an
            <code>INVALID_OPERATION</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isTexture(WebGLTexture? texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.4">OpenGL ES 2.0 &sect;6.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsTexture.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLTexture is valid and false otherwise. <br><br>

            Returns false if the texture was generated by a
            different <code>WebGLRenderingContext</code> than this one. <br><br>

            Returns false if the texture's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code"><a name="TEXIMAGE2D">void texImage2D</a>(GLenum target, GLint level, GLint internalformat,
                    GLsizei width, GLsizei height, GLint border, GLenum format,
                    GLenum type, [AllowShared] ArrayBufferView? pixels)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.1">OpenGL ES 2.0 &sect;3.7.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexImage2D.xml">man page</a>)</span>
        <dd>
            If <code>pixels</code> is null, a buffer of sufficient size initialized to 0 is
            passed. <br><br>

            If <code>pixels</code> is non-null, the type of <code>pixels</code> must match the type
            of the data to be read. If it is UNSIGNED_BYTE, a Uint8Array or Uint8ClampedArray must
            be supplied; if it is UNSIGNED_SHORT_5_6_5, UNSIGNED_SHORT_4_4_4_4, or
            UNSIGNED_SHORT_5_5_5_1, a Uint16Array must be supplied. If the types do not match, an
            INVALID_OPERATION error is generated.
            <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function. <br><br>

            If <code>pixels</code> is non-null but its size is less than what is required by the specified <em>width</em>, <em>height</em>, <em>format</em>, <em>type</em>, and pixel storage parameters, generates an <code>INVALID_OPERATION</code> error.

        <dt><p class="idl-code"><a name="TEXIMAGE2D_HTML">void texImage2D</a>(GLenum target, GLint level, GLint internalformat,
                    GLenum format, GLenum type, TexImageSource source) /* May throw DOMException */
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.1">OpenGL ES 2.0 &sect;3.7.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexImage2D.xml">man page</a>)</span></p>
        <dd>
            Uploads the given element or image data to the currently bound WebGLTexture. <br><br>

            The width and height of the texture are set as specified in section
            <a href="#TEXTURE_UPLOAD_SIZE">Texture Upload Width and Height</a>.<br><br>

            The source image data is conceptually first converted to the data type and format
            specified by the <em>format</em> and <em>type</em> arguments, and then transferred to
            the WebGL implementation. Format conversion is performed according to the following table.
            If a packed pixel format is specified which would imply loss of bits of precision from the
            image data, this loss of precision must occur. <br><br>

            <table class="foo">
              <tr>
                <th rowspan="2">Source DOM Image Format</th>
                <th colspan="5">Target WebGL Format</th>
              </tr>
              <tr>
                <th>ALPHA</th>
                <th>RGB</th>
                <th>RGBA</th>
                <th>LUMINANCE</th>
                <th>LUMINANCE_ALPHA</th>
              </tr>
              <tr>
                <td>Grayscale (1 channel)</td>
                <td>A = 255 (1.0)</td>
                <td>R = <em>sourceGray</em><br>G = <em>sourceGray</em><br>B = <em>sourceGray</em><br></td>
                <td>R = <em>sourceGray</em><br>G = <em>sourceGray</em><br>B = <em>sourceGray</em><br>A = 255 (1.0)</td>
                <td>L = <em>sourceGray</em></td>
                <td>L = <em>sourceGray</em><br>A = 255 (1.0)</td>
              </tr>
              <tr>
                <td>Grayscale + Alpha (2 channels)</td>
                <td>A = <em>sourceAlpha</em></td>
                <td>R = <em>sourceGray</em><br>G = <em>sourceGray</em><br>B = <em>sourceGray</em><br></td>
                <td>R = <em>sourceGray</em><br>G = <em>sourceGray</em><br>B = <em>sourceGray</em><br>A = <em>sourceAlpha</em></td>
                <td>L = <em>sourceGray</em><br></td>
                <td>L = <em>sourceGray</em><br>A = <em>sourceAlpha</em></td>
              </tr>
              <tr>
                <td>Color (3 channels)</td>
                <td>A = 255 (1.0)</td>
                <td>R = <em>sourceRed</em><br>G = <em>sourceGreen</em><br>B = <em>sourceBlue</em><br></td>
                <td>R = <em>sourceRed</em><br>G = <em>sourceGreen</em><br>B = <em>sourceBlue</em><br>A = 255 (1.0)<br></td>
                <td>L = <em>sourceRed</em></td>
                <td>L = <em>sourceRed</em><br>A = 255 (1.0)</td>
              </tr>
              <tr>
                <td>Color + Alpha (4 channels)</td>
                <td>A = <em>sourceAlpha</em></td>
                <td>R = <em>sourceRed</em><br>G = <em>sourceGreen</em><br>B = <em>sourceBlue</em></td>
                <td>R = <em>sourceRed</em><br>G = <em>sourceGreen</em><br>B = <em>sourceBlue</em><br>A = <em>sourceAlpha</em></td>
                <td>L = <em>sourceRed</em></td>
                <td>L = <em>sourceRed</em><br>A = <em>sourceAlpha</em></td>
              </tr>
            </table><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function when it is called
            with any argument type other than <code>ImageBitmap</code>. <br><br>

            The first pixel transferred from the source to the WebGL implementation corresponds
            to the upper left corner of the source. This behavior is modified by the
            <code>UNPACK_FLIP_Y_WEBGL</code> <a href="#PIXEL_STORAGE_PARAMETERS">pixel storage
            parameter</a>, except for <code>ImageBitmap</code> arguments, as described in the
            abovementioned section. <br><br>

            If the source is an <code>HTMLImageElement</code> or <code>ImageBitmap</code> containing
            an RGB or RGBA lossless image with 8 bits per channel, the browser guarantees that the
            full precision of all channels is preserved. <br><br>

            If the original <code>HTMLImageElement</code> contains an alpha channel and the
            <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter is false, then the
            RGB values are guaranteed to never have been premultiplied by the alpha channel, whether
            those values are derived directly from the original file format or converted from some
            other color format. <br><br>

            <div class="note">

            Some implementations of HTMLCanvasElement's or OffscreenCanvas's
            CanvasRenderingContext2D store color values internally in premultiplied form. If such a
            canvas is uploaded to a WebGL texture with the
            <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter set to false, the
            color channels will have to be un-multiplied by the alpha channel, which is a lossy
            operation. The WebGL implementation therefore can not guarantee that colors with alpha
            &lt; 1.0 will be preserved losslessly when first drawn to a canvas via
            CanvasRenderingContext2D and then uploaded to a WebGL texture when
            the <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter is set to false.

            </div>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If this function is called with an <code>ImageData</code> whose <code>data</code>
            attribute has been neutered, an <code>INVALID_VALUE</code> error is generated. <br><br>

            If this function is called with an <code>ImageBitmap</code> that has been neutered,
            an <code>INVALID_VALUE</code> error is generated. <br><br>

            If this function is called with an <code>HTMLImageElement</code>
            or <code>HTMLVideoElement</code> whose origin differs from the origin of the containing
            Document, or with an <code>HTMLCanvasElement</code>, <code>ImageBitmap</code>
            or <code>OffscreenCanvas</code> whose bitmap's <i>origin-clean</i> flag is set to false,
            a <code>SECURITY_ERR</code> exception must be
            thrown. See <a href="#ORIGIN_RESTRICTIONS">Origin Restrictions</a>.<br><br>

            If <code>source</code> is null then an <code>INVALID_VALUE</code> error is
            generated. <br><br>
        <dt class="idl-code">void texParameterf(GLenum target, GLenum pname, GLfloat param)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.4">OpenGL ES 2.0 &sect;3.7.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexParameter.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        <dt class="idl-code">void texParameteri(GLenum target, GLenum pname, GLint param)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.4">OpenGL ES 2.0 &sect;3.7.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexParameter.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        <dt class="idl-code"><a name="TEXSUBIMAGE2D">void texSubImage2D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                       GLsizei width, GLsizei height,
                       GLenum format, GLenum type, [AllowShared] ArrayBufferView? pixels)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexSubImage2D.xml">man page</a>)</span>
        <dd>
            See <a href="#TEXIMAGE2D">texImage2D</a> for restrictions on the <em>format</em>
            and <em>pixels</em> arguments. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If <em>type</em> does not match the type originally used to define the texture, an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If <code>pixels</code> is null then an <code>INVALID_VALUE</code> error is
            generated. <br><br>

            If <code>pixels</code> is non-null but its size is less than what is required by the specified <em>width</em>, <em>height</em>, <em>format</em>, <em>type</em>, and pixel storage parameters, generates an <code>INVALID_OPERATION</code> error. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
        <dt><p class="idl-code"><a name="TEXSUBIMAGE2D_HTML">void texSubImage2D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                       GLenum format, GLenum type, TexImageSource source) /* May throw DOMException */
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexSubImage2D.xml">man page</a>)</span></p>
        <dd>
            Updates a sub-rectangle of the currently bound WebGLTexture with the contents of the
            given element or image data. <br><br>

            The width and height of the updated sub-rectangle are determined as specified in section
            <a href="#TEXTURE_UPLOAD_SIZE">Texture Upload Width and Height</a>.<br><br>

            See <a href="#TEXIMAGE2D_HTML">texImage2D</a> for the interpretation of
            the <em>format</em> and <em>type</em> arguments, and notes on
            the <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function when it is called
            with any argument type other than <code>ImageBitmap</code>. <br><br>

            The first pixel transferred from the source to the WebGL implementation corresponds
            to the upper left corner of the source. This behavior is modified by the
            <code>UNPACK_FLIP_Y_WEBGL</code> <a href="#PIXEL_STORAGE_PARAMETERS">pixel storage
            parameter</a>, except for <code>ImageBitmap</code> arguments, as described in the
            abovementioned section. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If <em>type</em> does not match the type originally used to define the texture, an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If this function is called with an <code>ImageData</code> whose <code>data</code>
            attribute has been neutered, an <code>INVALID_VALUE</code> error is generated. <br><br>

            If this function is called with an <code>ImageBitmap</code> that has been neutered,
            an <code>INVALID_VALUE</code> error is generated. <br><br>

            If this function is called with an <code>HTMLImageElement</code>
            or <code>HTMLVideoElement</code> whose origin differs from the origin of the containing
            Document, or with an <code>HTMLCanvasElement</code>, <code>ImageBitmap</code>,
            or <code>OffscreenCanvas</code> whose bitmap's <i>origin-clean</i> flag is set to false,
            a <code>SECURITY_ERR</code> exception must be thrown. See
            <a href="#ORIGIN_RESTRICTIONS">Origin Restrictions</a>.<br><br>

            If <code>source</code> is null then an <code>INVALID_VALUE</code> error is
            generated. <br><br>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Programs and Shaders</h4>

    <p>
        Rendering with OpenGL ES 2.0 requires the use of <i>shaders</i>, written in OpenGL ES's shading language, GLSL ES.
        Shaders must be loaded with a source string (shaderSource), compiled
        (compileShader) and attached to a <i>program</i> (attachShader) which must be linked
        (linkProgram) and then used (useProgram).
    </p>

    <dl class="methods">
        <dt class="idl-code">void attachShader(WebGLProgram program, WebGLShader shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glAttachShader.xml">man page</a>)</span>
        <dd>
            If either <code>program</code> or <code>shader</code> were generated by a different
            <code>WebGLRenderingContext</code> than this one, generates
            an <code>INVALID_OPERATION</code> error.
        <dt class="idl-code">void bindAttribLocation(WebGLProgram program, GLuint index, DOMString name)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindAttribLocation.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            If the passed name is longer than the restriction defined
            in <a href="#MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a>,
            generates an <code>INVALID_VALUE</code> error. <br><br>

            If <code>name</code> starts with one of the reserved WebGL prefixes
            per <a href="#GLSL_CONSTRUCTS">GLSL Constructs</a>, generates
            an <code>INVALID_OPERATION</code> error. <br><br>

            See <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source Character
            Set</a> for additional validation performed by WebGL implementations.
        <dt class="idl-code">void compileShader(WebGLShader shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompileShader.xml">man page</a>)</span>
        <dd>
            If <code>shader</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            See <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL
            Constructs</a>, <a href="#MAX_GLSL_TOKEN_SIZE">Maximum GLSL Token
            Size</a>, <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source
            Character Set</a>, <a href="#MAX_STRUCT_NESTING">Maximum Nesting of Structures in GLSL
            Shaders</a>, and <a href="#PACKING_RESTRICTIONS">Packing Restrictions for Uniforms and
            Varyings</a> for additional constraints enforced in, additional constructs supported by,
            and additional validation performed by WebGL implementations.
        <dt class="idl-code">WebGLProgram? createProgram()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateProgram.xml">man page</a>)</span>
        <dd>
            Create a WebGLProgram object and initialize it with a program object name as if by
            calling glCreateProgram.

        <dt class="idl-code">WebGLShader? createShader(GLenum type)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateShader.xml">man page</a>)</span>
        <dd>
            Create a WebGLShader object and initialize it with a shader object name as if by
            calling glCreateShader.

        <dt class="idl-code">void deleteProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteProgram.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Mark for deletion the program object contained in the passed WebGLProgram, as if by
            calling glDeleteProgram.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">void deleteShader(WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteShader.xml">man page</a>)</span>
        <dd>
            If <code>shader</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Mark for deletion the shader object contained in the passed WebGLShader, as if by
            calling glDeleteShader.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">void detachShader(WebGLProgram program, WebGLShader shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDetachShader.xml">man page</a>)</span>
        <dd>
            If either <code>program</code> or <code>shader</code> were generated by a different
            <code>WebGLRenderingContext</code> than this one, generates
            an <code>INVALID_OPERATION</code> error.
        <dt class="idl-code">sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetAttachedShaders.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            <p>Returns a new object representing the list of shaders attached to the passed program.</p>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">any getProgramParameter(WebGLProgram program, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetProgramiv.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Return the value for the passed pname given the passed program. The type returned is the natural
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>DELETE_STATUS</td><td>GLboolean</td></tr>
                <tr><td>LINK_STATUS</td><td>GLboolean</td></tr>
                <tr><td>VALIDATE_STATUS</td><td>GLboolean</td></tr>
                <tr><td>ATTACHED_SHADERS</td><td>GLint</td></tr>
                <tr><td>ACTIVE_ATTRIBUTES</td><td>GLint</td></tr>
                <tr><td>ACTIVE_UNIFORMS</td><td>GLint</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">DOMString? getProgramInfoLog(WebGLProgram program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetProgramInfoLog.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">any getShaderParameter(WebGLShader shader, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderiv.xml">man page</a>)</span>
        <dd>
            If <code>shader</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Return the value for the passed pname given the passed shader. The type returned is the natural
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>SHADER_TYPE</td><td>GLenum</td></tr>
                <tr><td>DELETE_STATUS</td><td>GLboolean</td></tr>
                <tr><td>COMPILE_STATUS</td><td>GLboolean</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">WebGLShaderPrecisionFormat? getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetShaderPrecisionFormat.xml">man page</a>)</span>
        <dd>
            <p>Return a new <code>WebGLShaderPrecisionFormat</code> describing the range and precision
            for the specified shader numeric format. The shadertype value can be FRAGMENT_SHADER or
            VERTEX_SHADER. The precisiontype value can be LOW_FLOAT, MEDIUM_FLOAT, HIGH_FLOAT,
            LOW_INT, MEDIUM_INT or HIGH_INT.</p>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">DOMString? getShaderInfoLog(WebGLShader shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderInfoLog.xml">man page</a>)</span>
        <dd>
            If <code>shader</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">DOMString? getShaderSource(WebGLShader shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderSource.xml">man page</a>)</span>
        <dd>
            If <code>shader</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsProgram.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLProgram is valid and false otherwise. <br><br>

            Returns false if the program was generated by a
            different <code>WebGLRenderingContext</code> than this one. <br><br>
            Returns false if the program's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isShader(WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsShader.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLShader is valid and false otherwise. <br><br>

            Returns false if the shader was generated by a
            different <code>WebGLRenderingContext</code> than this one. <br><br>

            Returns false if the shader's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code">void linkProgram(WebGLProgram program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glLinkProgram.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Links the passed program object. Details of the behavior are defined in the OpenGL ES
            2.0 specification, with the following clarifications: linkProgram is the only API in
            this group which affects the passed program's link status, and the internal executable
            code it references. Operations like attaching and detaching shader objects from a
            program, modifying shader objects which are attached to a program, or compiling shader
            objects attached to a program affect neither that program's link status, nor the
            executable code that program may reference. <br><br>

            If the given program is linked successfully and is also the current program object in
            use as defined by <code>useProgram</code>, below, then the generated executable code
            will be immediately installed as part of the current rendering state. Otherwise any
            executable code referenced by the current rendering state is unmodified by a call to
            linkProgram. <br><br>

            See <a href="#PACKING_RESTRICTIONS">Packing Restrictions for Uniforms and Varyings</a>
            for additional constraints enforced in, and additional validation performed by, WebGL
            implementations.
        <dt class="idl-code">void shaderSource(WebGLShader shader, DOMString source)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glShaderSource.xml">man page</a>)</span>
        <dd>
            If <code>shader</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            See <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL
            Constructs</a>, <a href="#MAX_GLSL_TOKEN_SIZE">Maximum GLSL Token
            Size</a>, <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source
            Character Set</a>, <a href="#MAX_STRUCT_NESTING">Maximum Nesting of Structures in GLSL
            Shaders</a>, and <a href="#PACKING_RESTRICTIONS">Packing Restrictions for Uniforms and
            Varyings</a> for additional constraints enforced in, additional constructs supported by,
            and additional validation performed by WebGL implementations.
        <dt class="idl-code">void useProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUseProgram.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>
        <dt class="idl-code">void validateProgram(WebGLProgram program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.5">OpenGL ES 2.0 &sect;2.10.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glValidateProgram.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Uniforms and attributes</h4>

    <p>
        Values used by the shaders are passed in as uniforms or vertex attributes.
    </p>

    <dl class="methods">
        <dt class="idl-code">void disableVertexAttribArray(GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDisableVertexAttribArray.xml">man page</a>)</span>
        <dt class="idl-code">void enableVertexAttribArray(GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glEnableVertexAttribArray.xml">man page</a>)</span>
        <dd>
            Enable the vertex attribute at <code>index</code> as an array. WebGL imposes additional
            rules beyond OpenGL ES 2.0 regarding enabled vertex attributes;
            see <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range
            Checking</a>.
        <dt class="idl-code">WebGLActiveInfo? getActiveAttrib(WebGLProgram program, GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetActiveAttrib.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Returns a new <code>WebGLActiveInfo</code> object describing the size, type and name of
            the vertex attribute at the passed index of the passed program object. If the passed
            index is out of range, generates an <code>INVALID_VALUE</code> error and returns null.
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">WebGLActiveInfo? getActiveUniform(WebGLProgram program, GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetActiveUniform.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            Returns a new <code>WebGLActiveInfo</code> object describing the size, type and name of
            the uniform at the passed index of the passed program object. If the passed index is out
            of range, generates an <code>INVALID_VALUE</code> error and returns null.
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLint getAttribLocation(WebGLProgram program, DOMString name)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetAttribLocation.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error and returns -1. <br><br>

            If the passed name is longer than the restriction defined
            in <a href="#MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a>,
            generates an <code>INVALID_VALUE</code> error and returns -1. <br><br>

            Returns -1 if <code>name</code> starts with one of the reserved WebGL prefixes
            per <a href="#GLSL_CONSTRUCTS">GLSL Constructs</a>. <br><br>

            Returns -1 if the context's <a href="#webgl-context-lost-flag">webgl context lost
            flag</a> is set. <br><br>

            If the <a href="#webgl-object-invalidated-flag">invalidated flag</a> of the passed
            program is set, generates an <code>INVALID_OPERATION</code> error and returns
            -1. <br><br>

            See <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source Character
            Set</a> for additional validation performed by WebGL implementations.
        <dt class="idl-code">any getUniform(WebGLProgram program, WebGLUniformLocation location)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetUniform.xml">man page</a>)</span>
        <dd>
            If either <code>program</code> or <code>location</code> were generated by a
            different <code>WebGLRenderingContext</code> than this one, generates
            an <code>INVALID_OPERATION</code> error. <br><br>

            Return the uniform value at the passed location in the passed program. The type returned is
            dependent on the uniform type, as shown in the following table:
            <table class="foo">
                <tr><th>uniform type</th><th>returned type</th></tr>
                <tr><td>boolean</td><td>GLboolean</td></tr>
                <tr><td>int</td><td>GLint</td></tr>
                <tr><td>float</td><td>GLfloat</td></tr>
                <tr><td>vec2</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ivec2</td><td>Int32Array (with 2 elements)</td></tr>
                <tr><td>bvec2</td><td>sequence&lt;GLboolean&gt; (with 2 elements)</td></tr>
                <tr><td>vec3</td><td>Float32Array (with 3 elements)</td></tr>
                <tr><td>ivec3</td><td>Int32Array (with 3 elements)</td></tr>
                <tr><td>bvec3</td><td>sequence&lt;GLboolean&gt; (with 3 elements)</td></tr>
                <tr><td>vec4</td><td>Float32Array (with 4 elements)</td></tr>
                <tr><td>ivec4</td><td>Int32Array (with 4 elements)</td></tr>
                <tr><td>bvec4</td><td>sequence&lt;GLboolean&gt; (with 4 elements)</td></tr>
                <tr><td>mat2</td><td>Float32Array (with 4 elements)</td></tr>
                <tr><td>mat3</td><td>Float32Array (with 9 elements)</td></tr>
                <tr><td>mat4</td><td>Float32Array (with 16 elements)</td></tr>
                <tr><td>sampler2D</td><td>GLint</td></tr>
                <tr><td>samplerCube</td><td>GLint</td></tr>
            </table>
            <p>All queries returning sequences or typed arrays return a new object each time.</p>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">WebGLUniformLocation? getUniformLocation(WebGLProgram program, DOMString name)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetUniformLocation.xml">man page</a>)</span>
        <dd>
            If <code>program</code> was generated by a different <code>WebGLRenderingContext</code>
            than this one, generates an <code>INVALID_OPERATION</code> error. <br><br>

            <p>Return a new <code>WebGLUniformLocation</code> that represents the location of a
            specific uniform variable within a program object. The return value is null if name does
            not correspond to an active uniform variable in the passed program.</p>

            <p>If the passed name is longer than the restriction defined
            in <a href="#MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a>,
            generates an <code>INVALID_VALUE</code> error and returns null.</p>

            <p>Returns null if <code>name</code> starts with one of the reserved WebGL prefixes
            per <a href="#GLSL_CONSTRUCTS">GLSL Constructs</a>.</p>

            <p>See <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source
            Character Set</a> for additional validation performed by WebGL implementations.</p>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">any getVertexAttrib(GLuint index, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetVertexAttrib.xml">man page</a>)</span>
        <dd>
            Return the information requested in pname about the vertex attribute at the passed index. The
            type returned is dependent on the information requested, as shown in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_ENABLED</td><td>GLboolean</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_SIZE</td><td>GLint</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_STRIDE</td><td>GLint</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_TYPE</td><td>GLenum</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_NORMALIZED</td><td>GLboolean</td></tr>
                <tr><td>CURRENT_VERTEX_ATTRIB</td><td>Float32Array (with 4 elements)</td></tr>
            </table>
            <p>All queries returning sequences or typed arrays return a new object each time.</p>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetVertexAttribPointerv.xml">man page</a>)</span>
        <dd>
            Returns 0 if the context's <a href="#webgl-context-lost-flag">webgl context lost
            flag</a> is set.
        <dt><p class="idl-code">void uniform[1234][fi](WebGLUniformLocation? location, ...)</p>
            <p class="idl-code">void uniform[1234][fi]v(WebGLUniformLocation? location, ...)
            <p class="idl-code">void uniformMatrix[234]fv(WebGLUniformLocation? location, GLboolean transpose, ...)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUniform.xml">man page</a>)</span></p>
       <dd>
            Each of the uniform* functions above sets the specified uniform or uniforms to the
            values provided. If the passed <code>location</code> is not null and was not obtained
            from the currently used program via an earlier call to <code>getUniformLocation</code>,
            an <code>INVALID_OPERATION</code> error will be generated. If the passed
            <code>location</code> is null, the data passed in will be silently ignored and
            no uniform variables will be changed.
            <br><br>
            If the array passed to any of the vector forms (those ending in <code>v</code>) has an
            invalid length, an <code>INVALID_VALUE</code> error will be generated. The length is
            invalid if it is too short for or is not an integer multiple of the assigned type.

            <div class="note">Performance problems have been observed on some implementations when
            using <code>uniform1i</code> to update sampler uniforms. To change the texture
            referenced by a sampler uniform, binding a new texture to the texture unit referenced
            by the uniform should be preferred over using <code>uniform1i</code> to update the
            uniform itself.</div>
        <dt><p class="idl-code">void vertexAttrib[1234]f(GLuint index, ...)</p>
            <p class="idl-code">void vertexAttrib[1234]fv(GLuint index, ...)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.7">OpenGL ES 2.0 &sect;2.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glVertexAttrib.xml">man page</a>)</span></p>
       <dd>
           Sets the vertex attribute at the passed index to the given constant value. Values set via the
           <code>vertexAttrib</code> are guaranteed to be returned from the <code>getVertexAttrib</code> function
           with the <code>CURRENT_VERTEX_ATTRIB</code> param, even if there have been intervening calls to
           <code>drawArrays</code> or <code>drawElements</code>.
           <br><br>
           If the array passed to any of the vector forms (those ending in <code>v</code>) is too
           short, an <code>INVALID_VALUE</code> error will be generated.

       <dt class="idl-code">void vertexAttribPointer(GLuint index, GLint size, GLenum type,
                            GLboolean normalized, GLsizei stride, GLintptr offset)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glVertexAttribPointer.xml">man page</a>)</span>
        <dd>
            Assign the WebGLBuffer object currently bound to the ARRAY_BUFFER target to the vertex
            attribute at the passed index. Size is number of components per attribute. Stride and
            offset are in units of bytes. Passed stride and offset must be appropriate for the
            passed type and size or an <code>INVALID_OPERATION</code> error will be generated;
            see <a href="#BUFFER_OFFSET_AND_STRIDE">Buffer Offset and Stride Requirements</a>. If
            offset is negative, an <code>INVALID_VALUE</code> error will be generated. If no
            WebGLBuffer is bound to the ARRAY_BUFFER target and <code>offset</code> is non-zero,
            an <code>INVALID_OPERATION</code> error will be generated. In WebGL, the maximum
            supported stride is 255; see <a href="#VERTEX_STRIDE"> Vertex Attribute Data Stride</a>.
    </dl>

<!-- ======================================================================================================= -->

    <h4><a name="WRITING_TO_THE_DRAWING_BUFFER">Writing to the drawing buffer</a></h4>

    <p>
        OpenGL ES 2.0 has 3 calls which can render to the drawing buffer: <code>clear</code>,
        <code>drawArrays</code> and <code>drawElements</code>. Furthermore rendering can
        be directed to the drawing buffer or to a Framebuffer object. When rendering is
        directed to the drawing buffer, making any of the 3 rendering calls shall
        cause the drawing buffer to be presented to the HTML page compositor at the start
        of the next compositing operation.
    </p>

    <p>
        If any one of these 3 calls attempts to draw to a missing attachment of a complete framebuffer,
        nothing is drawn to that attachment and no error is generated
        per <a href="../1.0/index.html#DRAWING_TO_MISSING_ATTACHMENT">Drawing to a Missing Attachment</a>.
    </p>

    <dl class="methods">
        <dt class="idl-code">void clear(GLbitfield mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClear.xml">man page</a>)</span>
        <dt class="idl-code">void drawArrays(GLenum mode, GLint first, GLsizei count)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDrawArrays.xml">man page</a>)</span>
            <dd>
            If <em>first</em> is negative, an <code>INVALID_VALUE</code> error will be generated.
            If the CURRENT_PROGRAM is null, an <code>INVALID_OPERATION</code> error will be generated.
        <dt class="idl-code">void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDrawElements.xml">man page</a>)</span>
        <dd>
            Draw using the currently bound element array buffer.  The given offset is in bytes, and
            must be a valid multiple of the size of the given type or an <code>INVALID_OPERATION</code>
            error will be generated; in addition the offset must be non-negative or an
            <code>INVALID_VALUE</code> error will be generated; see <a href="#BUFFER_OFFSET_AND_STRIDE">
            Buffer Offset and Stride Requirements</a>. If <code>count</code> is greater than zero,
            then a non-null <code>WebGLBuffer</code> must be bound to the <code>ELEMENT_ARRAY_BUFFER</code>
            binding point or an <code>INVALID_OPERATION</code> error will be generated.<br><br>
            If the CURRENT_PROGRAM is null, an <code>INVALID_OPERATION</code> error will be generated.

            WebGL performs additional error checking beyond that specified in OpenGL ES 2.0 during
            calls to <code>drawArrays</code>
            and <code>drawElements</code>. See <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex
            Attributes and Range Checking</a>.
        <dt class="idl-code">void finish()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.1">OpenGL ES 2.0 &sect;5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFinish.xml">man page</a>)</span>
        <dt class="idl-code">void flush()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.1">OpenGL ES 2.0 &sect;5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFlush.xml">man page</a>)</span>
    </dl>

<!-- ======================================================================================================= -->

    <h4><a name="readpixels">Reading back pixels</a></h4>

    <p>
        Pixels in the current framebuffer can be read back into an ArrayBufferView object.
    </p>

    <dl class="methods">
        <dt class="idl-code">void readPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                           GLenum format, GLenum type, [AllowShared] ArrayBufferView? pixels)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.3.1">OpenGL ES 2.0 &sect;4.3.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glReadPixels.xml">man page</a>)</span>
        <dd>
            Fills <code>pixels</code> with the pixel data in the specified rectangle of the frame
            buffer. The data returned from readPixels must be up-to-date as of the most recently
            sent drawing command.
            <br><br>

            The type of <code>pixels</code> must match the type of the data to be read. For example,
            if it is UNSIGNED_BYTE, a Uint8Array or Uint8ClampedArray must be supplied; if it is
            UNSIGNED_SHORT_5_6_5, UNSIGNED_SHORT_4_4_4_4, or UNSIGNED_SHORT_5_5_5_1, a Uint16Array
            must be supplied; if it is FLOAT, a Float32Array must be supplied. If the types do not
            match, an INVALID_OPERATION error is generated.
            <br><br>

            Only two combinations of <code>format</code> and <code>type</code> are accepted. The
            first is <code>format</code> RGBA and <code>type</code> UNSIGNED_BYTE. The second is an
            implementation-chosen format. The values of <code>format</code> and <code>type</code>
            for this format may be determined by calling
            <a href="#GETPARAMETER"><code>getParameter</code></a> with the symbolic constants
            IMPLEMENTATION_COLOR_READ_FORMAT and IMPLEMENTATION_COLOR_READ_TYPE, respectively. The
            implementation-chosen format may vary depending on the format of the currently bound
            rendering surface. Unsupported combinations of <code>format</code> and <code>type</code>
            will generate an INVALID_OPERATION error.
            <br><br>

            Because queries of IMPLEMENTATION_COLOR_READ_[FORMAT,TYPE] may return enums not used
            elsewhere, providing these enums to <code>readPixels</code> will not necessarily
            generate INVALID_ENUM.
            <br><br>

            If <code>pixels</code> is null, an INVALID_VALUE error is generated. If
            <code>pixels</code> is non-null, but is not large enough to retrieve all of the pixels
            in the specified rectangle taking into account pixel store modes, an INVALID_OPERATION
            error is generated.
            <br><br>

            For any pixel lying outside the frame buffer, the corresponding destination buffer range
            remains untouched; see <a href="#READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the
            Framebuffer</a>.
            <br><br>

            If this function attempts to read from a complete framebuffer with a missing color
            attachment, an <code>INVALID_OPERATION</code> error is generated
            per <a href="#READING_FROM_MISSING_ATTACHMENT">Reading from a Missing Attachment</a>.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Detecting context lost events</h4>

    <p>
        Occurrences such as power events on mobile devices may cause the WebGL rendering context to
        be lost at any time and require the application to rebuild it;
        see <a href="#WEBGLCONTEXTEVENT">WebGLContextEvent</a> for more details. The
        following method assists in detecting context lost events.
    </p>

    <dl class="methods">
        <dt class="idl-code">[WebGLHandlesContextLoss] boolean isContextLost()
        <dd>
            Return true if the <a href="#webgl-context-lost-flag">webgl context lost flag</a> is
            set, otherwise return false.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Detecting and enabling extensions</h4>

    <p>
        An implementation of WebGL must not support any additional parameters, constants or functions
        without first enabling that functionality through the extension mechanism. The
        <code>getSupportedExtensions</code> function returns an array of the extension strings
        supported by this implementation. An extension is enabled by passing one of those strings to
        the <code>getExtension</code> function. This call returns an object which contains any
        constants or functions defined by that extension. The definition of that object is specific
        to the extension and must be defined by the extension specification.
    </p>
    <p>
        Once an extension is enabled, it is only disabled if the WebGL rendering context is lost (see
        below), with the exception of the "WEBGL_lose_context" extension which remains active through
        any loss of context. Any objects referenced by a disabled extension, such as the object returned
        by <code>getExtension</code>, are no longer associated with the WebGL rendering context. Any
        extension objects that derive from <code>WebGLObject</code> have their
        <a href="#webgl-object-invalidated-flag">invalidated</a> flag set to true. Behavior of
        extensions' methods after context loss is defined by the steps in the
        section <a href="#WEBGLRENDERINGCONTEXT">"The WebGL context"</a>.
    <p>
        There are no other mechanisms to disable an extension.
    </p>
    <p>
        Multiple calls to <code>getExtension</code> with the same extension string, taking into account
        case-insensitive comparison, must return the same object as long as the extension is enabled. An
        attempt to use any features of an extension without first calling getExtension to enable it must
        generate an appropriate GL error and must not make use of the feature.
    </p>
    <p>
        This specification does not define any extensions. A separate <a href="#refsREGISTRY">WebGL
        extension registry</a> defines extensions that may be supported by a particular WebGL
        implementation.
    </p>

    <dl class="methods">
        <dt class="idl-code">sequence&lt;DOMString&gt;? getSupportedExtensions()
        <dd>
            Returns a list of all the supported extension strings.

        <dt class="idl-code">object? getExtension(DOMString name)
        <dd>
            Returns an object if, and only if, <em>name</em> is
            an <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#ascii-case-insensitive">ASCII
            case-insensitive match</a> <a href="#refsHTML">[HTML]</a> for one of the names returned
            from <code>getSupportedExtensions</code>; otherwise, returns <code>null</code>. The
            object returned from <code>getExtension</code> contains any constants or functions
            provided by the extension. A returned object may have no constants or functions if the
            extension does not define any, but a unique object must still be returned. That object
            is used to indicate that the extension has been enabled.
    </dl>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLCONTEXTEVENT">WebGLContextEvent</a></h3>

    <p>
        WebGL generates a <code>WebGLContextEvent</code> event in response to important changes in status of a
        WebGL rendering context. Events are sent using the DOM Event System <a href="#refsDOM3EVENTS">[DOM3EVENTS]</a>,
        and are dispatched to the HTMLCanvasElement or OffscreenCanvas associated with the WebGL rendering context.
        The types of status changes that can trigger a <code>WebGLContextEvent</code> event are <a href="#CONTEXT_LOST">
        the loss of the context</a>, <a href="#CONTEXT_RESTORED">the restoration of the context</a>, and
        <a href="#CONTEXT_CREATION_ERROR"> the inability to create a context</a>.
    </p>
    <p>
        To <b><a name="fire-a-webgl-context-event">fire a WebGL context event named e</a></b> means
        that an <a href="http://www.w3.org/TR/domcore/#concept-event">event</a> using
        the <code>WebGLContextEvent</code> interface, with
        its <a href="http://www.w3.org/TR/domcore/#dom-event-type"><code>type</code></a>
        attribute <a href="#refsDOM4">[DOM4]</a> initialized to <em>e</em>, its
        <code>cancelable</code> attribute initialized to true, and
        its <a href="http://www.w3.org/TR/domcore/#dom-event-istrusted"><code>isTrusted</code></a>
        attribute <a href="#refsDOM4">[DOM4]</a> initialized to true, is to
        be <a href="http://www.w3.org/TR/domcore/#concept-event-dispatch">dispatched</a> at the
        given object.
    </p>
    <pre class="idl">
[Exposed=(Window,Worker),
 Constructor(DOMString type,
 optional WebGLContextEventInit eventInit = {})]
interface <dfn id="WebGLContextLostEvent">WebGLContextEvent</dfn> : <a href="http://www.w3.org/TR/domcore/#event">Event</a> {
    readonly attribute DOMString statusMessage;
};

// EventInit is defined in the DOM4 specification.
dictionary WebGLContextEventInit : <a href="http://www.w3.org/TR/domcore/#eventinit">EventInit</a> {
    DOMString statusMessage = "";
};</pre>

    <p>
    The <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#task-source">task
    source</a> for
    all <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#concept-task">tasks</a> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#queue-a-task">queued</a> <a href="#refsHTML">[HTML]</a>
    in this section is the <b>WebGL task source</b>.
    </p>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt><span class="prop-name"><code>statusMessage</code></span> of type <code>DOMString</code>
        <dd>
            A string containing additional information, or the empty string if no additional information
            is available.
    </dl>

    <h4><a name="CONTEXT_LOST">The Context Lost Event</a></h4>

    <p>
        When the user agent detects that the <em>drawing buffer</em> associated with
        a <code>WebGLRenderingContext</code> <em>context</em> has been lost, it must run the
        following steps:

        <ol class="nestedlist">

        <li> Let <em>canvas</em> be the <em>context's</em>
        <a href="#context-canvas">canvas</a>. </li>

        <li> If </em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost</a> flag
        is set, abort these steps. </li>

        <li> Set <em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost</a>
        flag. </li>

        <li> Set the <a href="#webgl-object-invalidated-flag">invalidated flag</a> of
        each <code>WebGLObject</code> instance created by this context. </li>

        <li> Disable all extensions except "WEBGL_lose_context". </li>

        <li> <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to
        perform the following steps:

            <ol class="nestedlist">

            <li> <a href="#fire-a-webgl-context-event">Fire a WebGL context event</a> named
            "webglcontextlost" at <em>canvas</em>, with its <code>statusMessage</code> attribute set
            to "". </li>

            <li> If the
            event's <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#canceled-flag">canceled
            flag</a> is not set, abort these steps. </li>

            <li> Perform the following steps asynchronously. </li>

            <li> Await a restorable <em>drawing buffer</em>. </li>

            <li> Queue a task to <a href="#restore-the-drawing-buffer">restore the drawing
            buffer</a> for <em>context</em>. </li>

            </ol>

        </li>
        </ol>
    </p>
    <div class="example">
        The following code prevents the default behavior of the <code>webglcontextlost</code>
        event and enables the <code>webglcontextrestored</code> event to be delivered:
    <pre>canvas.addEventListener("webglcontextlost", function(e) { e.preventDefault(); }, false); </pre>
    </div>

    <h4><a name="CONTEXT_RESTORED">The Context Restored Event</a></h4>

    <p>

        When the user agent is to <b><a name="restore-the-drawing-buffer">restore the drawing
        buffer</a></b> for a <code>WebGLRenderingContext</code> <em>context</em>, it must run the
        following steps:

        <ol class="nestedlist">

        <li> Let <em>canvas</em> be the canvas object associated with <em>context</em>.

        <li> If <em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost flag</a> is
        not set, abort these steps.

        <li> <a href="#create-a-drawing-buffer">Create a <em>drawing buffer</em></a> using the
        settings specified in <em>context's</em> <a href="#context-creation-parameters">context
        creation parameters</a>, and associate the <em>drawing buffer</em> with <em>context</em>,
        discarding any previous <em>drawing buffer</em>.

        <li> Clear <em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost
        flag</a>.

        <li> Reset <em>context's</em> OpenGL error state.

        <li> <a href="#fire-a-webgl-context-event">Fire a WebGL context event</a> named
        "webglcontextrestored" at <em>canvas</em>, with its <code>statusMessage</code> attribute set
        to "".

        </ol>

    </p>

    <div class="note">
        Once the context is restored, WebGL resources such as textures and buffers that were created
        before the context was lost are no longer valid.
        Previously enabled extensions are not restored.
        The application will want to restore all modified state and destroyed extensions and resources.
    </div>

    <div class="example">
        The following code illustrates how an application can handle context loss and restoration:
<pre>function initializeGame() {
  initializeWorld();
  initializeResources();
}

function initializeResources() {
  initializeShaders();
  initializeBuffers();
  initializeTextures();

  // ready to draw, start the main loop
  renderFrame();
}

function renderFrame() {
  updateWorld();
  drawSkyBox();
  drawWalls();
  drawMonsters();

  requestId = window.requestAnimationFrame(
      renderFrame, canvas);
}

canvas.addEventListener(
    "webglcontextlost", function (event) {

  // inform WebGL that we handle context restoration
  event.preventDefault();

  // Stop rendering
  window.cancelAnimationFrame(requestId);
}, false);

canvas.addEventListener(
    "webglcontextrestored", function (event) {

  initializeResources();
}, false);

initializeGame();</pre>
    </div>

    <h4><a name="CONTEXT_CREATION_ERROR">The Context Creation Error Event</a></h4>

    <p>
        When the user agent is to <b><a name="fire-a-webgl-context-creation-error">fire a WebGL
        context creation error</a></b> at a <em>canvas</em>, it must perform the following steps:

        <ol class="nestedlist">

        <li> <a href="#fire-a-webgl-context-event">Fire a WebGL context event</a> named
        "webglcontextcreationerror" at <em>canvas</em>, optionally with its <code>statusMessage</code>
        attribute set to a platform dependent string about the nature of the failure. </li>

        </ol>

    </p>

    <div class="example">

        The following code illustrates how an application can retrieve information about context creation failure:

<pre>var errorInfo = "";
function onContextCreationError(event) {

  canvas.removeEventListener(
     "webglcontextcreationerror",
     onContextCreationError, false);

  errorInfo = e.statusMessage || "Unknown";
}

canvas.addEventListener(
    "webglcontextcreationerror",
    onContextCreationError, false);

var gl = canvas.getContext("webgl");
if(!gl) {
  alert("A WebGL context could not be created.\nReason: " +
        errorInfo);
}</pre>
    </div>

<!-- ======================================================================================================= -->

    <h2><a name="webgl_gl_differences">Differences Between WebGL and OpenGL ES 2.0</a></h2>

<p>

This section describes changes made to the WebGL API relative to the OpenGL ES 2.0 API to improve
portability across various operating systems and devices.

</p>

    <h3><a name="BUFFER_OBJECT_BINDING">Buffer Object Binding</a></h3>

<p>

In the WebGL API, a given buffer object may only be bound to one of the <code>ARRAY_BUFFER</code> or
<code>ELEMENT_ARRAY_BUFFER</code> binding points in its lifetime. This restriction implies that a
given buffer object may contain either vertices or indices, but not both.

</p>
<p>

The type of a WebGLBuffer is initialized the first time it is passed as an argument
to <code>bindBuffer</code>. A subsequent call to <code>bindBuffer</code> which attempts to bind the
same WebGLBuffer to the other binding point will generate an <code>INVALID_OPERATION</code> error, and
the state of the binding point will remain untouched.

</p>

    <h3>No Client Side Arrays</h3>

<p>
The WebGL API does not support client-side arrays.

<p>
If a vertex attribute is enabled as an array via <code>enableVertexAttribArray</code> but no buffer
is bound to that attribute (generally via <code>bindBuffer</code> and
<code>vertexAttribPointer</code>), then draw commands (<code>drawArrays</code> or
<code>drawElements</code>) will generate an <code>INVALID_OPERATION</code> error.

<p>
If an indexed draw command (<code>drawElements</code>) is called and no <code>WebGLBuffer</code> is
bound to the <code>ELEMENT_ARRAY_BUFFER</code> binding point, an <code>INVALID_OPERATION</code>
error is generated.

<p>
If <code>vertexAttribPointer</code> is called without a <code>WebGLBuffer</code> bound to the
<code>ARRAY_BUFFER</code> binding point, and <code>offset</code> is non-zero, an
<code>INVALID_OPERATION</code> error is generated.

<div class="note rationale">
    <p>
    Allowing setting VERTEX_ATTRIB_ARRAY_BUFFER_BINDING to null even though client-side arrays
    are never supported allows for clearing the binding to its original state, which isn't
    strictly possible otherwise.
    <p>
    This also matches the behavior in OpenGL ES 3.0.5 <a href="#refsGLES30">[GLES30]</a> p25 for
    non-default VAO objects.
</div>

    <h3>No Default Textures</h3>

<p>

The WebGL API does not support default textures. A non-null <code>WebGLTexture</code> object must be
bound in order for texture-related operations and queries to succeed.

</p>

    <h3>No Shader Binaries</h3>

<p>

Accessing binary representations of compiled shaders is not supported in the WebGL API. This
includes the OpenGL ES 2.0 <code>ShaderBinary</code> entry point. In addition, querying shader
binary formats and the availability of a shader compiler via <code>getParameter</code> is not
supported in the WebGL API.

</p>
<p>

All WebGL implementations must implicitly support an on-line shader compiler.

</p>

    <h3><a name="BUFFER_OFFSET_AND_STRIDE">Buffer Offset and Stride Requirements</a></h3>

<p>

The <code>offset</code> arguments to <code>drawElements</code> and <code>vertexAttribPointer</code>,
and the <code>stride</code> argument to <code>vertexAttribPointer</code>, must be a multiple of the
size of the data type passed to the call, or an <code>INVALID_OPERATION</code> error is generated.

</p>

<div class="note rationale">
    <p>
        This enforces the following requirement from OpenGL ES 2.0.25
        <a href="#refsGLES20">[GLES20]</a> p24:
    </p>
    <p>
        "Clients must align data elements consistent with the requirements of the client
        platform, with an additional base-level requirement that an offset within a buffer
        to a datum comprising <code>N</code> basic machine units be a multiple of
        <code>N</code>."
    </p>
</div>

<p>

In addition the <code>offset</code> argument to <code>drawElements</code> must be non-negative or
an <code>INVALID_VALUE</code> error is generated.

</p>

    <h3><a name="ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range Checking</a></h3>

<p>
It is possible for draw commands to request data outside the bounds of a WebGLBuffer by calling a
drawing command that requires fetching data for an active vertex attribute, when it is enabled as an
array, either directly (<code>drawArrays</code>), or indirectly from an indexed draw
(<code>drawElements</code>).
If this occurs, then one of the following behaviors will result:

<ol>

<li> The WebGL implementation may generate an INVALID_OPERATION error and draw no geometry. </li>

<li> Out-of-range vertex fetches may return any of the following values:

  <ul>
  <li> Values from anywhere within the buffer object. </li>
  <li> Zero values, or (0,0,0,x) vectors for vector reads where x is a
       valid value represented in the type of the vector components and may
       be any of:

       <ul>
         <li>0, 1, or the maximum representable positive integer value, for
         signed or unsigned integer components</li>
         <li>0.0 or 1.0, for floating-point components</li>
       </ul>
       </li>

  </ul>
  </li>

</ol>

</p>
<div class="note">
This behavior replicates that defined in <a href="#refsKHRROBUSTACCESS">[KHRROBUSTACCESS]</a>.
</div>
<p>

If a vertex attribute is enabled as an array, a buffer is bound to that attribute, but the attribute
is not consumed by the current program, then regardless of the size of the bound buffer, it will not
cause any error to be generated during a call to <code>drawArrays</code>
or <code>drawElements</code>.

    <h3>Out-of-bounds fetches from the index buffer</h3>

<p>
Calling an indexed drawing command (<code>drawElements</code>) that fetches index elements outside
the bounds of ELEMENT_ARRAY_BUFFER will result in an INVALID_OPERATION error.

    <h3><a name="FBO_ATTACHMENTS">Framebuffer Object Attachments</a></h3>

<p>

WebGL adds the <code>DEPTH_STENCIL_ATTACHMENT</code> framebuffer object attachment point and
the <code>DEPTH_STENCIL</code> renderbuffer internal format. To attach both depth and stencil
buffers to a framebuffer object, call <code>renderbufferStorage</code> with
the <code>DEPTH_STENCIL</code> internal format, and then call <code>framebufferRenderbuffer</code>
with the <code>DEPTH_STENCIL_ATTACHMENT</code> attachment point.

</p>
<p>

A renderbuffer attached to the <code>DEPTH_ATTACHMENT</code> attachment point must be allocated with
the <code>DEPTH_COMPONENT16</code> internal format. A renderbuffer attached to
the <code>STENCIL_ATTACHMENT</code> attachment point must be allocated with
the <code>STENCIL_INDEX8</code> internal format. A renderbuffer attached to
the <code>DEPTH_STENCIL_ATTACHMENT</code> attachment point must be allocated with
the <code>DEPTH_STENCIL</code> internal format.

</p>
<p>

In the WebGL API, it is an error to concurrently attach renderbuffers to the following combinations
of attachment points:

<ul>
<li> <code>DEPTH_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
<li> <code>STENCIL_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
<li> <code>DEPTH_ATTACHMENT + STENCIL_ATTACHMENT</code>
</ul>

If any of the constraints above are violated, then:

<ul>
<li> <code>checkFramebufferStatus</code> must return <code>FRAMEBUFFER_UNSUPPORTED</code>.
<li> The following calls, which either modify or read the framebuffer, must generate
     an <code>INVALID_FRAMEBUFFER_OPERATION</code> error and return early, leaving the contents of
     the framebuffer, destination texture or destination memory untouched.
  <ul>
  <li> clear
  <li> copyTexImage2D
  <li> copyTexSubImage2D
  <li> drawArrays
  <li> drawElements
  <li> readPixels
  </ul>
</ul>

The following combinations of framebuffer object attachments, when all of the attachments are
framebuffer attachment complete, non-zero, and have the same width and height, must result in the
framebuffer being framebuffer complete:

<ul>
<li> <code>COLOR_ATTACHMENT0</code> = <code>RGBA/UNSIGNED_BYTE</code> texture
<li> <code>COLOR_ATTACHMENT0</code> = <code>RGBA/UNSIGNED_BYTE</code> texture + <code>DEPTH_ATTACHMENT</code> = <code>DEPTH_COMPONENT16</code> renderbuffer
<li> <code>COLOR_ATTACHMENT0</code> = <code>RGBA/UNSIGNED_BYTE</code> texture + <code>DEPTH_STENCIL_ATTACHMENT</code> = <code>DEPTH_STENCIL</code> renderbuffer
</ul>

<h3><a name="TEXTURE_UPLOAD_SIZE">Texture Upload Width and Height</a></h3>

<p>
Unless <code>width</code> and <code>height</code> parameters are explicitly specified, the width
and height of the texture set by <code>texImage2D</code> and the width and height of the
sub-rectangle updated by <code>texSubImage2D</code> are determined based on the uploaded
<code>TexImageSource source</code> object:
</p>

    <dl>
        <dt><code>source</code> of type <code>ImageData</code>
        <dd>
            The width and height of the texture are set to the current values of the width and
            height properties of the ImageData object, representing the actual pixel width and height
            of the <code>ImageData</code> object.
        <dt><code>source</code> of type <code>HTMLImageElement</code>
        <dd>
            If a bitmap is uploaded, the width and height of the texture are set to the width and
            height of the uploaded bitmap in pixels. If an SVG image is uploaded, the width and
            height of the texture are set to the current values of the width and height properties
            of the <code>HTMLImageElement</code> object.
        <dt><code>source</code> of type <code>HTMLCanvasElement</code> or
          <code>OffscreenCanvas</code>
        <dd>
            The width and height of the texture are set to the current values of the width and
            height properties of the <code>HTMLCanvasElement</code> or <code>OffscreenCanvas</code>
            object.
        <dt><code>source</code> of type <code>HTMLVideoElement</code>
        <dd>
            The width and height of the texture are set to the width and height of the uploaded
            frame of the video in pixels.
    </dl>

<h3><a name="PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a></h3>

<p>
The WebGL API supports the following additional parameters to <code>pixelStorei</code>.

<dl>
<dt><code>UNPACK_FLIP_Y_WEBGL</code> of type <code>boolean</code>
<dd>If set, then during any subsequent calls to <code>texImage2D</code> or
<code>texSubImage2D</code>, the source data is flipped along the vertical axis, so that conceptually
the last row is the first one transferred. The initial value is <code>false</code>. Any non-zero
value is interpreted as <code>true</code>.

<dt><code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> of type <code>boolean</code>
<dd>If set, then during any subsequent calls to <code>texImage2D</code>
or <code>texSubImage2D</code>, the alpha channel of the source data, if present, is multiplied into
the color channels during the data transfer. The initial value is <code>false</code>. Any non-zero
value is interpreted as <code>true</code>.

<dt><code>UNPACK_COLORSPACE_CONVERSION_WEBGL</code> of type <code>unsigned long</code>
<dd>If set to <code>BROWSER_DEFAULT_WEBGL</code>, then the browser's default colorspace conversion
is applied during subsequent <code>texImage2D</code> and <code>texSubImage2D</code> calls
taking <code>HTMLImageElement</code>. The precise conversions may be specific to both the browser
and file type. If set to <code>NONE</code>, no colorspace conversion is applied. The initial value
is <code>BROWSER_DEFAULT_WEBGL</code>.

</dl>

<p>
If the <code>TexImageSource</code> is an <code>ImageBitmap</code>, then these three parameters will
be ignored. Instead the equivalent
<a href="https://html.spec.whatwg.org/multipage/webappapis.html#imagebitmapoptions">ImageBitmapOptions</a> should be used to
create an <code>ImageBitmap</code> with the desired format.

<h3><a name="READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the Framebuffer</a></h3>

<p>
In the WebGL API, three functions read the framebuffer: <code>copyTexImage2D</code>,
<code>copyTexSubImage2D</code>, and <code>readPixels</code>. <code>copyTexImage2D</code> is defined to
generate the RGBA value (0, 0, 0, 0) for any pixel outside of the bound framebuffer.
<code>copyTexSubImage2D</code> and <code>readPixels</code> are defined not to touch the corresponding
destination range for any pixel outside the bound framebuffer.
</p>

<h3><a name="STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a></h3>

<p>
In the WebGL API, if stencil testing is enabled and the currently bound framebuffer has a stencil buffer,
then it is illegal to draw while any of the following cases are true.
Doing so will generate an <code>INVALID_OPERATION</code> error.
</p>

<ul>
<li><code>(STENCIL_WRITEMASK &amp; maxStencilValue) != (STENCIL_BACK_WRITEMASK &amp; maxStencilValue)</code>
<br>
(as specified by <code>stencilMaskSeparate</code> for the <code>mask</code> parameter associated with the FRONT and BACK values of <code>face</code>, respectively)

<li><code>(STENCIL_VALUE_MASK &amp; maxStencilValue) != (STENCIL_BACK_VALUE_MASK &amp; maxStencilValue)</code>
<br>
(as specified by <code>stencilFuncSeparate</code> for the <code>mask</code> parameter associated with the FRONT and BACK values of <code>face</code>, respectively)

<li><code>clamp(STENCIL_REF, 0, maxStencilValue) != clamp(STENCIL_BACK_REF, 0, maxStencilValue)</code>
<br>
(as specified by <code>stencilFuncSeparate</code> for the <code>ref</code> parameter associated with the FRONT and BACK values of <code>face</code>, respectively)
</ul>

<p>
where <code>maxStencilValue</code> is <code>((1 &lt;&lt; s) - 1)</code>,
where <code>s</code> is the number of stencil bits in the draw framebuffer.
(When no stencil bits are present, these checks always pass.)
</p>

    <h3><a name="VERTEX_STRIDE">Vertex Attribute Data Stride</a></h3>

<p>
The WebGL API supports vertex attribute data strides up to 255 bytes. A call to
<code>vertexAttribPointer</code> will generate an <code>INVALID_VALUE</code> error if the value for
the stride parameter exceeds 255.
</p>

    <h3><a name="VIEWPORT_DEPTH_RANGE">Viewport Depth Range</a></h3>

<p>
The WebGL API does not support depth ranges with where the near plane is mapped to a value greater
than that of the far plane. A call to <code>depthRange</code> will generate an
<code>INVALID_OPERATION</code> error if <code>zNear</code> is greater than <code>zFar</code>.
</p>

    <h3><a name="CONSTANT_COLOR_BLEND">Blending With Constant Color</a></h3>

<p>
In the WebGL API, constant color and constant alpha cannot be used together as source and
destination factors in the blend function. A call to <code>blendFunc</code> will generate an
<code>INVALID_OPERATION</code> error if one of the two factors is set to <code>CONSTANT_COLOR</code>
or <code>ONE_MINUS_CONSTANT_COLOR</code> and the other to <code>CONSTANT_ALPHA</code> or
<code>ONE_MINUS_CONSTANT_ALPHA</code>. A call to <code>blendFuncSeparate</code> will generate an
<code>INVALID_OPERATION</code> error if <code>srcRGB</code> is set to <code>CONSTANT_COLOR</code>
or <code>ONE_MINUS_CONSTANT_COLOR</code> and <code>dstRGB</code> is set to <code>CONSTANT_ALPHA</code> or
<code>ONE_MINUS_CONSTANT_ALPHA</code> or vice versa.
</p>

    <h3>Fixed point support</h3>

The WebGL API does not support the <code>GL_FIXED</code> data type.

    <h3><a name="GLSL_CONSTRUCTS">GLSL Constructs</a></h3>

<p>
Per <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a>, identifiers starting with
"webgl_" and "_webgl_" are reserved for use by WebGL.
</p>

    <h3><a name="EXTENSION_QUERIES">Extension Queries</a></h3>

<p>

In the OpenGL ES 2.0 API, the available extensions are determined by calling
<code>glGetString(GL_EXTENSIONS)</code>, which returns a space-separated list of extension strings.
In the WebGL API, the <code>EXTENSIONS</code> enumerant has been removed.
Instead, <code>getSupportedExtensions</code> must be called to determine the set of available
extensions.

</p>

    <h3><a name="COMPRESSED_TEXTURE_SUPPORT">Compressed Texture Support</a></h3>

<p>
    The core WebGL specification does not define any supported compressed texture formats.
    Therefore, in the absence of any other extensions being enabled:

    <ul>

      <li> The <a href="#COMPRESSEDTEXIMAGE2D"><code>compressedTexImage2D</code></a>
           and <a href="#COMPRESSEDTEXSUBIMAGE2D"><code>compressedTexSubImage2D</code></a> methods
           generate an <code>INVALID_ENUM</code> error. </li>

      <li> Calling <a href="#GETPARAMETER"><code>getParameter</code></a> with the
           argument <code>COMPRESSED_TEXTURE_FORMATS</code> returns a zero-length array (of
           type <code>Uint32Array</code>). </li>

    </ul>
</p>

    <h3><a name="MAX_GLSL_TOKEN_SIZE">Maximum GLSL Token Size</a></h3>

<p>
    The GLSL ES spec <a href="#refsGLES20GLSL">[GLES20GLSL]</a> does not define a limit to the
    length of tokens. WebGL requires support of tokens up to 256 characters in length. Shaders
    containing tokens longer than 256 characters must fail to compile.
</p>

    <h3><a name="CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source Character Set</a></h3>

<p>
    The GLSL ES spec <a href="#refsGLES20GLSL">[GLES20GLSL]</a> defines the source character set for
    the OpenGL ES shading language to be ISO/IEC 646:1991, commonly called ASCII <a href="#refsASCII">[ASCII]</a>.
    If a string containing a character not in this set is passed to any of the shader-related entry
    points <code>bindAttribLocation</code>, <code>getAttribLocation</code>, <code>getUniformLocation</code>,
    or <code>shaderSource</code>, an <code>INVALID_VALUE</code> error will be generated. The exception is
    that any character allowed in an HTML DOMString <a href="#refsDOMSTRING">[DOMSTRING]</a> may be used
    in GLSL comments. Such use must not generate an error.
</p>

<div class="note">
    <p>
        Some GLSL implementations disallow characters outside the ASCII range, even in comments. The
        WebGL implementation needs to prevent errors in such cases. The recommended technique is to
        preprocess the GLSL string, removing all comments, but maintaining the line numbering for
        debugging purposes by inserting newline characters as needed.
    </p>
</div>

    <h3><a name="MAX_STRUCT_NESTING">Maximum Nesting of Structures in GLSL Shaders</a></h3>

<p>
    WebGL imposes a limit on the nesting of structures in GLSL shaders. Nesting occurs when a field
    in a struct refers to another struct type; the GLSL ES
    spec <a href="#refsGLES20GLSL">[GLES20GLSL]</a> forbids embedded structure definitions. The
    fields in a top-level struct definition have a nesting level of 1.
</p>
<p>
    WebGL requires support of a structure nesting level of 4. Shaders containing structures nested
    more than 4 levels deep must fail to compile.
</p>

    <h3><a name="MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a></h3>

<p>
    WebGL imposes a limit of 256 characters on the lengths of uniform and attribute locations.
</p>

    <h3><a name="STRING_LENGTH_QUERIES">String Length Queries</a></h3>

<p>
    In the WebGL API, the enumerants <code>INFO_LOG_LENGTH</code>, <code>SHADER_SOURCE_LENGTH</code>,
    <code>ACTIVE_UNIFORM_MAX_LENGTH</code>, and <code>ACTIVE_ATTRIBUTE_MAX_LENGTH</code> have been removed. In
    the OpenGL ES 2.0 API, these enumerants are needed to determine the size of buffers passed to calls
    like <code>glGetActiveAttrib</code>. In the WebGL API, the analogous calls (<code>getActiveAttrib</code>,
    <code>getActiveUniform</code>, <code>getProgramInfoLog</code>, <code>getShaderInfoLog</code>, and
    <code>getShaderSource</code>) all return <code>DOMString</code>.
</p>

<h3>Texture Type in TexSubImage2D Calls</h3>

<p>
    In the WebGL API, the <em>type</em> argument passed to <code>texSubImage2D</code> must match the
    type used to originally define the texture object (i.e., using <code>texImage2D</code>).
</p>

    <h3><a name="PACKING_RESTRICTIONS">Packing Restrictions for Uniforms and Varyings</a></h3>

<p>
    The OpenGL ES Shading Language, Version 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a>,
    Appendix A, Section 7 "Counting of Varyings and Uniforms" defines a conservative algorithm for
    computing the storage required for all of the uniform and varying variables in a shader. The
    GLSL ES specification requires that if the packing algorithm defined in Appendix A succeeds,
    then the shader must succeed compilation on the target platform. The WebGL API further requires
    that if the packing algorithm fails either for the uniform variables of a shader or for the
    varying variables of a program, compilation or linking must fail.
</p>
<p>
    Instead of using a fixed size grid of registers, the number of rows in the target architecture
    is determined in the following ways:

    <ul>
    <li> when counting uniform variables in a vertex shader: <code>getParameter(MAX_VERTEX_UNIFORM_VECTORS)</code>
    <li> when counting uniform variables in a fragment shader: <code>getParameter(MAX_FRAGMENT_UNIFORM_VECTORS)</code>
    <li> when counting varying variables: <code>getParameter(MAX_VARYING_VECTORS)</code>
    </ul>
</p>
<div class="note">
    <p>
        The text above defines the circumstances under which compilation or linking of a shader or
        program must fail due to the constraints enforced by the packing algorithm. It is not
        guaranteed that a shader which uses more variables than the minimum required amount whose
        variables pack successfully according to this algorithm will compile successfully.
        Inefficiencies have been observed in implementations, including expansion of scalar arrays
        to consume multiple columns. Developers should avoid relying heavily upon automatic packing
        of multiple variables into columns. Instead, define larger variables (like vec4) and
        explicitly pack values into the rightmost columns.
    </p>
</div>

<h3>Feedback Loops Between Textures and the Framebuffer</h3>
<p>
    In the OpenGL ES 2.0 API, it's possible to make calls that both write to and read from
    the same texture, creating a feedback loop.
    It specifies that where these feedback loops exist, undefined behavior results.
</p>
<p>
    In the WebGL API, such operations that would cause such feedback loops (by the definitions
    in the OpenGL ES 2.0 spec) will instead generate an <code>INVALID_OPERATION</code> error.
</p>

<h3><a name="READING_FROM_MISSING_ATTACHMENT">Reading From a Missing Attachment</a></h3>
<p>
    In the OpenGL ES 2.0 API, it is not specified what happens when a command tries to source
    data from a missing attachment, such as ReadPixels of color data from a complete framebuffer
    that does not have a color attachment.
</p>
<p>
    In the WebGL API, such operations that require data from an attachment that is missing will
    generate an <code>INVALID_OPERATION</code> error. This applies to the following functions:

    <ul>
    <li> <code>copyTexImage2D</code>
    <li> <code>copyTexSubImage2D</code>
    <li> <code>readPixels</code>
    </ul>
</p>

<h3><a name="DRAWING_TO_MISSING_ATTACHMENT">Drawing To a Missing Attachment</a></h3>
<p>
    In the OpenGL ES 2.0 API, it is not specified what happens when a command tries to draw
    to a missing attachment, such as clearing a draw buffer from a complete framebuffer
    that does not have a color attachment.
</p>
<p>
    In the WebGL API, such operations that draw to an attachment that is missing will draw
    nothing to that attachment. No error is generated. This applies to the following functions:

    <ul>
    <li> <code>clear</code>
    <li> <code>drawArrays</code>
    <li> <code>drawElements</code>
    </ul>
</p>

<h3><a name="NAN_LINE_WIDTH">NaN Line Width</a></h3>
<p>
    In the WebGL API, if the <code>width</code> parameter passed to <code>lineWidth</code> is set
    to NaN, an <code>INVALID_VALUE</code> error is generated and the line width is not changed.
</p>

<h3><a name="ATTRIBUTE_ALIASING">Attribute Aliasing</a></h3>
<p>
    It is possible for an application to bind more than one attribute name to the
    same location. This is referred to as aliasing. When more than one attributes that
    are aliased to the same location are active in the executable program,
    <code>linkProgram</code> should fail.
</p>

<h3><a name="INITIAL_VALUE_GL_POSITION">Initial value for gl_Position</a></h3>
<p>
    The GLSL ES <a href="#refsGLES20GLSL">[GLES20GLSL]</a> spec leaves the value of
    gl_Position as undefined unless it is written to in a vertex shader. WebGL guarantees
    that gl_Position's initial value is <code>(0,0,0,0)</code>.
</p>

<h3>GLSL ES Global Variable Initialization</h3>
<p>
    The GLSL ES 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a> spec restricts global variable
    initializers to be constant expressions. In the WebGL API, it is allowed to use other global
    variables not qualified with the <code>const</code> qualifier and uniform values in global
    variable initializers in GLSL ES 1.00 shaders. Global variable initializers must be global
    initializer expressions, which are defined as one of:
</p>
<ul>
<li>a constant expression</li>
<li>a user-defined global variable</li>
<li>a uniform</li>
<li>
    an expression formed by an operator on operands that are global initializer expressions,
    including getting an element of a global initializer vector or global initializer matrix,
    or a field of a global initializer structure
</li>
<li>a constructor whose arguments are all global initializer expressions</li>
<li>
    a built-in function call whose arguments are all global initializer expressions, with the
    exception of the texture lookup functions
</li>
</ul>
<p>
    The following may not be used in global initializer expressions:
</p>
<ul>
<li>User-defined functions</li>
<li>Attributes and varyings</li>
<li>Built-in variables with the exception of constant expressions</li>
<li>Global variables as l-values in an assignment or other operation</li>
</ul>

<p>
    Compilers should generate a warning when a global variable initializer is in violation of the
    unmodified GLSL ES spec i.e. when a global variable initializer is not a constant expression.
</p>

<div class="note rationale">
    This behavior has existed in WebGL implementations for several years. Fixing this behavior to be
    consistent with the GLSL ES specification would have a large compatibility impact with existing
    content.
</div>

<h3><a name="PREPROCESSOR_DEFINED_IN_MACRO">GLSL ES Preprocessor "defined" Operator</a></h3>

<p>
    The C++ standard, which the GLSL ES preprocessor specification refers to, has undefined behavior
    when the <code>defined</code> operator is generated by macro replacement when parsing the
    controlling expression of an <code>#if</code> or <code>#elif</code> directive. When shader code
    processed by the WebGL API generates the token <code>defined</code> during macro replacement
    inside a preprocessor expression, that must result in a compiler error.
</p>

<p>
    This has no effect on macro expansion outside preprocessor directives that handle the
    <code>defined</code> operator.
</p>

<p>
    Using <code>defined</code> as a macro name also has undefined behavior in the C++ standard. In
    the WebGL API, using <code>defined</code> as a macro name must result in a compiler error.
</p>

<div class="note rationale">
    Behavior of the WebGL API should be consistent in cases where the native API spec allows undefined
    behavior.
</div>

<h3><a name="EXTENSION_DIRECTIVE_LOCATION">GLSL ES #extension directive location</a></h3>

<p>
    The GLSL ES 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a> specification mandates that
    <code>#extension</code> directives must occur before any non-preprocessor tokens unless the
    extension specification says otherwise. In the WebGL API, <code>#extension</code> directives
    may always occur after non-preprocessor tokens in GLSL ES 1.00 shaders. The scope of
    <code>#extension</code> directives in GLSL ES 1.00 shaders is always the whole shader, and
    <code>#extension</code> directives that occur later override those seen earlier for the whole
    shader.
</p>

<div class="note rationale">
    Letting extensions determine where the <code>#extension</code> directives should be placed has
    resulted in a lot of room for interpretation in the spec. In practice GLES implementations have
    not enforced the rule that's written in the GLSL ES spec, and neither have WebGL
    implementations, so relaxing the rule is the only way to make the spec well-defined while being
    compatible with existing content.
</div>

<h3>Completeness of Cube Map Framebuffer Attachments</h3>

<p>
    In the WebGL API, a face of a cube map that is not cube complete is not framebuffer attachment
    complete. Querying framebuffer status when a face of an incomplete cube map is attached must
    return <code>FRAMEBUFFER_INCOMPLETE_ATTACHMENT</code>.
</p>

<div class="note rationale">
    APIs that WebGL is implemented on, including recent OpenGL core
    versions and OpenGL ES 3.0 and newer, have a requirement that cube
    map faces used as a framebuffer attachment must be part of a cube
    complete cube map. See for
    example <a href="https://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.4.4">OpenGL
    ES 3.0.4 &sect;4.4.4</a> "Framebuffer Completeness", subsection
    "Framebuffer Attachment Completeness".
</div>

<h3>Transferring vertices when current program is null</h3>

<p>
    Any command that transfers vertices to the GL generates <code>INVALID_OPERATION</code> if the
    <code>CURRENT_PROGRAM</code> is null. This includes <code>drawElements</code> and
    <code>drawArrays</code>.
</p>

<h3>Fragment shader output</h3>

<p>
    If a fragment shader writes to neither <code>gl_FragColor</code> nor <code>gl_FragData</code>,
    the values of the fragment colors following shader execution are untouched.
</p>

<h3>Initial values for GLSL local and global variables</h3>

<p>
    The GLSL ES <a href="#refsGLES20GLSL">[GLES20GLSL]</a> spec leaves the value of
    local and global variables as undefined unless they are initialized by the
    shader. WebGL guarantees that such variables are initialized to zero:
    <code>0.0</code>, <code>vec4(0.0)</code>, <code>0</code>, <code>false</code>, etc.
</p>

<h3>Vertex attribute conversions from normalized signed integers to floating point</h3>

<p>
    The OpenGL ES 2.0 spec <a href="#refsGLES20">[GLES20]</a> section 2.1.2 "Data Conversions",
    subsection "Conversion from Integer to Floating-Point" defines conversion from a normalized
    signed integer <em>c</em>, where the bit width of the type is <em>b</em>, to floating-point
    value <em>f</em> as:

    <dl>
    <dd><em>f</em> = (2*<em>c</em> + 1) / (2^<em>b</em> - 1)</dd>
    </dl>

    During conversions of signed normalized vertex attributes to floating point, WebGL 1.0
    implementations may optionally use this conversion rule, which preserves zeros:

    <dl>
    <dd><em>f</em> = max(<em>c</em> / (2^(<em>b</em> - 1) - 1), -1.0)
    </dl>

    <div class="note rationale">
    Some APIs on which WebGL 1.0 is built on use the second rule, and since this conversion is done
    in fixed-function hardware, it is not possible to emulate one behavior or the other. This
    difference in behavior does not affect most applications, so a query to determine which behavior
    is being used has not been added to the WebGL rendering context.
    </div>
</p>

<h3>Uniform and attribute name collisions</h3>

<p>
    If any of the shaders attached to a WebGL program declare a uniform that has the same name as a
    statically used vertex attribute, program linking should fail.
</p>

<div class="note">
    This behavior differs from one specified in GLSL ES 3.00.6 section 12.47.
</div>

<div class="note rationale">
    WebGL implementations have enforced this behavior for several years now, due to that some OpenGL
    drivers don't accept uniforms and vertex attributes with the same name.
</div>

<h3>Wide point primitive clipping</h3>
<p>
    <code>POINTS</code> primitives may or may not be discarded if the vertex lies outside the clip
    volume, but within the near and far clip planes.
</p>
<div class="note rationale">
    <p>
        Clipping of wide points works differently in GLES and GL, and this difference in behavior is
        prohibitive to work around in implementations.
    </p>
    <p>
        <a href="#refsGLES20">OpenGL ES 2.0.25</a> p46:
        <blockquote>
            If the primitive under consideration is a point, then clipping discards it if it lies
            outside the near or far clip plane; otherwise it is passed unchanged.
        </blockquote>
    </p>
    <p>
        <a href="#refsGL32CORE">OpenGL 3.2 Core</a> p97:
        <blockquote>
            If the primitive under consideration is a point, then clipping passes it unchanged if it
            lies within the clip volume; otherwise, it is discarded.
        </blockquote>
    </p>
</div>

<!-- ======================================================================================================= -->

    <h2>References</h2>

    <dl>

        <dt id="refsCANVAS">[CANVAS]</dt>
        <dd><cite><a href="https://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">
            HTML5: The Canvas Element</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>

        <dt id="refsOFFSCREENCANVAS">[OFFSCREENCANVAS]</dt>
        <dd><cite><a href="https://html.spec.whatwg.org/multipage/canvas.html#the-offscreencanvas-interface">
            HTML Living Standard - The OffscreenCanvas interface</a></cite>,
            WHATWG.
        </dd>

        <dt id="refsCANVASCONTEXTS">[CANVASCONTEXTS]</dt>
        <dd><cite><a href="http://wiki.whatwg.org/wiki/CanvasContexts">
            Canvas Context Registry</a></cite>,
            WHATWG.
        </dd>
        <dt id="refsECMASCRIPT">[ECMASCRIPT]</dt>
        <dd><cite><a href="http://www.ecma-international.org/ecma-262/6.0/">
            ECMAScript&reg; 2015 Language Specification</a></cite>,
            Ecma International, 2015.
        </dd>
        <dt id="refsGL32CORE">[GL32CORE]</dt>
        <dd><cite><a href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec32.core.pdf">
            The OpenGL&reg; Graphics System: A Specification (Version 3.2 (Core Profile) - December 7, 2009)</a></cite>,
            M. Segal, K. Akeley, December 2009.
        </dd>
        <dt id="refsGLES20">[GLES20]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf">
            OpenGL&reg; ES Common Profile Specification Version 2.0.25</a></cite>,
            A. Munshi, J. Leech, November 2010.
        </dd>
        <dt id="refsGLES20GLSL">[GLES20GLSL]</dt>
        <dd><cite><a href="https://www.khronos.org/registry/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf">
            The OpenGL&reg; ES Shading Language Version 1.00</a></cite>,
            R. Simpson, May 2009.
        </dd>
        <dt id="refsREGISTRY">[REGISTRY]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webgl/extensions/">
            WebGL Extension Registry</a></cite>
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsCSS">[CSS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/CSS21/">
            Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a></cite>,
            B. Bos, T. Celik, I. Hickson, H. W. Lie, June 2011.
        </dd>
        <dt id="refsCORS">[CORS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/cors/">
            Cross-Origin Resource Sharing</a></cite>,
            A. van Kesteren, July 2010.
        </dd>
        <dt id="refsDOM4">[DOM4]</dt>
        <dd><cite><a href="http://www.w3.org/TR/domcore/">
            DOM4</a></cite>,
            A. van Kesteren, A. Gregor, Ms2ger.
        </dd>
        <dt id="refsDOM3EVENTS">[DOM3EVENTS]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html">
            Document Object Model (DOM) Level 3 Events Specification</a></cite>,
            Doug Schepers and Jacob Rossi. W3C.
        </dd>
        <dt id="refsHTML">[HTML]</dt>
        <dd><cite><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">
            HTML</a></cite>,
            I. Hickson, June 2011.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="https://heycam.github.io/webidl/">
            Web IDL: W3C Editor’s Draft</a></cite>,
            C. McCormack, B. Zbarsky, T. Langel.
        </dd>
        <dt id="refsASCII">[ASCII]</dt>
        <dd><cite>International Standard ISO/IEC 646:1991. Information technology -
            ISO 7-bit coded character set for information interchange</cite>
        </dd>
        <dt id="refsDOMSTRING">[DOMSTRING]</dt>
        <dd><cite><a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#DOMString">
            Document Object Model Core: The DOMString type</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>
        <dt id="refsKHRROBUSTACCESS">[KHRROBUSTACCESS]</dt>
        <dd><cide><a href="https://www.opengl.org/registry/specs/KHR/robust_buffer_access_behavior.txt">
            KHR_robust_buffer_access_behavior OpenGL ES extension</a></cite>,
            Leech, J. and Daniell, P., August, 2014.
        </dd>
        <dt id="refsMULTIPLEBUFFERING">[MULTIPLEBUFFERING]</dt>
        <dd>(Non-normative) <cite><a href="https://en.wikipedia.org/wiki/Multiple_buffering">
            Multiple buffering</a></cite>. Wikipedia.
        </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h2>Acknowledgments</h2>
    <p>This specification is produced by the Khronos WebGL Working Group.</p>

    <p>
        Special thanks to: Arun Ranganathan (Mozilla), Chris Marrin (Apple), Jon Leech, Kenneth
        Russell (Google), Kenneth Waters (Google), Mark Callow (HI), Mark Steele (Mozilla), Oliver
        Hunt (Apple), Tim Johansson (Opera), Vangelis Kokkevis (Google), Vladimir Vukicevic
        (Mozilla), Gregg Tavares (Google)
    </p>
    <p>
        Additional thanks to: Alan Hudson (Yumetech), Benoit Jacob (Mozilla), Bill Licea Kane (AMD),
        Boris Zbarsky (Mozilla), Cameron McCormack (Mozilla), Cedric Vivier (Zegami), Dan Gessel
        (Apple), David Ligon (Qualcomm), David Sheets (Ashima Arts), Glenn Maynard, Greg Roth
        (Nvidia), Jacob Strom  (Ericsson), Jeff Gilbert (Mozilla), Kari Pulli (Nokia), Teddie Stenvi
        (ST-Ericsson), Neil Trevett (Nvidia), Per Wennersten (Ericsson), Per-Erik Brodin (Ericsson),
        Shiki Okasaka (Google), Tom Olson (ARM), Zhengrong Yao (Ericsson), and the members of the
        Khronos WebGL Working Group.
    </p>

</body>
</html>
