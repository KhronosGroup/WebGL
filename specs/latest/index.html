<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>WebGL Specification</title>
    <meta name="generator" content="BBEdit 9.1">
    <link rel="stylesheet" type="text/css" href="../../resources/Khronos-WD.css" />
    <script src="../../resources/jquery-1.3.2.min.js" type="text/javascript"></script>
    <script src="../../resources/generateTOC.js" type="text/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class=head>
        <p>
            <a href="http://khronos.org/">
                <img alt=Khronos height=60 src="../../resources/KhronosGroup-3D.png" width=220>
            </a>
        </p>
    </div>
    <div class=head>
        <p>
            <a href="http://webgl.org/">
                <img alt=WebGL height=72 src="../../resources/WebGL-Logo.png" width=156>
            </a>
        </p>
    </div>
    <!--end-logo-->
    
    <h1>WebGL Specification</h1>
    <h2 class="no-toc">Editor's Draft 28 November 2012</h2>
    <dl>
        <dt>This version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/">
                    https://www.khronos.org/registry/webgl/specs/latest/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/webgl.idl
                </a>
            </dd>
        <dt>Latest version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/">
                    https://www.khronos.org/registry/webgl/specs/latest/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/webgl.idl
                </a>
            </dd>
        <dt>Previous version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0/">
                    https://www.khronos.org/registry/webgl/specs/1.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/1.0/webgl.idl
                </a>
            </dd>
        <dt>Editor:
            <dd>
                <a href="mailto:cmarrin@apple.com">Chris Marrin</a>
                <a href="http://www.apple.com/">(Apple Inc.)</a>
            </dd>
    </dl>
    
    <span style="font-size: x-small; font-style: oblique">Copyright &copy; 2012 Khronos Group</span>

    <hr />
    
    <h2 class="no-toc">Abstract</h2>
    <p>
        This specification describes an additional rendering context and support
        objects for the
        <a href="http://www.w3.org/TR/html5/the-canvas-element.html"
           title="HTML 5 Canvas Element">
            HTML 5 <span class="prop-name">canvas</span> element <a href="#refsCANVAS">[CANVAS]</a>.
        </a>
        This context allows rendering using an API that conforms closely to the OpenGL ES 2.0 API.
    </p>

    <h2 class="no-toc">Status of this document</h2>
    
    <!--begin-status-->
    <p>
        This document is an editor's draft. Do not cite this document as other than work in
        progress.  Public discussion of this specification is welcome on the
        (<a href="https://www.khronos.org/webgl/public-mailing-list/archives/">archived</a>) WebGL
        mailing list <a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a> (see
        <a href="http://www.khronos.org/webgl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->
    
    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>
    <div class="note">        
    <p>
      WebGL™ is an immediate mode 3D rendering API designed for the
      web.  It is derived from OpenGL® ES 2.0, and provides similar
      rendering functionality, but in an HTML context.  WebGL is
      designed as a rendering context for the HTML Canvas element.
      The HTML Canvas provides a destination for programmatic
      rendering in web pages, and allows for performing that rendering
      using different rendering APIs.  The only such interface
      described as part of the Canvas specification is the 2D canvas
      rendering context, CanvasRenderingContext2D. This document
      describes another such interface, WebGLRenderingContext, which
      presents the WebGL API.
    </p>
    
    <p>
      The immediate mode nature of the API is a divergence from most
      web APIs.  Given the many use cases of 3D graphics, WebGL
      chooses the approach of providing flexible primitives that can
      be applied to any use case.  Libraries can provide an API on top
      of WebGL that is more tailored to specific areas, thus adding a
      convenience layer to WebGL that can accelerate and simplify development.
      However, because of its OpenGL ES 2.0 heritage, it should be
      straightforward for developers familiar with modern desktop
      OpenGL or OpenGL ES 2.0 development to transition to WebGL
      development.
    </p>
    </div>

    <h3>Conventions</h3>

    <p>
     Many functions described in this document contain links to OpenGL ES
     man pages. While every effort is made to make these pages match the
     OpenGL ES 2.0 specification <a href="#refsGLES20">[GLES20]</a>, 
     they may contain errors. In the case of a contradiction, the OpenGL 
     ES 2.0 specification is the final authority.
    </p>

    <p>
      The remaining sections of this document are intended to be read in conjunction
      with the OpenGL ES 2.0 specification (2.0.25 at the time of this writing, available
      from the <a href="http://www.khronos.org/registry/gles/">Khronos OpenGL ES API Registry</a>).
      Unless otherwise specified, the behavior of each method is defined by the
      OpenGL ES 2.0 specification.  This specification may diverge from OpenGL ES 2.0
      in order to ensure interoperability or security, often defining areas that
      OpenGL ES 2.0 leaves implementation-defined.  These differences are summarized in the
      <a href="#webgl_gl_differences">Differences Between WebGL and OpenGL ES 2.0</a> section.
    </p>

<!-- ======================================================================================================= -->

    <h2>Context Creation and Drawing Buffer Presentation</h2>

    <p>
        Before using the WebGL API, the author must obtain a <code>WebGLRenderingContext</code>
        object for a given HTMLCanvasElement <a href="#refsCANVAS">[CANVAS]</a> as described
        below. This object is used to manage OpenGL state and render to the drawing buffer, which
        must be created at the time of context creation.
    </p>
    
<!-- ======================================================================================================= -->

    <h3>Context Creation</h3>

    <p>
        Each <code>WebGLRenderingContext</code> has an
        associated <b><a name="context-canvas">canvas</a></b>, set upon creation, which is
        a <em>canvas</em> <a href="#refsCANVAS">[CANVAS]</a>.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> has <b><a name="context-creation-parameters">context
        creation parameters</a></b>, set upon creation, in
        a <a href="#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> has <b><a name="actual-context-parameters">actual
        context parameters</a></b>, set each time the drawing buffer is created, in
        a <a href="#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> has a <b><a name="webgl-context-lost-flag">webgl
        context lost flag</a></b>, which is initially unset.
    </p>
    <p>
        When the <code>getContext()</code> method of a <code>canvas</code> element is to return a
        new object for
        the <em>contextId</em> <code>webgl</code> <a href="#refsCANVASCONTEXTS">[CANVASCONTEXTS]</a>,
        the user agent must perform the following steps:

        <ol class="nestedlist">

        <li> Create a new <code>WebGLRenderingContext</code> object, <em>context</em>.

        <li> Let <em>context's</em> <a href="#context-canvas">canvas</a> be the canvas
             the <code>getContext()</code> method is associated with.

        <li> Create a new <code>WebGLContextAttributes</code> object, <em>contextAttributes</em>.

        <li> If <code>getContext()</code> was invoked with a second argument, <em>options</em>, set
             the attributes of <em>contextAttributes</em> from those specified in <em>options</em>.

        <li> <a href="#create-a-drawing-buffer">Create a <em>drawing buffer</em></a> using the settings
             specified in <em>contextAttributes</em>, and associate the <em>drawing buffer</em>
             with <em>context</em>.

        <li> If drawing buffer creation failed, perform the following steps:

          <ol class="nestedlist">

          <li> <a href="#fire-a-webgl-context-creation-error">Fire a WebGL context creation
          error</a> at <em>canvas</em>.

          <li> Return null and terminate these steps.

          </ol>

        <li> Set the attributes of <em>contextAttributes</em> based on the properties of the newly
             created drawing buffer.

        <li> Set <em>context's</em> <a href="#context-creation-parameters">context creation
        parameters</a> to <em>contextAttributes</em>.

        <li> Return <em>context</em>.

        </ol>
    </p>
    
<!-- ======================================================================================================= -->

    <h3><a name="THE_DRAWING_BUFFER">The Drawing Buffer</a></h3>

    <p>
        The drawing buffer into which the API calls are rendered shall be defined upon creation of
        the WebGLRenderingContext object. The following description defines how
        to <b><a name="create-a-drawing-buffer">create a drawing buffer</a></b>.
    </p>
    <p>
        The table below shows all the buffers which make up the drawing buffer, along with their
        minimum sizes and whether they are defined or not by default. The size of this drawing
        buffer shall be determined by the <code>width</code> and <code>height</code> attributes of
        the HTMLCanvasElement. The table below also shows the value to which these buffers shall be
        cleared when first created, when the size is changed, or after presentation when
        the <code>preserveDrawingBuffer</code> context creation attribute is <code>false</code>.
    </p>
    <table class="foo">
        <tr><th>Buffer</th><th>Clear value</th><th>Minimum size</th><th>Defined by default?</th></tr>
        <tr><td>Color</td><td>(0, 0, 0, 0)</td><td>8 bits per component</td><td>yes</td></tr>
        <tr><td>Depth</td><td>1.0</td><td>16 bit integer</td><td>yes</td></tr>
        <tr><td>Stencil</td><td>0</td><td>8 bits</td><td>no</td></tr>
    </table>
    <br>
    <p>
        If the requested width or height cannot be satisfied, either when the drawing buffer is first
        created or when the <code>width</code> and <code>height</code> attributes of the 
        <code>HTMLCanvasElement</code> are changed, a drawing buffer with smaller dimensions shall
        be created. The dimensions actually used are implementation dependent and there is no 
        guarantee that a buffer with the same aspect ratio will be created. The actual drawing 
        buffer size can be obtained from the <code>drawingBufferWidth</code> and 
        <code>drawingBufferHeight</code> attributes.
    </p>
    <p>
        A WebGL implementation must not perform any automatic scaling of the size of the drawing
        buffer on high-definition displays. The context's <code>drawingBufferWidth</code>
        and <code>drawingBufferHeight</code> must match the canvas's <code>width</code>
        and <code>height</code> attributes as closely as possible, modulo implementation-dependent
        constraints.
    </p>
    <div class="note">
        <p>
            The constraint above does not change the amount of space the canvas element consumes on
            the web page, even on a high-definition display. The
            canvas's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#attr-canvas-width">intrinsic
            dimensions</a> <a href="#refsCANVAS">[CANVAS]</a> equal the size of its coordinate
            space, with the numbers interpreted in CSS pixels, and CSS pixels
            are <a href="http://www.w3.org/TR/CSS21/syndata.html#length-units">resolution-independent</a> <a href="#refsCSS">[CSS]</a>.
        </p>
        <p>
            A WebGL application can achieve a 1:1 ratio between drawing buffer pixels and on-screen
            pixels on high-definition displays by examining properties
            like <code>window.devicePixelRatio</code>, scaling the canvas's <code>width</code>
            and <code>height</code> by that factor, and setting its CSS width and height to the
            original width and height. An application can simulate the effect of running on a
            higher-resolution display simply by scaling up the canvas's <code>width</code>
            and <code>height</code> properties.
        </p>
    </div>
    <p>
        The optional <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> object may be used
        to change whether or not the buffers are defined. It can also be used to define whether the
        color buffer will include an alpha channel. If defined, the alpha channel is used by the
        HTML compositor to combine the color buffer with the rest of the page. The
        WebGLContextAttributes object is only used on the first call to
        <code>getContext</code>. No facility is provided to change the attributes of the drawing 
        buffer after its creation.
    </p>
    <p>
        The <code>depth</code>, <code>stencil</code> and <code>antialias</code> attributes, when set
        to true, are requests, not requirements. The WebGL implementation should make a best effort
        to honor them. When any of these attributes is set to false, however, the WebGL
        implementation must not provide the associated functionality. Combinations of attributes not
        supported by the WebGL implementation or graphics hardware shall not cause a failure to
        create a WebGLRenderingContext. The <a href="#actual-context-parameters">actual context
        parameters</a> are set to the attributes of the created drawing buffer. The
        <code>alpha</code>, <code>premultipliedAlpha</code> and <code>preserveDrawingBuffer</code>
        attributes must be obeyed by the WebGL implementation.
    </p>
    <p>
        WebGL presents its drawing buffer to the HTML page compositor immediately before a
        compositing operation, but only if <code>clear</code>, <code>drawArrays</code>
        or <code>drawElements</code> have been called since the last compositing operation, while
        the drawing buffer is the currently bound framebuffer. Before the drawing buffer is
        presented for compositing the implementation shall ensure that all rendering operations have
        been flushed to the drawing buffer. By default, after compositing the contents of the
        drawing buffer shall be cleared to their default values, as shown in the table above.
    </p>
    <p>
        This default behavior can be changed by setting the <code>preserveDrawingBuffer</code>
        attribute of the <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> object. If
        this flag is true, the contents of the drawing buffer shall be preserved until the author
        either clears or overwrites them. If this flag is false, attempting to perform operations
        using this context as a source image after the rendering function has returned can lead to
        undefined behavior. This includes <code>readPixels</code> or <code>toDataURL</code> calls,
        or using this context as the source image of another context's <code>texImage2D</code> or
        <code>drawImage</code> call.
    </p>
    <div class="note">        
        <p>
            While it is sometimes desirable to preserve the drawing buffer, it can cause significant 
            performance loss on some platforms. Whenever possible this flag should remain false 
            and other techniques used. Techniques like synchronous drawing buffer access (e.g., 
            calling <code>readPixels</code> or <code>toDataURL</code> in the same function that 
            renders to the drawing buffer) can be used to get the contents of the drawing buffer. 
            If the author needs to render to the same drawing buffer over a series of calls, a 
            <a href="#WEBGL_FRAMEBUFFER">Framebuffer Object</a> can be used.
        </p>
        <p>
            Implementations may optimize away the required implicit clear operation of the Drawing 
            Buffer as long as a guarantee can be made that the author cannot gain access to buffer 
            contents from another process. For instance, if the author performs an explicit 
            clear then the implicit clear is not needed.
        </p>
    </div>
    
<!-- ======================================================================================================= -->

    <h3>The WebGL Viewport</h3>

    <p>
        OpenGL manages a rectangular viewport as part of its state which defines the placement of
        the rendering results in the drawing buffer. Upon creation of WebGL
        context <em>context</em>, the viewport is initialized to a rectangle with origin at (0, 0)
        and width and height equal to (context.drawingBufferWidth, context.drawingBufferHeight).
    </p>
    <p>
        A WebGL implementation <em>shall not</em> affect the state of the OpenGL viewport in response to
        resizing of the canvas element.
    </p>
    <div class="example">
        Note that if a WebGL program does not contain logic to set the viewport, it will not properly
        handle the case where the canvas is resized. The following ECMAScript example illustrates how
        a WebGL program might resize the canvas programmatically.

        <pre>
var canvas = document.getElementById('canvas1');
var gl = canvas.getContext('webgl');
canvas.width = newWidth;
canvas.height = newHeight;
gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        </pre>
    </div>
    <p>
        <em>Rationale</em>: automatically setting the viewport will interfere with applications that set
        it manually. Applications are expected to use <code>onresize</code> handlers to respond to
        changes in size of the canvas and set the OpenGL viewport in turn.
    </p>

<!-- ======================================================================================================= -->

    <h3><a name="PREMULTIPLIED_ALPHA">Premultiplied Alpha, Canvas APIs and texImage2D</a></h3>

    <p>
        The OpenGL API allows the application to modify the blending modes used during rendering,
        and for this reason allows control over how alpha values in the drawing buffer are
        interpreted; see the <code>premultipliedAlpha</code> parameter in
        the <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> section.
    </p>
    <p>
        The HTML Canvas APIs <code>toDataURL</code> and <code>drawImage</code> must respect
        the <code>premultipliedAlpha</code> context creation parameter. When <code>toDataURL</code>
        is called against a Canvas into which WebGL content is being rendered, then if the requested
        image format does not specify premultiplied alpha and the WebGL context has
        the <code>premultipliedAlpha</code> parameter set to true, then the pixel values must be
        de-multiplied; i.e., the color channels are divided by the alpha channel. <b>Note</b> that
        this operation is lossy.
    </p>
    <p>
        Passing a WebGL-rendered Canvas to the <code>drawImage</code> method
        of <code>CanvasRenderingContext2D</code> may or may not need to modify the the rendered
        WebGL content during the drawing operation, depending on the premultiplication needs of the
        <code>CanvasRenderingContext2D</code> implementation.
    </p>
    <p>
        When passing a WebGL-rendered Canvas to the <code>texImage2D</code> API, then depending on
        the setting of the <code>premultipliedAlpha</code> context creation parameter of the passed
        canvas and the <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel store parameter of the
        destination WebGL context, the pixel data may need to be changed to or from premultiplied
        form.
    </p>

<!-- ======================================================================================================= -->

    <h2>WebGL Resources</h2>

    <p> 
        OpenGL manages several types of resources as part of its state. These are identified
        by integer object names and are obtained from OpenGL by various creation calls.
        In contrast WebGL represents these resources as DOM objects. Each object is derived 
        from the WebGLObject interface. Currently supported resources are:
        textures, buffers (i.e., VBOs), framebuffers, renderbuffers, shaders and
        programs. The WebGLRenderingContext interface has a method to create a 
        WebGLObject subclass for each type. Data from the underlying graphics library are
        stored in these objects and are fully managed by them. The resources represented
        by these objects are guaranteed to exist as long as the object exists.
        Furthermore, the DOM object is guaranteed to exist as long as the author has an explicit
        valid reference to it <b>or</b> as long as it is bound by the underlying graphics library.
        When none of these conditions exist the user agent can, at any point, delete the object 
        using the equivalent of a delete call (e.g., deleteTexture). If authors wish to control 
        when the underlying resource is released then the delete call can be made explicitly.
    </p>

<!-- ======================================================================================================= -->

    <h2>Security</h2>

    <p> 
    </p>

<!-- ======================================================================================================= -->

    <h3>Resource Restrictions</h3>

    <p>
        WebGL resources such as textures and vertex buffer objects (VBOs) must always 
        contain initialized data, even if they were created without initial user 
        data values.  Creating a resource without initial values is commonly used to 
        reserve space for a texture or VBO, which is then modified using <code>texSubImage</code> or 
        <code>bufferSubData</code> calls.  If initial data is not provided to these calls, the WebGL
        implementation must initialize their contents to 0; depth renderbuffers must be cleared to
        the default 1.0 clear depth.  This may require creating a zeroed temporary buffer the size
        of a requested VBO, so that it can be initialized correctly.  All other forms of loading
        data into a texture or VBO involve either ArrayBuffers or DOM objects such as images, and
        are therefore already required to be initialized.
    </p>

    <p>
        When WebGL resources are accessed by shaders through a call such as
        <code>drawElements</code> or <code>drawArrays</code>, the WebGL implementation must ensure
        that the shader cannot access either out of bounds or uninitialized data.
        See <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range Checking</a>
        for restrictions which must be enforced by the WebGL implementation.
    </p>

<!-- ======================================================================================================= -->

    <h3><a name="ORIGIN_RESTRICTIONS">Origin Restrictions</a></h3>

    <p>
        In order to prevent information leakage, WebGL disallows uploading as textures:
        <ul>
        <li> Image or video elements whose origin is not the same as the origin of the Document that
             contains the WebGLRenderingContext's canvas element
        <li> Canvas elements whose <i>origin-clean</i> flag is set to false
        </ul>
    </p>
    <p>
        If the <code>texImage2D</code> or <code>texSubImage2D</code> method is called with otherwise
        correct arguments and an <code>HTMLImageElement</code>, <code>HTMLVideoElement</code>,
        or <code>HTMLCanvasElement</code> violating these restrictions, a <code>SECURITY_ERR</code>
        exception must be thrown.
    </p>
    <div class="note">
        <p>
            WebGL necessarily imposes stronger restrictions on the use of cross-domain media than other
            APIs such as the 2D canvas rendering context, because shaders can be used to indirectly
            deduce the contents of textures which have been uploaded to the GPU.
        </p>
        <p>
            WebGL applications may utilize images and videos that come from other domains, with the
            cooperation of the server hosting the media,
            using <a href="http://www.w3.org/TR/cors/">Cross-Origin Resource
            Sharing</a> <a href="#refsCORS">[CORS]</a>. In order to use such media, the application
            needs to explicitly request permission to do so, and the server needs to explicitly grant
            permission. Successful CORS-enabled fetches of image and video elements from other
            domains <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#origin-0">cause
            the origin of these elements</a> to be set to that of the containing
            Document <a href="#refsHTML">[HTML]</a>.
        </p>
        <div class="example">
            <p>
                The following ECMAScript example demonstrates how to issue a CORS request for an
                image coming from another domain. The image is fetched from the server without any
                credentials, i.e., cookies.
            </p>
<pre>
var gl = ...;
var image = new Image();

// The onload handler should be set to a function which uploads the HTMLImageElement
// using texImage2D or texSubImage2D.
image.onload = ...;

image.crossOrigin = "anonymous";

image.src = "http://other-domain.com/image.jpg";
</pre>
        </div>
        <p>
            Note that these rules imply that the <i>origin-clean</i> flag for a canvas rendered
            using WebGL will never be set to false.
        </p>
        <p>
            For more information on issuing CORS requests for image and video elements, consult:
            <ul>
            <li> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#cors-settings-attribute">CORS settings attributes</a> <a href="#refsHTML">[HTML]</a>
            <li> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content-1.html#the-img-element">The <code>img</code> element</a> <a href="#refsHTML">[HTML]</a>
            <li> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#media-elements">Media elements</a> <a href="#refsHTML">[HTML]</a>
            </ul>
        </p>
    </div>

<!-- ======================================================================================================= -->

    <h3><a name="SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a></h3>

    <p>
        A WebGL implementation must only accept shaders which conform to The OpenGL ES Shading
        Language, Version 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a>, and which do not exceed
        the minimum functionality mandated in Sections 4 and 5 of Appendix A.  In particular:

        <ul>
        <li> A shader referencing state variables or functions that are available in other versions
             of GLSL, such as that found in versions of OpenGL for the desktop, must not be allowed
             to load. </li>
        <li> <code>for</code> loops must conform to the structural constraints in Appendix A. </li>
        <li> <code>while</code> and <code>do-while</code> loops are disallowed, since they are
             optional in Appendix A.</li>
        <li> Appendix A mandates certain forms of indexing of arrays; for example, within fragment
             shaders, indexing is only mandated with a <i>constant-index-expression</i>
             (see <a href="#refsGLES20GLSL">[GLES20GLSL]</a> for the definition of this term). In
             the WebGL API, only the forms of indexing mandated in Appendix A are supported. </li>
        </ul>
    </p>
    <p>
        In addition to the reserved identifiers in the aforementioned specification, identifiers
        starting with "webgl_" and "_webgl_" are reserved for use by WebGL. A shader which declares
        a function, variable, structure name, or structure field starting with these prefixes must
        not be allowed to load.
    </p>

<!-- ======================================================================================================= -->

    <h3>Defense Against Denial of Service</h3>
    <div class="note">        
    <p>
    It is possible to create, either intentionally or unintentionally, combinations of shaders and
    geometry that take an undesirably long time to render. This issue is analogous to that of
    long-running scripts, for which user agents already have safeguards. However, long-running draw
    calls can cause loss of interactivity for the entire window system, not just the user agent.
    </p>

    <p>
    In the general case it is not possible to impose limits on the structure of incoming shaders to
    guard against this problem. Experimentation has shown that even very strict structural limits
    are insufficient to prevent long rendering times, and such limits would prevent shader authors
    from implementing common algorithms.
    </p>

    <p>
    User agents should implement safeguards to prevent excessively long rendering times and
    associated loss of interactivity. Suggested safeguards include:
    </p>

    <ul>

    <li> Splitting up draw calls with large numbers of elements into smaller draw calls.

    <li> Timing individual draw calls and forbidding further rendering from a page if a certain
         timeout is exceeded.

    <li> Using any watchdog facilities available at the user level, graphics API level, or operating
         system level to limit the duration of draw calls.

    <li> Separating the graphics rendering of the user agent into a distinct operating system
         process which can be terminated and restarted without losing application state.

    </ul>

    <p>
    The supporting infrastructure at the OS and graphics API layer is expected to improve over time,
    which is why the exact nature of these safeguards is not specified.
    </p>
    </div>
<!-- ======================================================================================================= -->

    <h3><a name="OUT_OF_RANGE_ARRAY_ACCESSES">Out-of-Range Array Accesses</a></h3>

    <p>
        Shaders must not be allowed to read or write array elements that lie outside the bounds of
        the array. This includes any variable of array type, as well as vector or matrix types such
        as <code>vec3</code> or <code>mat4</code> when accessed using array subscripting syntax. If
        detected during compilation, such accesses must generate an error and prevent the shader
        from compiling. Otherwise, at runtime they may return a constant value (such as 0), or the
        value at any valid index of the same array.
    </p>
    <div class="note">
        <p>
            See <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a> for more information
            on restrictions which simplify static analysis of the array indexing operations in shaders.
        </p>
    </div>
<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

<!-- ======================================================================================================= -->

    <h3>Types</h3>

    <p>
        The following types are used in all interfaces in the following section.
    </p>
    <pre class="idl">
typedef unsigned long  GLenum;
typedef boolean        GLboolean;
typedef unsigned long  GLbitfield;
typedef byte           GLbyte;         /* 'byte' should be a signed 8 bit type. */
typedef short          GLshort;
typedef long           GLint;
typedef long           GLsizei;
typedef long long      GLintptr;
typedef long long      GLsizeiptr;
// Ideally the typedef below would use 'unsigned byte', but that doesn't currently exist in Web IDL.
typedef octet          GLubyte;        /* 'octet' should be an unsigned 8 bit type. */
typedef unsigned short GLushort;
typedef unsigned long  GLuint;
typedef unrestricted float GLfloat;
typedef unrestricted float GLclampf;  
</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a></h3>

    <p>
        The <code>WebGLContextAttributes</code> dictionary contains drawing surface attributes and
        is passed as the second parameter to <code>getContext</code>.
    </p>
    <pre class="idl">dictionary <dfn id="WebGLContextAttributes">WebGLContextAttributes</dfn> {
    boolean alpha = true;
    boolean depth = true;
    boolean stencil = false;
    boolean antialias = true;
    boolean premultipliedAlpha = true;
    boolean preserveDrawingBuffer = false;
};</pre>

    <h4>Context creation parameters</h4>

    <p>
        The following list describes each attribute in the WebGLContextAttributes object and its
        use. For each attribute the default value is shown. The default value is used either if no
        second parameter is passed to <code>getContext</code>, or if a user object is passed which
        has no attribute of the given name.
    </p>
    <dl>
        <dt><span class=prop-value>alpha</span></dt>
            <dd>
                If the value is true, the drawing buffer has an alpha channel for the purposes of
                performing OpenGL destination alpha operations and compositing with the page. If the
                value is false, no alpha buffer is available.
            </dd>
        <dt> <span class=prop-value>depth</span>
            <dd>
                If the value is true, the drawing buffer has a depth buffer of at least 16 bits. If
                the value is false, no depth buffer is available.
           </dd>
        <dt> <span class=prop-value>stencil</span>
            <dd>
                If the value is true, the drawing buffer has a stencil buffer of at least 8 bits. If
                the value is false, no stencil buffer is available.
            </dd>
        <dt> <span class=prop-value>antialias</span>
            <dd>
                If the value is true and the implementation supports antialiasing the drawing buffer
                will perform antialiasing using its choice of technique (multisample/supersample)
                and quality. If the value is false or the implementation does not support
                antialiasing, no antialiasing is performed.
            </dd>
        <dt> <span class=prop-value>premultipliedAlpha</span>
            <dd>
                If the value is true the page compositor will assume the drawing buffer contains
                colors with premultiplied alpha. If the value is false the page compositor will
                assume that colors in the drawing buffer are not premultiplied. This flag is ignored
                if the <strong>alpha</strong> flag is
                false. See <a href="#PREMULTIPLIED_ALPHA">Premultiplied Alpha</a> for more
                information on the effects of the <code>premultipliedAlpha</code> flag.
            </dd>
        <dt> <span class=prop-value>preserveDrawingBuffer</span>
            <dd>
                If false, once the drawing buffer is presented as described in
                the<a href="#THE_DRAWING_BUFFER">Drawing Buffer</a> section, the contents of the
                drawing buffer are cleared to their default values.  All elements of the drawing
                buffer (color, depth and stencil) are cleared.  If the value is true the buffers
                will not be cleared and will preserve their values until cleared or overwritten by
                the author.
                <blockquote>
                <em>
                    On some hardware setting the <code>preserveDrawingBuffer</code> flag 
                    to true can have significant performance implications.
                </em>
                </blockquote>
            </dd>
    </dl>
    <div class="example">
    Here is an ECMAScript example which passes a WebGLContextAttributes argument
    to <code>getContext</code>.  It assumes the presence of a canvas element named "canvas1" on the
    page.

    <pre>
var canvas = document.getElementById('canvas1');
var context = canvas.getContext('webgl',
                                { antialias: false,
                                  stencil: true });
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3>WebGLObject</h3>

    <p>
        The <code>WebGLObject</code> interface is the parent interface for all GL objects.
    </p>
    <p>
        Each <code>WebGLObject</code> has
        an <b><a name="webgl-object-invalidated-flag">invalidated</a></b> flag, which is initially unset.
    </p>
    <pre class="idl">interface <dfn id="WebGLObject">WebGLObject</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLBuffer</h3>

    <p>
        The <code>WebGLBuffer</code> interface represents an OpenGL Buffer Object. The
        underlying object is created as if by calling glGenBuffers 
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenBuffers.xml">man page</a>)</span>
        , bound as if by calling glBindBuffer
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindBuffer.xml">man page</a>)</span>
        and destroyed as if by calling glDeleteBuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteBuffers.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">interface <dfn id="WebGLBuffer">WebGLBuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGL_FRAMEBUFFER">WebGLFramebuffer</a></h3>

    <p>
        The <code>WebGLFramebuffer</code> interface represents an OpenGL Framebuffer Object. The
        underlying object is created as if by calling glGenFramebuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenFramebuffers.xml">man page</a>)</span>
        , bound as if by calling glBindFramebuffer
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindFramebuffer.xml">man page</a>)</span>
        and destroyed as if by calling glDeleteFramebuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteFramebuffers.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">interface <dfn id="WebGLFramebuffer">WebGLFramebuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLProgram</h3>

    <p>
        The <code>WebGLProgram</code> interface represents an OpenGL Program Object. The
        underlying object is created as if by calling glCreateProgram
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateProgram.xml">man page</a>)</span>
        , used as if by calling glUseProgram
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUseProgram.xml">man page</a>)</span>
        and destroyed as if by calling glDeleteProgram
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteProgram.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">interface <dfn id="WebGLProgram">WebGLProgram</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLRenderbuffer</h3>

    <p>
        The <code>WebGLRenderbuffer</code> interface represents an OpenGL Renderbuffer Object. The
        underlying object is created as if by calling glGenRenderbuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenRenderbuffers.xml">man page</a>)</span>
        , bound as if by calling glBindRenderbuffer
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindRenderbuffer.xml">man page</a>)</span>
        and destroyed as if by calling glDeleteRenderbuffers
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteRenderbuffers.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderbuffer">WebGLRenderbuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLShader</h3>

    <p>
        The <code>WebGLShader</code> interface represents an OpenGL Shader Object. The
        underlying object is created as if by calling glCreateShader
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateShader.xml">man page</a>)</span>
        , attached to a Program as if by calling glAttachShader
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glAttachShader.xml">man page</a>)</span>
        and destroyed as if by calling glDeleteShader
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteShader.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">interface <dfn id="WebGLShader">WebGLShader</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLTexture</h3>

    <p>
        The <code>WebGLTexture</code> interface represents an OpenGL Texture Object. The
        underlying object is created as if by calling glGenTextures
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenTextures.xml">man page</a>)</span>
        , bound as if by calling glBindTexture
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindTexture.xml">man page</a>)</span>
        and destroyed as if by calling glDeleteTextures
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteTextures.xml">man page</a>)</span>
        .
    </p>
    <pre class="idl">interface <dfn id="WebGLTexture">WebGLTexture</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLUniformLocation</h3>

    <p>
        The <code>WebGLUniformLocation</code> interface represents the location of a uniform variable 
        in a shader program.
    </p>
    <pre class="idl">interface <dfn id="WebGLUniformLocation">WebGLUniformLocation</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLActiveInfo</h3>

    <p>
        The <code>WebGLActiveInfo</code> interface represents the information returned 
        from the getActiveAttrib and getActiveUniform calls.
    </p>
    <pre class="idl">interface <dfn id="WebGLActiveInfo">WebGLActiveInfo</dfn> {
    readonly attribute GLint size;
    readonly attribute GLenum type;
    readonly attribute DOMString name;
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-size">
                    size
                </a>
            </code> 
            of type <code>GLint</code>
        <dd>
            The size of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-type">
                    type
                </a>
            </code> 
            of type <code>GLenum</code>
        <dd>
            The data type of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-name">
                    name
                </a>
            </code> 
            of type <code>DOMString</code>
        <dd>
            The name of the requested variable.
    </dl>

<!-- ======================================================================================================= -->

    <h3>WebGLShaderPrecisionFormat</h3>

    <p>
        The <code>WebGLShaderPrecisionFormat</code> interface represents the information returned 
        from the getShaderPrecisionFormat call.
    </p>
    <pre class="idl">interface <dfn id="WebGLShaderPrecisionFormat">WebGLShaderPrecisionFormat</dfn> {
    readonly attribute GLint rangeMin;
    readonly attribute GLint rangeMax;
    readonly attribute GLint precision;
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLShaderPrecisionFormat-rangeMin">
                    rangeMin
                </a>
            </code> 
            of type <code>GLint</code>
        <dd>
            The base 2 log of the absolute value of the minimum value that can be represented.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLShaderPrecisionFormat-rangeMax">
                    rangeMax
                </a>
            </code> 
            of type <code>GLint</code>
        <dd>
            The base 2 log of the absolute value of the maximum value that can be represented.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLShaderPrecisionFormat-precision">
                    precision
                </a>
            </code> 
            of type <code>GLint</code>
        <dd>
            The number of bits of precision that can be represented. For integer formats this value
            is always 0.
    </dl>

<!-- ======================================================================================================= -->

    <h3><a name="ARRAYBUFFER">ArrayBuffer</a> and <a name="TYPEDARRAY">Typed Arrays</a></h3>

    <p>
        Vertex, index, texture, and other data is transferred to the WebGL implementation using
        the <a href="../../../typedarray/specs/latest/#ARRAYBUFFER">ArrayBuffer</a>
        and <a href="../../../typedarray/specs/latest/#TYPEDARRAYS">views</a> defined in
        the <a href="../../../typedarray/specs/latest/">Typed Array</a>
        specification <a href="#refsTYPEDARRAYS">[TYPEDARRAYS]</a>.
    </p>
    <p>
        Typed Arrays support the creation of interleaved, heterogeneous vertex data; uploading of
        distinct blocks of data into a large vertex buffer object; and most other use cases required
        by OpenGL programs.
    </p>

    <div class="example">
    Here is an ECMAScript example showing access to the same ArrayBuffer using different types of
    typed arrays. In this case the buffer contains a floating point vertex position (x, y, z)
    followed by a color as 4 unsigned bytes (r, g, b, a).

    <pre>
var numVertices = 100; // for example

// Compute the size needed for the buffer, in bytes and floats
var vertexSize = 3 * Float32Array.BYTES_PER_ELEMENT +
     4 * Uint8Array.BYTES_PER_ELEMENT;
var vertexSizeInFloats = vertexSize / Float32Array.BYTES_PER_ELEMENT;

// Allocate the buffer
var buf = new ArrayBuffer(numVertices * vertexSize);

// Map this buffer to a Float32Array to access the positions
var positionArray = new Float32Array(buf);

// Map the same buffer to a Uint8Array to access the color
var colorArray = new Uint8Array(buf);

// Set up the initial offset of the vertices and colors within the buffer
var positionIdx = 0;
var colorIdx = 3 * Float32Array.BYTES_PER_ELEMENT;

// Initialize the buffer
for (var i = 0; i < numVertices; i++) {
    positionArray[positionIdx] = ...;
    positionArray[positionIdx + 1] = ...;
    positionArray[positionIdx + 2] = ...;
    colorArray[colorIdx] = ...;
    colorArray[colorIdx + 1] = ...;
    colorArray[colorIdx + 2] = ...;
    colorArray[colorIdx + 3] = ...;
    positionIdx += vertexSizeInFloats;
    colorIdx += vertexSize;
}
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLRENDERINGCONTEXT">The WebGL context</a></h3>

    <p>
        The <code>WebGLRenderingContext</code> represents the API allowing
        OpenGL ES 2.0 style rendering into the canvas element.
    </p>
    <p>
        Before performing the implementation of any method of the <code>WebGLRenderingContext</code>
        interface or any method of an interface returned by the <code>getExtension</code> method,
        the following steps must be performed:

        <ol class="nestedlist">

        <li> If the <code>[WebGLHandlesContextLoss]</code> extended attribute appears on the called
        method, perform the implementation of the called method, return its result and terminate
        these steps. </li>

        <li> Let <em>use default return value</em> be false. </li>

        <li> If the <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set,
        let <em>use default return value</em> be true. </li>

        <li> If any argument to the method is a <code>WebGLObject</code> with
        its <a href="#webgl-object-invalidated-flag">invalidated flag</a> set, generate
        an <code>INVALID_OPERATION</code> error and let <em>use default return value</em> be
        true. </li>

        <li> If <em>use default return value</em> is true, perform the following steps:

            <ol class="nestedlist">

            <li> If the return type of the called method is <code>any</code> or any nullable type,
            return null. </li>

            <li> Terminate this algorithm without calling the method implementation. </li>

            </ol>

        <li> Otherwise, perform the implementation of the called method and return its result. </li>

        </ol>
    </p>
    <p>
    See <a href="#CONTEXT_LOST">the context lost event</a> for further details.
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderingContext">WebGLRenderingContext</dfn> {

    /* ClearBufferMask */
    const GLenum DEPTH_BUFFER_BIT               = 0x00000100;
    const GLenum STENCIL_BUFFER_BIT             = 0x00000400;
    const GLenum COLOR_BUFFER_BIT               = 0x00004000;
    
    /* BeginMode */
    const GLenum POINTS                         = 0x0000;
    const GLenum LINES                          = 0x0001;
    const GLenum LINE_LOOP                      = 0x0002;
    const GLenum LINE_STRIP                     = 0x0003;
    const GLenum TRIANGLES                      = 0x0004;
    const GLenum TRIANGLE_STRIP                 = 0x0005;
    const GLenum TRIANGLE_FAN                   = 0x0006;
    
    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* BlendingFactorDest */
    const GLenum ZERO                           = 0;
    const GLenum ONE                            = 1;
    const GLenum SRC_COLOR                      = 0x0300;
    const GLenum ONE_MINUS_SRC_COLOR            = 0x0301;
    const GLenum SRC_ALPHA                      = 0x0302;
    const GLenum ONE_MINUS_SRC_ALPHA            = 0x0303;
    const GLenum DST_ALPHA                      = 0x0304;
    const GLenum ONE_MINUS_DST_ALPHA            = 0x0305;
    
    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    const GLenum DST_COLOR                      = 0x0306;
    const GLenum ONE_MINUS_DST_COLOR            = 0x0307;
    const GLenum SRC_ALPHA_SATURATE             = 0x0308;
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */
    
    /* BlendEquationSeparate */
    const GLenum FUNC_ADD                       = 0x8006;
    const GLenum BLEND_EQUATION                 = 0x8009;
    const GLenum BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
    const GLenum BLEND_EQUATION_ALPHA           = 0x883D;
    
    /* BlendSubtract */
    const GLenum FUNC_SUBTRACT                  = 0x800A;
    const GLenum FUNC_REVERSE_SUBTRACT          = 0x800B;
    
    /* Separate Blend Functions */
    const GLenum BLEND_DST_RGB                  = 0x80C8;
    const GLenum BLEND_SRC_RGB                  = 0x80C9;
    const GLenum BLEND_DST_ALPHA                = 0x80CA;
    const GLenum BLEND_SRC_ALPHA                = 0x80CB;
    const GLenum CONSTANT_COLOR                 = 0x8001;
    const GLenum ONE_MINUS_CONSTANT_COLOR       = 0x8002;
    const GLenum CONSTANT_ALPHA                 = 0x8003;
    const GLenum ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
    const GLenum BLEND_COLOR                    = 0x8005;
    
    /* Buffer Objects */
    const GLenum ARRAY_BUFFER                   = 0x8892;
    const GLenum ELEMENT_ARRAY_BUFFER           = 0x8893;
    const GLenum ARRAY_BUFFER_BINDING           = 0x8894;
    const GLenum ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;
    
    const GLenum STREAM_DRAW                    = 0x88E0;
    const GLenum STATIC_DRAW                    = 0x88E4;
    const GLenum DYNAMIC_DRAW                   = 0x88E8;
    
    const GLenum BUFFER_SIZE                    = 0x8764;
    const GLenum BUFFER_USAGE                   = 0x8765;
    
    const GLenum CURRENT_VERTEX_ATTRIB          = 0x8626;
    
    /* CullFaceMode */
    const GLenum FRONT                          = 0x0404;
    const GLenum BACK                           = 0x0405;
    const GLenum FRONT_AND_BACK                 = 0x0408;
    
    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* EnableCap */
    /* TEXTURE_2D */
    const GLenum CULL_FACE                      = 0x0B44;
    const GLenum BLEND                          = 0x0BE2;
    const GLenum DITHER                         = 0x0BD0;
    const GLenum STENCIL_TEST                   = 0x0B90;
    const GLenum DEPTH_TEST                     = 0x0B71;
    const GLenum SCISSOR_TEST                   = 0x0C11;
    const GLenum POLYGON_OFFSET_FILL            = 0x8037;
    const GLenum SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
    const GLenum SAMPLE_COVERAGE                = 0x80A0;
    
    /* ErrorCode */
    const GLenum NO_ERROR                       = 0;
    const GLenum INVALID_ENUM                   = 0x0500;
    const GLenum INVALID_VALUE                  = 0x0501;
    const GLenum INVALID_OPERATION              = 0x0502;
    const GLenum OUT_OF_MEMORY                  = 0x0505;
    
    /* FrontFaceDirection */
    const GLenum CW                             = 0x0900;
    const GLenum CCW                            = 0x0901;
    
    /* GetPName */
    const GLenum LINE_WIDTH                     = 0x0B21;
    const GLenum ALIASED_POINT_SIZE_RANGE       = 0x846D;
    const GLenum ALIASED_LINE_WIDTH_RANGE       = 0x846E;
    const GLenum CULL_FACE_MODE                 = 0x0B45;
    const GLenum FRONT_FACE                     = 0x0B46;
    const GLenum DEPTH_RANGE                    = 0x0B70;
    const GLenum DEPTH_WRITEMASK                = 0x0B72;
    const GLenum DEPTH_CLEAR_VALUE              = 0x0B73;
    const GLenum DEPTH_FUNC                     = 0x0B74;
    const GLenum STENCIL_CLEAR_VALUE            = 0x0B91;
    const GLenum STENCIL_FUNC                   = 0x0B92;
    const GLenum STENCIL_FAIL                   = 0x0B94;
    const GLenum STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
    const GLenum STENCIL_PASS_DEPTH_PASS        = 0x0B96;
    const GLenum STENCIL_REF                    = 0x0B97;
    const GLenum STENCIL_VALUE_MASK             = 0x0B93;
    const GLenum STENCIL_WRITEMASK              = 0x0B98;
    const GLenum STENCIL_BACK_FUNC              = 0x8800;
    const GLenum STENCIL_BACK_FAIL              = 0x8801;
    const GLenum STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
    const GLenum STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
    const GLenum STENCIL_BACK_REF               = 0x8CA3;
    const GLenum STENCIL_BACK_VALUE_MASK        = 0x8CA4;
    const GLenum STENCIL_BACK_WRITEMASK         = 0x8CA5;
    const GLenum VIEWPORT                       = 0x0BA2;
    const GLenum SCISSOR_BOX                    = 0x0C10;
    /*      SCISSOR_TEST */
    const GLenum COLOR_CLEAR_VALUE              = 0x0C22;
    const GLenum COLOR_WRITEMASK                = 0x0C23;
    const GLenum UNPACK_ALIGNMENT               = 0x0CF5;
    const GLenum PACK_ALIGNMENT                 = 0x0D05;
    const GLenum MAX_TEXTURE_SIZE               = 0x0D33;
    const GLenum MAX_VIEWPORT_DIMS              = 0x0D3A;
    const GLenum SUBPIXEL_BITS                  = 0x0D50;
    const GLenum RED_BITS                       = 0x0D52;
    const GLenum GREEN_BITS                     = 0x0D53;
    const GLenum BLUE_BITS                      = 0x0D54;
    const GLenum ALPHA_BITS                     = 0x0D55;
    const GLenum DEPTH_BITS                     = 0x0D56;
    const GLenum STENCIL_BITS                   = 0x0D57;
    const GLenum POLYGON_OFFSET_UNITS           = 0x2A00;
    /*      POLYGON_OFFSET_FILL */
    const GLenum POLYGON_OFFSET_FACTOR          = 0x8038;
    const GLenum TEXTURE_BINDING_2D             = 0x8069;
    const GLenum SAMPLE_BUFFERS                 = 0x80A8;
    const GLenum SAMPLES                        = 0x80A9;
    const GLenum SAMPLE_COVERAGE_VALUE          = 0x80AA;
    const GLenum SAMPLE_COVERAGE_INVERT         = 0x80AB;
    
    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */
    
    const GLenum COMPRESSED_TEXTURE_FORMATS     = 0x86A3;
    
    /* HintMode */
    const GLenum DONT_CARE                      = 0x1100;
    const GLenum FASTEST                        = 0x1101;
    const GLenum NICEST                         = 0x1102;
    
    /* HintTarget */
    const GLenum GENERATE_MIPMAP_HINT            = 0x8192;
    
    /* DataType */
    const GLenum BYTE                           = 0x1400;
    const GLenum UNSIGNED_BYTE                  = 0x1401;
    const GLenum SHORT                          = 0x1402;
    const GLenum UNSIGNED_SHORT                 = 0x1403;
    const GLenum INT                            = 0x1404;
    const GLenum UNSIGNED_INT                   = 0x1405;
    const GLenum FLOAT                          = 0x1406;
    
    /* PixelFormat */
    const GLenum DEPTH_COMPONENT                = 0x1902;
    const GLenum ALPHA                          = 0x1906;
    const GLenum RGB                            = 0x1907;
    const GLenum RGBA                           = 0x1908;
    const GLenum LUMINANCE                      = 0x1909;
    const GLenum LUMINANCE_ALPHA                = 0x190A;
    
    /* PixelType */
    /*      UNSIGNED_BYTE */
    const GLenum UNSIGNED_SHORT_4_4_4_4         = 0x8033;
    const GLenum UNSIGNED_SHORT_5_5_5_1         = 0x8034;
    const GLenum UNSIGNED_SHORT_5_6_5           = 0x8363;
    
    /* Shaders */
    const GLenum FRAGMENT_SHADER                  = 0x8B30;
    const GLenum VERTEX_SHADER                    = 0x8B31;
    const GLenum MAX_VERTEX_ATTRIBS               = 0x8869;
    const GLenum MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
    const GLenum MAX_VARYING_VECTORS              = 0x8DFC;
    const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
    const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
    const GLenum MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
    const GLenum MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
    const GLenum SHADER_TYPE                      = 0x8B4F;
    const GLenum DELETE_STATUS                    = 0x8B80;
    const GLenum LINK_STATUS                      = 0x8B82;
    const GLenum VALIDATE_STATUS                  = 0x8B83;
    const GLenum ATTACHED_SHADERS                 = 0x8B85;
    const GLenum ACTIVE_UNIFORMS                  = 0x8B86;
    const GLenum ACTIVE_ATTRIBUTES                = 0x8B89;
    const GLenum SHADING_LANGUAGE_VERSION         = 0x8B8C;
    const GLenum CURRENT_PROGRAM                  = 0x8B8D;
    
    /* StencilFunction */
    const GLenum NEVER                          = 0x0200;
    const GLenum LESS                           = 0x0201;
    const GLenum EQUAL                          = 0x0202;
    const GLenum LEQUAL                         = 0x0203;
    const GLenum GREATER                        = 0x0204;
    const GLenum NOTEQUAL                       = 0x0205;
    const GLenum GEQUAL                         = 0x0206;
    const GLenum ALWAYS                         = 0x0207;
    
    /* StencilOp */
    /*      ZERO */
    const GLenum KEEP                           = 0x1E00;
    const GLenum REPLACE                        = 0x1E01;
    const GLenum INCR                           = 0x1E02;
    const GLenum DECR                           = 0x1E03;
    const GLenum INVERT                         = 0x150A;
    const GLenum INCR_WRAP                      = 0x8507;
    const GLenum DECR_WRAP                      = 0x8508;
    
    /* StringName */
    const GLenum VENDOR                         = 0x1F00;
    const GLenum RENDERER                       = 0x1F01;
    const GLenum VERSION                        = 0x1F02;
    
    /* TextureMagFilter */
    const GLenum NEAREST                        = 0x2600;
    const GLenum LINEAR                         = 0x2601;
    
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    const GLenum NEAREST_MIPMAP_NEAREST         = 0x2700;
    const GLenum LINEAR_MIPMAP_NEAREST          = 0x2701;
    const GLenum NEAREST_MIPMAP_LINEAR          = 0x2702;
    const GLenum LINEAR_MIPMAP_LINEAR           = 0x2703;
    
    /* TextureParameterName */
    const GLenum TEXTURE_MAG_FILTER             = 0x2800;
    const GLenum TEXTURE_MIN_FILTER             = 0x2801;
    const GLenum TEXTURE_WRAP_S                 = 0x2802;
    const GLenum TEXTURE_WRAP_T                 = 0x2803;
    
    /* TextureTarget */
    const GLenum TEXTURE_2D                     = 0x0DE1;
    const GLenum TEXTURE                        = 0x1702;
    
    const GLenum TEXTURE_CUBE_MAP               = 0x8513;
    const GLenum TEXTURE_BINDING_CUBE_MAP       = 0x8514;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
    const GLenum MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;
    
    /* TextureUnit */
    const GLenum TEXTURE0                       = 0x84C0;
    const GLenum TEXTURE1                       = 0x84C1;
    const GLenum TEXTURE2                       = 0x84C2;
    const GLenum TEXTURE3                       = 0x84C3;
    const GLenum TEXTURE4                       = 0x84C4;
    const GLenum TEXTURE5                       = 0x84C5;
    const GLenum TEXTURE6                       = 0x84C6;
    const GLenum TEXTURE7                       = 0x84C7;
    const GLenum TEXTURE8                       = 0x84C8;
    const GLenum TEXTURE9                       = 0x84C9;
    const GLenum TEXTURE10                      = 0x84CA;
    const GLenum TEXTURE11                      = 0x84CB;
    const GLenum TEXTURE12                      = 0x84CC;
    const GLenum TEXTURE13                      = 0x84CD;
    const GLenum TEXTURE14                      = 0x84CE;
    const GLenum TEXTURE15                      = 0x84CF;
    const GLenum TEXTURE16                      = 0x84D0;
    const GLenum TEXTURE17                      = 0x84D1;
    const GLenum TEXTURE18                      = 0x84D2;
    const GLenum TEXTURE19                      = 0x84D3;
    const GLenum TEXTURE20                      = 0x84D4;
    const GLenum TEXTURE21                      = 0x84D5;
    const GLenum TEXTURE22                      = 0x84D6;
    const GLenum TEXTURE23                      = 0x84D7;
    const GLenum TEXTURE24                      = 0x84D8;
    const GLenum TEXTURE25                      = 0x84D9;
    const GLenum TEXTURE26                      = 0x84DA;
    const GLenum TEXTURE27                      = 0x84DB;
    const GLenum TEXTURE28                      = 0x84DC;
    const GLenum TEXTURE29                      = 0x84DD;
    const GLenum TEXTURE30                      = 0x84DE;
    const GLenum TEXTURE31                      = 0x84DF;
    const GLenum ACTIVE_TEXTURE                 = 0x84E0;
    
    /* TextureWrapMode */
    const GLenum REPEAT                         = 0x2901;
    const GLenum CLAMP_TO_EDGE                  = 0x812F;
    const GLenum MIRRORED_REPEAT                = 0x8370;
    
    /* Uniform Types */
    const GLenum FLOAT_VEC2                     = 0x8B50;
    const GLenum FLOAT_VEC3                     = 0x8B51;
    const GLenum FLOAT_VEC4                     = 0x8B52;
    const GLenum INT_VEC2                       = 0x8B53;
    const GLenum INT_VEC3                       = 0x8B54;
    const GLenum INT_VEC4                       = 0x8B55;
    const GLenum BOOL                           = 0x8B56;
    const GLenum BOOL_VEC2                      = 0x8B57;
    const GLenum BOOL_VEC3                      = 0x8B58;
    const GLenum BOOL_VEC4                      = 0x8B59;
    const GLenum FLOAT_MAT2                     = 0x8B5A;
    const GLenum FLOAT_MAT3                     = 0x8B5B;
    const GLenum FLOAT_MAT4                     = 0x8B5C;
    const GLenum SAMPLER_2D                     = 0x8B5E;
    const GLenum SAMPLER_CUBE                   = 0x8B60;
    
    /* Vertex Arrays */
    const GLenum VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
    const GLenum VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
    const GLenum VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
    const GLenum VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
    const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
    const GLenum VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
    const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
    
    /* Shader Source */
    const GLenum COMPILE_STATUS                 = 0x8B81;
    
    /* Shader Precision-Specified Types */
    const GLenum LOW_FLOAT                      = 0x8DF0;
    const GLenum MEDIUM_FLOAT                   = 0x8DF1;
    const GLenum HIGH_FLOAT                     = 0x8DF2;
    const GLenum LOW_INT                        = 0x8DF3;
    const GLenum MEDIUM_INT                     = 0x8DF4;
    const GLenum HIGH_INT                       = 0x8DF5;
    
    /* Framebuffer Object. */
    const GLenum FRAMEBUFFER                    = 0x8D40;
    const GLenum RENDERBUFFER                   = 0x8D41;
    
    const GLenum RGBA4                          = 0x8056;
    const GLenum RGB5_A1                        = 0x8057;
    const GLenum RGB565                         = 0x8D62;
    const GLenum DEPTH_COMPONENT16              = 0x81A5;
    const GLenum STENCIL_INDEX                  = 0x1901;
    const GLenum STENCIL_INDEX8                 = 0x8D48;
    const GLenum DEPTH_STENCIL                  = 0x84F9;
    
    const GLenum RENDERBUFFER_WIDTH             = 0x8D42;
    const GLenum RENDERBUFFER_HEIGHT            = 0x8D43;
    const GLenum RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
    const GLenum RENDERBUFFER_RED_SIZE          = 0x8D50;
    const GLenum RENDERBUFFER_GREEN_SIZE        = 0x8D51;
    const GLenum RENDERBUFFER_BLUE_SIZE         = 0x8D52;
    const GLenum RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
    const GLenum RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
    const GLenum RENDERBUFFER_STENCIL_SIZE      = 0x8D55;
    
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
    
    const GLenum COLOR_ATTACHMENT0              = 0x8CE0;
    const GLenum DEPTH_ATTACHMENT               = 0x8D00;
    const GLenum STENCIL_ATTACHMENT             = 0x8D20;
    const GLenum DEPTH_STENCIL_ATTACHMENT       = 0x821A;
    
    const GLenum NONE                           = 0;
    
    const GLenum FRAMEBUFFER_COMPLETE                      = 0x8CD5;
    const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
    const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
    const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
    const GLenum FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;
    
    const GLenum FRAMEBUFFER_BINDING            = 0x8CA6;
    const GLenum RENDERBUFFER_BINDING           = 0x8CA7;
    const GLenum MAX_RENDERBUFFER_SIZE          = 0x84E8;
    
    const GLenum INVALID_FRAMEBUFFER_OPERATION  = 0x0506;
    
    /* WebGL-specific enums */
    const GLenum UNPACK_FLIP_Y_WEBGL            = 0x9240;
    const GLenum UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
    const GLenum CONTEXT_LOST_WEBGL             = 0x9242;
    const GLenum UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
    const GLenum BROWSER_DEFAULT_WEBGL          = 0x9244;

    readonly attribute HTMLCanvasElement canvas;
    readonly attribute GLsizei drawingBufferWidth;
    readonly attribute GLsizei drawingBufferHeight;

    [WebGLHandlesContextLoss] WebGLContextAttributes? getContextAttributes();
    [WebGLHandlesContextLoss] boolean isContextLost();
    
    sequence&lt;DOMString&gt;? getSupportedExtensions();
    object? getExtension(DOMString name);

    void activeTexture(GLenum texture);
    void attachShader(WebGLProgram? program, WebGLShader? shader);
    void bindAttribLocation(WebGLProgram? program, GLuint index, DOMString name);
    void bindBuffer(GLenum target, WebGLBuffer? buffer);
    void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer);
    void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer);
    void bindTexture(GLenum target, WebGLTexture? texture);
    void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void blendEquation(GLenum mode);
    void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
    void blendFunc(GLenum sfactor, GLenum dfactor);
    void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, 
                           GLenum srcAlpha, GLenum dstAlpha);

    void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
    void bufferData(GLenum target, ArrayBufferView data, GLenum usage);
    void bufferData(GLenum target, ArrayBuffer? data, GLenum usage);
    void bufferSubData(GLenum target, GLintptr offset, ArrayBufferView data);
    void bufferSubData(GLenum target, GLintptr offset, ArrayBuffer? data);

    [WebGLHandlesContextLoss] GLenum checkFramebufferStatus(GLenum target);
    void clear(GLbitfield mask);
    void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void clearDepth(GLclampf depth);
    void clearStencil(GLint s);
    void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
    void compileShader(WebGLShader? shader);

    void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat,
                              GLsizei width, GLsizei height, GLint border,
                              ArrayBufferView data);
    void compressedTexSubImage2D(GLenum target, GLint level,
                                 GLint xoffset, GLint yoffset,
                                 GLsizei width, GLsizei height, GLenum format,
                                 ArrayBufferView data);

    void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, 
                        GLint x, GLint y, GLsizei width, GLsizei height, 
                        GLint border);
    void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                           GLint x, GLint y, GLsizei width, GLsizei height);

    WebGLBuffer? createBuffer();
    WebGLFramebuffer? createFramebuffer();
    WebGLProgram? createProgram();
    WebGLRenderbuffer? createRenderbuffer();
    WebGLShader? createShader(GLenum type);
    WebGLTexture? createTexture();

    void cullFace(GLenum mode);

    void deleteBuffer(WebGLBuffer? buffer);
    void deleteFramebuffer(WebGLFramebuffer? framebuffer);
    void deleteProgram(WebGLProgram? program);
    void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer);
    void deleteShader(WebGLShader? shader);
    void deleteTexture(WebGLTexture? texture);

    void depthFunc(GLenum func);
    void depthMask(GLboolean flag);
    void depthRange(GLclampf zNear, GLclampf zFar);
    void detachShader(WebGLProgram? program, WebGLShader? shader);
    void disable(GLenum cap);
    void disableVertexAttribArray(GLuint index);
    void drawArrays(GLenum mode, GLint first, GLsizei count);
    void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset);

    void enable(GLenum cap);
    void enableVertexAttribArray(GLuint index);
    void finish();
    void flush();
    void framebufferRenderbuffer(GLenum target, GLenum attachment, 
                                 GLenum renderbuffertarget, 
                                 WebGLRenderbuffer? renderbuffer);
    void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, 
                              WebGLTexture? texture, GLint level);
    void frontFace(GLenum mode);

    void generateMipmap(GLenum target);

    WebGLActiveInfo? getActiveAttrib(WebGLProgram? program, GLuint index);
    WebGLActiveInfo? getActiveUniform(WebGLProgram? program, GLuint index);
    sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram? program);

    [WebGLHandlesContextLoss] GLint getAttribLocation(WebGLProgram? program, DOMString name);

    any getBufferParameter(GLenum target, GLenum pname);
    any getParameter(GLenum pname);

    [WebGLHandlesContextLoss] GLenum getError();

    any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, 
                                          GLenum pname);
    any getProgramParameter(WebGLProgram? program, GLenum pname);
    DOMString? getProgramInfoLog(WebGLProgram? program);
    any getRenderbufferParameter(GLenum target, GLenum pname);
    any getShaderParameter(WebGLShader? shader, GLenum pname);
    WebGLShaderPrecisionFormat? getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype);
    DOMString? getShaderInfoLog(WebGLShader? shader);

    DOMString? getShaderSource(WebGLShader? shader);

    any getTexParameter(GLenum target, GLenum pname);

    any getUniform(WebGLProgram? program, WebGLUniformLocation? location);

    WebGLUniformLocation? getUniformLocation(WebGLProgram? program, DOMString name);

    any getVertexAttrib(GLuint index, GLenum pname);

    [WebGLHandlesContextLoss] GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname);

    void hint(GLenum target, GLenum mode);
    [WebGLHandlesContextLoss] GLboolean isBuffer(WebGLBuffer? buffer);
    [WebGLHandlesContextLoss] GLboolean isEnabled(GLenum cap);
    [WebGLHandlesContextLoss] GLboolean isFramebuffer(WebGLFramebuffer? framebuffer);
    [WebGLHandlesContextLoss] GLboolean isProgram(WebGLProgram? program);
    [WebGLHandlesContextLoss] GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer);
    [WebGLHandlesContextLoss] GLboolean isShader(WebGLShader? shader);
    [WebGLHandlesContextLoss] GLboolean isTexture(WebGLTexture? texture);
    void lineWidth(GLfloat width);
    void linkProgram(WebGLProgram? program);
    void pixelStorei(GLenum pname, GLint param);
    void polygonOffset(GLfloat factor, GLfloat units);

    void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                    GLenum format, GLenum type, ArrayBufferView? pixels);

    void renderbufferStorage(GLenum target, GLenum internalformat, 
                             GLsizei width, GLsizei height);
    void sampleCoverage(GLclampf value, GLboolean invert);
    void scissor(GLint x, GLint y, GLsizei width, GLsizei height);

    void shaderSource(WebGLShader? shader, DOMString source);

    void stencilFunc(GLenum func, GLint ref, GLuint mask);
    void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
    void stencilMask(GLuint mask);
    void stencilMaskSeparate(GLenum face, GLuint mask);
    void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
    void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);

    void texImage2D(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, GLenum format, 
                    GLenum type, ArrayBufferView? pixels);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, ImageData? pixels);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLImageElement image); // May throw DOMException
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLCanvasElement canvas); // May throw DOMException
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLVideoElement video); // May throw DOMException

    void texParameterf(GLenum target, GLenum pname, GLfloat param);
    void texParameteri(GLenum target, GLenum pname, GLint param);

    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLsizei width, GLsizei height, 
                       GLenum format, GLenum type, ArrayBufferView? pixels);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, ImageData? pixels);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLImageElement image); // May throw DOMException
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLCanvasElement canvas); // May throw DOMException
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLVideoElement video); // May throw DOMException

    void uniform1f(WebGLUniformLocation? location, GLfloat x);
    void uniform1fv(WebGLUniformLocation? location, Float32Array v);
    void uniform1fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform1i(WebGLUniformLocation? location, GLint x);
    void uniform1iv(WebGLUniformLocation? location, Int32Array v);
    void uniform1iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
    void uniform2f(WebGLUniformLocation? location, GLfloat x, GLfloat y);
    void uniform2fv(WebGLUniformLocation? location, Float32Array v);
    void uniform2fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform2i(WebGLUniformLocation? location, GLint x, GLint y);
    void uniform2iv(WebGLUniformLocation? location, Int32Array v);
    void uniform2iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
    void uniform3f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z);
    void uniform3fv(WebGLUniformLocation? location, Float32Array v);
    void uniform3fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform3i(WebGLUniformLocation? location, GLint x, GLint y, GLint z);
    void uniform3iv(WebGLUniformLocation? location, Int32Array v);
    void uniform3iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
    void uniform4f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void uniform4fv(WebGLUniformLocation? location, Float32Array v);
    void uniform4fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
    void uniform4i(WebGLUniformLocation? location, GLint x, GLint y, GLint z, GLint w);
    void uniform4iv(WebGLUniformLocation? location, Int32Array v);
    void uniform4iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);

    void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, 
                          sequence&lt;GLfloat&gt; value);
    void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, 
                          sequence&lt;GLfloat&gt; value);
    void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, 
                          sequence&lt;GLfloat&gt; value);

    void useProgram(WebGLProgram? program);
    void validateProgram(WebGLProgram? program);

    void vertexAttrib1f(GLuint indx, GLfloat x);
    void vertexAttrib1fv(GLuint indx, Float32Array values);
    void vertexAttrib1fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
    void vertexAttrib2fv(GLuint indx, Float32Array values);
    void vertexAttrib2fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
    void vertexAttrib3fv(GLuint indx, Float32Array values);
    void vertexAttrib3fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void vertexAttrib4fv(GLuint indx, Float32Array values);
    void vertexAttrib4fv(GLuint indx, sequence&lt;GLfloat&gt; values);
    void vertexAttribPointer(GLuint indx, GLint size, GLenum type, 
                             GLboolean normalized, GLsizei stride, GLintptr offset);

    void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
};</pre>

<!-- ======================================================================================================= -->

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-canvas">
                    canvas
                </a>
            </code> 
            of type <code>HTMLCanvasElement</code>
        <dd>
            A reference to the canvas element which created this context.

        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-drawingBufferWidth">
                    drawingBufferWidth
                </a>
            </code> 
            of type <code>GLsizei</code>
        <dd>
            The actual width of the drawing buffer. May be different from the 
            <code>width</code> attribute of the <code>HTMLCanvasElement</code> if 
            the implementation is unable to satisfy the requested widthor height.
            
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-drawingBufferHeight">
                    drawingBufferHeight
                </a>
            </code> 
            of type <code>GLsizei</code>
        <dd>
            The actual height of the drawing buffer. May be different from the 
            <code>height</code> attribute of the <code>HTMLCanvasElement</code> if 
            the implementation is unable to satisfy the requested width or height.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Getting information about the context</h4>

    <dl class="methods">
        <dt class="idl-code">[WebGLHandlesContextLoss] WebGLContextAttributes? getContextAttributes()
        <dd>
            If the <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set, returns
            null. Otherwise, returns a copy of the <a href="#actual-context-parameters">actual
            context parameters</a>.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Setting and getting state</h4>

    <p>
        OpenGL ES 2.0 maintains state values for use in rendering. All the calls in this
        group behave identically to their OpenGL counterparts unless otherwise noted.
    </p>
    
    <dl class="methods">
        <dt class="idl-code">void activeTexture(GLenum texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7">OpenGL ES 2.0 &sect;3.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glActiveTexture.xml">man page</a>)</span>
        <dt class="idl-code">void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendColor.xml">man page</a>)</span>
        <dt class="idl-code">void blendEquation(GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendEquation.xml">man page</a>)</span>
        <dt class="idl-code">void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendEquationSeparate.xml">man page</a>)</span>
        <dt class="idl-code">void blendFunc(GLenum sfactor, GLenum dfactor)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendFunc.xml">man page</a>)</span>
            <dd>
                See <a href="#CONSTANT_COLOR_BLEND">Blending With Constant Color</a> for limitations imposed
                by WebGL.
        <dt class="idl-code">void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES 2.0 &sect;4.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendFuncSeparate.xml">man page</a>)</span>
            <dd>
                See <a href="#CONSTANT_COLOR_BLEND">Blending With Constant Color</a> for limitations imposed
                by WebGL.
        <dt class="idl-code">void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearColor.xml">man page</a>)</span>
        <dt class="idl-code">void clearDepth(GLclampf depth)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearDepthf.xml">man page</a>)</span>
            <dd>
                <code>depth</code> value is clamped to the range 0 to 1.
        <dt class="idl-code">void clearStencil(GLint s)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearStencil.xml">man page</a>)</span>
        <dt class="idl-code">void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glColorMask.xml">man page</a>)</span>
        <dt class="idl-code">void cullFace(GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.1">OpenGL ES 2.0 &sect;3.5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCullFace.xml">man page</a>)</span>
        <dt class="idl-code">void depthFunc(GLenum func)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.5">OpenGL ES 2.0 &sect;4.1.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthFunc.xml">man page</a>)</span>
        <dt class="idl-code">void depthMask(GLboolean flag)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthMask.xml">man page</a>)</span>
        <dt class="idl-code">void depthRange(GLclampf zNear, GLclampf zFar)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.12.1">OpenGL ES 2.0 &sect;2.12.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthRangef.xml">man page</a>)</span>
            <dd>
                <code>zNear</code> and <code>zFar</code> values are clamped to the range 0 to 1 and
                <code>zNear</code> must be less than or equal to <code>zFar</code>; see
                <a href="#VIEWPORT_DEPTH_RANGE">Viewport Depth Range</a>.
        <dt class="idl-code">void disable(GLenum cap)
            <span class="gl-spec">(<a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDisable.xml">man page</a>)</span>
        <dt class="idl-code">void enable(GLenum cap)
            <span class="gl-spec">(<a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glEnable.xml">man page</a>)</span>
        <dt class="idl-code">void frontFace(GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.1">OpenGL ES 2.0 &sect;3.5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFrontFace.xml">man page</a>)</span>
        <dt class="idl-code"><a name="GETPARAMETER">any getParameter</a>(GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGet.xml">
                (glGet OpenGL ES 2.0 man page)
            </a>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetString.xml">
                (glGetString OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>ACTIVE_TEXTURE</td><td>unsigned long</td></tr>
                <tr><td>ALIASED_LINE_WIDTH_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ALIASED_POINT_SIZE_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ALPHA_BITS</td><td>long</td></tr>
                <tr><td>ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>BLEND</td><td>boolean</td></tr>
                <tr><td>BLEND_COLOR</td><td>Float32Array (with 4 values)</td></tr>
                <tr><td>BLEND_DST_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_DST_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLUE_BITS</td><td>long</td></tr>
                <tr><td>COLOR_CLEAR_VALUE</td><td>Float32Array (with 4 values)</td></tr>
                <tr><td>COLOR_WRITEMASK</td><td>sequence&lt;boolean&gt; (with 4 values)</td></tr>
                <tr><td>COMPRESSED_TEXTURE_FORMATS</td><td>Uint32Array</td></tr>
                <tr><td>CULL_FACE</td><td>boolean</td></tr>
                <tr><td>CULL_FACE_MODE</td><td>unsigned long</td></tr>
                <tr><td>CURRENT_PROGRAM</td><td>WebGLProgram</td></tr>
                <tr><td>DEPTH_BITS</td><td>long</td></tr>
                <tr><td>DEPTH_CLEAR_VALUE</td><td>float</td></tr>
                <tr><td>DEPTH_FUNC</td><td>unsigned long</td></tr>
                <tr><td>DEPTH_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>DEPTH_TEST</td><td>boolean</td></tr>
                <tr><td>DEPTH_WRITEMASK</td><td>boolean</td></tr>
                <tr><td>DITHER</td><td>boolean</td></tr>
                <tr><td>ELEMENT_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>FRONT_FACE</td><td>unsigned long</td></tr>
                <tr><td>GENERATE_MIPMAP_HINT</td><td>unsigned long</td></tr>
                <tr><td>GREEN_BITS</td><td>long</td></tr>
                <tr><td>LINE_WIDTH</td><td>float</td></tr>
                <tr><td>MAX_COMBINED_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_CUBE_MAP_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_RENDERBUFFER_SIZE</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_VARYING_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_ATTRIBS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VIEWPORT_DIMS</td><td>Int32Array (with 2 elements)</td></tr>
                <tr><td>PACK_ALIGNMENT</td><td>long</td></tr>
                <tr><td>POLYGON_OFFSET_FACTOR</td><td>float</td></tr>
                <tr><td>POLYGON_OFFSET_FILL</td><td>boolean</td></tr>
                <tr><td>POLYGON_OFFSET_UNITS</td><td>float</td></tr>
                <tr><td>RED_BITS</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BINDING</td><td>WebGLRenderbuffer</td></tr>
                <tr><td>RENDERER</td><td>DOMString</td></tr>
                <tr><td>SAMPLE_BUFFERS</td><td>long</td></tr>
                <tr><td>SAMPLE_COVERAGE_INVERT</td><td>boolean</td></tr>
                <tr><td>SAMPLE_COVERAGE_VALUE</td><td>float</td></tr>
                <tr><td>SAMPLES</td><td>long</td></tr>
                <tr><td>SCISSOR_BOX</td><td>Int32Array (with 4 elements)</td></tr>
                <tr><td>SCISSOR_TEST</td><td>boolean</td></tr>
                <tr><td>SHADING_LANGUAGE_VERSION</td><td>DOMString</td></tr>
                <tr><td>STENCIL_BACK_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_REF</td><td>long</td></tr>
                <tr><td>STENCIL_BACK_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BITS</td><td>long</td></tr>
                <tr><td>STENCIL_CLEAR_VALUE</td><td>long</td></tr>
                <tr><td>STENCIL_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_REF</td><td>long</td></tr>
                <tr><td>STENCIL_TEST</td><td>boolean</td></tr>
                <tr><td>STENCIL_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>SUBPIXEL_BITS</td><td>long</td></tr>
                <tr><td>TEXTURE_BINDING_2D</td><td>WebGLTexture</td></tr>
                <tr><td>TEXTURE_BINDING_CUBE_MAP</td><td>WebGLTexture</td></tr>
                <tr><td>UNPACK_ALIGNMENT</td><td>long</td></tr>
                <tr><td>UNPACK_COLORSPACE_CONVERSION_WEBGL</td><td>unsigned long</td></tr>
                <tr><td>UNPACK_FLIP_Y_WEBGL</td><td>boolean</td></tr>
                <tr><td>UNPACK_PREMULTIPLY_ALPHA_WEBGL</td><td>boolean</td></tr>
                <tr><td>VENDOR</td><td>DOMString</td></tr>
                <tr><td>VERSION</td><td>DOMString</td></tr>
                <tr><td>VIEWPORT</td><td>Int32Array (with 4 elements)</td></tr>
            </table><br>
            <p>All queries returning sequences or typed arrays return a new object each time.</p>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
            <p>The following <em>pname</em> arguments return a string describing some aspect of the current WebGL implementation:</p>
            <table>
              <tr><td>VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;1.0&lt;space&gt;&lt;vendor-specific information&gt;</code>.</td></tr>
              <tr><td>SHADING_LANGUAGE_VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;1.0&lt;space&gt;&lt;vendor-specific information&gt;</code>.</td></tr>
              <tr><td>VENDOR</td>
                  <td>Returns the company responsible for this WebGL implementation. This name does not change from release to release.</td></tr>
              <tr><td>RENDERER</td>
                  <td>Returns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.</td></tr>
            </table><br>
            <p>See <a href="#EXTENSION_QUERIES">Extension Queries</a> for information on querying the
            available extensions in the current WebGL implementation.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLenum getError()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.5">OpenGL ES 2.0 &sect;2.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetError.xml">man page</a>)</span>
            <dd>
                If the context's <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set,
                returns <code class="enum">CONTEXT_LOST_WEBGL</code> the first time this method is
                called. Afterward, returns <code class="enum">NO_ERROR</code> until the context has
                been restored.
        <dt class="idl-code">void hint(GLenum target, GLenum mode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.2">OpenGL ES 2.0 &sect;5.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glHint.xml">man page</a>)</span>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isEnabled(GLenum cap)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.1">OpenGL ES 2.0 &sect;6.1.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsEnabled.xml">man page</a>)</span>
        <dd>
            Returns false if the context's <a href="#webgl-context-lost-flag">webgl context lost
            flag</a> is set.
        <dt class="idl-code">void lineWidth(GLfloat width)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.4">OpenGL ES 2.0 &sect;3.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glLineWidth.xml">man page</a>)</span>
        <dt class="idl-code">void pixelStorei(GLenum pname, GLint param)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.6.1">OpenGL ES 2.0 &sect;3.6.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glPixelStorei.xml">man page</a>)</span>
            <dd>
                In addition to the parameters in the OpenGL ES 2.0 specification, the WebGL
                specification accepts the parameters <code>UNPACK_FLIP_Y_WEBGL</code>,
                <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>
                and <code>UNPACK_COLORSPACE_CONVERSION_WEBGL</code>. See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel
                Storage Parameters</a> for documentation of these parameters.
        <dt class="idl-code">void polygonOffset(GLfloat factor, GLfloat units)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.2">OpenGL ES 2.0 &sect;3.5.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glPolygonOffset.xml">man page</a>)</span>
        <dt class="idl-code">void sampleCoverage(GLclampf value, GLboolean invert)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.3">OpenGL ES 2.0 &sect;4.1.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glSampleCoverage.xml">man page</a>)</span>
        <dt class="idl-code">void stencilFunc(GLenum func, GLint ref, GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilFunc.xml">man page</a>)</span>
        <dt class="idl-code">void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilFuncSeparate.xml">man page</a>)</span>
            <dd>
                See <a href="#STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a> for information
                on WebGL specific limitations to the allowable argument values.
        <dt class="idl-code">void stencilMask(GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilMask.xml">man page</a>)</span>
            <dd>
                See <a href="#STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a> for information
                on WebGL specific limitations to the allowable mask values.
        <dt class="idl-code">void stencilMaskSeparate(GLenum face, GLuint mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES 2.0 &sect;4.2.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilMaskSeparate.xml">man page</a>)</span>
        <dt class="idl-code">void stencilOp(GLenum fail, GLenum zfail, GLenum zpass)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilOp.xml">man page</a>)</span>
        <dt class="idl-code">void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES 2.0 &sect;4.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilOpSeparate.xml">man page</a>)</span>
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Viewing and clipping</h4>

    <p>
        The viewport specifies the affine transformation of x and y from normalized device 
        coordinates to window coordinates. The size of the drawing buffer is determined by 
        the HTMLCanvasElement. The scissor box defines a rectangle which constrains drawing.
        When the scissor test is enabled only pixels that lie within  the scissor box can 
        be modified by drawing commands. When enabled drawing can only occur inside the 
        intersection of the viewport, canvas area and the scissor box. When the scissor test
        is not enabled drawing can only occur inside the intersection of the viewport and 
        canvas area.
    </p>

    <dl class="methods">
        <dt class="idl-code">void scissor(GLint x, GLint y, GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.2">OpenGL ES 2.0 &sect;4.1.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glScissor.xml">man page</a>)</span>
            
        <dt class="idl-code">void viewport(GLint x, GLint y, GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.12.1">OpenGL ES 2.0 &sect;2.12.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glViewport.xml">man page</a>)</span>
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Buffer objects</h4>

    <p>
        Buffer objects (sometimes referred to as VBOs) hold vertex attribute data for the GLSL
        shaders.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindBuffer(GLenum target, WebGLBuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindBuffer.xml">man page</a>)</span>
        <dd>
            Binds the given WebGLBuffer object to the given binding point (target), either
            ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER. If the buffer is null then any buffer currently
            bound to this target is unbound. A given WebGLBuffer object may only be bound to one of
            the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime. An attempt to bind a
            buffer object to the other target will generate an <code>INVALID_OPERATION</code> error, and the
            current binding will remain untouched.
        
        <dt class="idl-code">void bufferData(GLenum target, GLsizeiptr size, GLenum usage)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferData.xml">man page</a>)</span>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target. The
            buffer is initialized to 0.
            
        <dt><p class="idl-code">void bufferData(GLenum target, ArrayBufferView data, GLenum usage)</p>
            <p class="idl-code">void bufferData(GLenum target, ArrayBuffer? data, GLenum usage)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferData.xml">man page</a>)</span></p>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target to the 
            size of the passed data, then write the contents of data to the buffer object.
            <br><br>
            If the passed data is null then an <code>INVALID_VALUE</code> error is generated.
        <dt><p class="idl-code">void bufferSubData(GLenum target, GLintptr offset, ArrayBufferView data)</p>
            <p class="idl-code">void bufferSubData(GLenum target, GLintptr offset, ArrayBuffer? data)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferSubData.xml">man page</a>)</span></p>
        <dd>
            For the WebGLBuffer object bound to the passed target write the passed data starting at
            the passed offset. If the data would be written past the end of the buffer object
            an <code>INVALID_VALUE</code> error is generated. If <code>data</code> is null then
            an <code>INVALID_VALUE</code> error is generated.
            
        <dt class="idl-code">WebGLBuffer? createBuffer()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenBuffers.xml">glGenBuffers</a>)</span>
        <dd>
            Create a WebGLBuffer object and initialize it with a buffer object name as if by
            calling glGenBuffers.
            
        <dt class="idl-code">void deleteBuffer(WebGLBuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES 2.0 &sect;2.9</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteBuffers.xml">glDeleteBuffers</a>)</span>
        <dd>
            Delete the buffer object contained in the passed WebGLBuffer as if by calling
            glDeleteBuffers. If the buffer has already been deleted the call has no effect.
            Note that the buffer object will be deleted when the WebGLBuffer object is destroyed.
            This method merely gives the author greater control over when the buffer object is
            destroyed.

        <dt class="idl-code">any getBufferParameter(GLenum target, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetBufferParameteriv.xml">glGetBufferParameteriv</a>)</span>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>BUFFER_SIZE</td><td>long</td></tr>
                <tr><td>BUFFER_USAGE</td><td>unsigned long</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isBuffer(WebGLBuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.6">OpenGL ES 2.0 &sect;6.1.6</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsBuffer.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLBuffer is valid and false otherwise. <br><br>

            Returns false if the buffer's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Framebuffer objects</h4>

    <p>
        Framebuffer objects provide an alternative rendering target to the drawing buffer. They
        are a collection of color, alpha, depth and stencil buffers and are often used to 
        render an image that will later be used as a texture.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindFramebuffer.xml">man page</a>)</span>
        <dd>
            Bind the given <code class="interface">WebGLFramebuffer</code> object to the given binding point
            (<code class="param">target</code>), which must be <code class="enum">FRAMEBUFFER</code>.
            If <code class="param">framebuffer</code> is null, the default framebuffer provided by the context
            is bound and attempts to modify or query state on <code class="param">target</code> <code class="enum">FRAMEBUFFER</code>
            will generate an <code class="error">INVALID_OPERATION</code> error.

        <dt class="idl-code">[WebGLHandlesContextLoss] GLenum checkFramebufferStatus(GLenum target)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.5">OpenGL ES 2.0 &sect;4.4.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCheckFramebufferStatus.xml">man page</a>)</span>
        <dd>
            Returns <code class="enum">FRAMEBUFFER_UNSUPPORTED</code> if the
            context's <a href="#webgl-context-lost-flag">webgl context lost flag</a> is set.

        <dt class="idl-code">WebGLFramebuffer? createFramebuffer()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenFramebuffers.xml">glGenFramebuffers</a>)</span>
        <dd>
            Create a WebGLFramebuffer object and initialize it with a framebuffer object name as if by
            calling glGenFramebuffers.
            
        <dt class="idl-code">void deleteFramebuffer(WebGLFramebuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES 2.0 &sect;4.4.1</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteFramebuffers.xml">glDeleteFramebuffers</a>)</span>
        <dd>
            Delete the framebuffer object contained in the passed WebGLFramebuffer as if by calling
            glDeleteFramebuffers. If the framebuffer has already been deleted the call has no effect.
            Note that the framebuffer object will be deleted when the WebGLFramebuffer object is destroyed.
            This method merely gives the author greater control over when the framebuffer object is
            destroyed.

        <dt class="idl-code">void framebufferRenderbuffer(GLenum target, GLenum attachment, 
                                 GLenum renderbuffertarget, 
                                 WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFramebufferRenderbuffer.xml">man page</a>)</span></dt>
        <dt class="idl-code">void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, 
                              WebGLTexture? texture, GLint level)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFramebufferTexture2D.xml">man page</a>)</span>
        <dt class="idl-code">any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, 
                                          GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetFramebufferAttachmentParameteriv.xml">glGetFramebufferAttachmentParameteriv</a>)</span>
        <dd>
            Return the value for the passed pname given the passed target and attachment. The type 
            returned is the natural type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</td><td>unsigned long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</td><td>WebGLRenderbuffer or WebGLTexture</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</td><td>long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</td><td>long</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isFramebuffer(WebGLFramebuffer? framebuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.7">OpenGL ES 2.0 &sect;6.1.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsFramebuffer.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLFramebuffer is valid and false otherwise. <br><br>

            Returns false if the framebuffer's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Renderbuffer objects</h4>

    <p>
        Renderbuffer objects are used to provide storage for the individual buffers used in a
        framebuffer object.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindRenderbuffer.xml">man page</a>)</span>
        <dd>
            Bind the given <code class="interface">WebGLRenderbuffer</code> object to the given binding point
            (<code class="param">target</code>), which must be <code class="enum">RENDERBUFFER</code>.
            If <code class="param">renderbuffer</code> is null the renderbuffer object currently bound to
            this <code class="param">target</code> is unbound.

        <dt class="idl-code">WebGLRenderbuffer? createRenderbuffer()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenRenderbuffers.xml">glGenRenderbuffers</a>)</span>
        <dd>
            Create a WebGLRenderbuffer object and initialize it with a renderbuffer object name as if by
            calling glGenRenderbuffers.
            
        <dt class="idl-code">void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteRenderbuffers.xml">glDeleteRenderbuffers</a>)</span>
        <dd>
            Delete the renderbuffer object contained in the passed WebGLRenderbuffer as if by calling
            glDeleteRenderbuffers. If the renderbuffer has already been deleted the call has no effect.
            Note that the renderbuffer object will be deleted when the WebGLRenderbuffer object is destroyed.
            This method merely gives the author greater control over when the renderbuffer object is
            destroyed.
        <dt class="idl-code">any getRenderbufferParameter(GLenum target, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetRenderbufferParameteriv.xml">glGetRenderbufferParameteriv</a>)</span>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>RENDERBUFFER_WIDTH</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_HEIGHT</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_INTERNAL_FORMAT</td><td>unsigned long</td></tr>
                <tr><td>RENDERBUFFER_RED_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_GREEN_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BLUE_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_ALPHA_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_DEPTH_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_STENCIL_SIZE</td><td>long</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.7">OpenGL ES 2.0 &sect;6.1.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsRenderbuffer.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLRenderbuffer is valid and false otherwise. <br><br>

            Returns false if the renderbuffer's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code">void renderbufferStorage(GLenum target, GLenum internalformat, 
                             GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES 2.0 &sect;4.4.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glRenderbufferStorage.xml">man page</a>)</span>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Texture objects</h4>

    <p>
        Texture objects provide storage and state for texturing operations. If no WebGLTexture is bound
        (e.g., passing null or 0 to bindTexture) then attempts to modify or query the texture object shall
        generate an <code>INVALID_OPERATION</code> error. This is indicated in the functions below.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindTexture(GLenum target, WebGLTexture? texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindTexture.xml">man page</a>)</span>

        <dt><p class="idl-code"><a name="COMPRESSEDTEXIMAGE2D">void compressedTexImage2D</a>(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, ArrayBufferView pixels)
                <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.3">OpenGL ES 2.0 &sect;3.7.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompressedTexImage2D.xml">man page</a>)</span></p>
            <p class="idl-code"><a name="COMPRESSEDTEXSUBIMAGE2D">void compressedTexSubImage2D</a>(GLenum target, GLint level,
                    GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView pixels)
                <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.3">OpenGL ES 2.0 &sect;3.7.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompressedTexSubImage2D.xml">man page</a>)</span></p>
        <dd>
            If an attempt is made to call these functions with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            The core WebGL specification does not define any supported compressed texture formats.
            By default, these methods generate an <code>INVALID_ENUM</code> error and return
            immediately. See <a href="#COMPRESSED_TEXTURE_SUPPORT">Compressed Texture Support</a>.

        <dt class="idl-code">void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, 
                        GLint x, GLint y, GLsizei width, GLsizei height, 
                        GLint border)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCopyTexImage2D.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            For any pixel lying outside the frame buffer, all channels of the associated texel are
            initialized to 0; see <a href="#READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the
            Framebuffer</a>.
        <dt class="idl-code">void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                           GLint x, GLint y, GLsizei width, GLsizei height)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCopyTexSubImage2D.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            For any pixel lying outside the frame buffer, all channels of the associated texel are
            initialized to 0; see <a href="#READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the
            Framebuffer</a>.
        <dt class="idl-code">WebGLTexture? createTexture()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenTextures.xml">man page</a>)</span>
        <dd>
            Create a WebGLTexture object and initialize it with a texture object name as if by
            calling glGenTextures.
            
        <dt class="idl-code">void deleteTexture(WebGLTexture? texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES 2.0 &sect;3.7.13</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteTextures.xml">man page</a>)</span>
        <dd>
            Delete the texture object contained in the passed WebGLTexture as if by calling
            glDeleteTextures. If the texture has already been deleted the call has no effect.
            Note that the texture object will be deleted when the WebGLTexture object is destroyed.
            This method merely gives the author greater control over when the texture object is
            destroyed.
        <dt class="idl-code">void generateMipmap(GLenum target)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.11">OpenGL ES 2.0 &sect;3.7.11</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenerateMipmap.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        <dt class="idl-code">any getTexParameter(GLenum target, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES 2.0 &sect;6.1.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetTexParameter.xml">man page</a>)</span>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>TEXTURE_MAG_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_MIN_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_S</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_T</td><td>unsigned long</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an
            <code>INVALID_OPERATION</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isTexture(WebGLTexture? texture)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.4">OpenGL ES 2.0 &sect;6.1.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsTexture.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLTexture is valid and false otherwise. <br><br>

            Returns false if the texture's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code"><a name="TEXIMAGE2D">void texImage2D</a>(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, GLenum format, 
                    GLenum type, ArrayBufferView? pixels)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.1">OpenGL ES 2.0 &sect;3.7.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexImage2D.xml">man page</a>)</span>
        <dd>
            If <code>pixels</code> is null, a buffer of sufficient size initialized to 0 is
            passed. <br><br>

            If <code>pixels</code> is non-null, the type of <code>pixels</code> must match the type
            of the data to be read. If it is UNSIGNED_BYTE, a Uint8Array must be supplied; if it is
            UNSIGNED_SHORT_5_6_5, UNSIGNED_SHORT_4_4_4_4, or UNSIGNED_SHORT_5_5_5_1, a Uint16Array
            must be supplied. If the types do not match, an INVALID_OPERATION error is generated.
            <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
        <dt><p class="idl-code"><a name="TEXIMAGE2D_HTML">void texImage2D</a>(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, ImageData? pixels)</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLImageElement image) /* May throw DOMException */</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLCanvasElement canvas) /* May throw DOMException */</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLVideoElement video) /* May throw DOMException */
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.1">OpenGL ES 2.0 &sect;3.7.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexImage2D.xml">man page</a>)</span></p>
        <dd>
            Uploads the given element or image data to the currently bound WebGLTexture. <br><br>

            The source image data is conceptually first converted to the data type and format
            specified by the <em>format</em> and <em>type</em> arguments, and then transferred to
            the OpenGL implementation. If a packed pixel format is specified which would imply loss
            of bits of precision from the image data, this loss of precision must occur. <br><br>

            If the source image is an RGB or RGBA lossless image with 8 bits per channel, the
            browser guarantees that the full precision of all channels is preserved. <br><br>

            If the original image contains an alpha channel and the
            <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter is false, then the
            RGB values are guaranteed to never have been premultiplied by the alpha channel, whether
            those values are derived directly from the original file format or converted from some
            other color format. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If this function is called with an <code>HTMLImageElement</code>
            or <code>HTMLVideoElement</code> whose origin differs from the origin of the containing
            Document, or with an <code>HTMLCanvasElement</code> whose <i>origin-clean</i> flag is
            set to false, a <code>SECURITY_ERR</code> exception must be
            thrown. See <a href="#ORIGIN_RESTRICTIONS">Origin Restrictions</a>.<br><br>

            If <code>pixels</code> is null then an <code>INVALID_VALUE</code> error is
            generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
        <dt class="idl-code">void texParameterf(GLenum target, GLenum pname, GLfloat param)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.4">OpenGL ES 2.0 &sect;3.7.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexParameter.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        <dt class="idl-code">void texParameteri(GLenum target, GLenum pname, GLint param)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.4">OpenGL ES 2.0 &sect;3.7.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexParameter.xml">man page</a>)</span>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        <dt class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLsizei width, GLsizei height, 
                       GLenum format, GLenum type, ArrayBufferView? pixels)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexSubImage2D.xml">man page</a>)</span>
        <dd>
            See <a href="#TEXIMAGE2D">texImage2D</a> for restrictions on the <em>format</em>
            and <em>pixels</em> arguments. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If <em>type</em> does not match the type originally used to define the texture, an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If <code>pixels</code> is null then an <code>INVALID_VALUE</code> error is
            generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
        <dt><p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, ImageData? pixels)</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLImageElement image) /* May throw DOMException */</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLCanvasElement canvas) /* May throw DOMException */</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLVideoElement video) /* May throw DOMException */
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES 2.0 &sect;3.7.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexSubImage2D.xml">man page</a>)</span></p>
        <dd>
            Updates a sub-rectangle of the currently bound WebGLTexture with the contents of the
            given element or image data. <br><br>

            See <a href="#TEXIMAGE2D_HTML">texImage2D</a> for the interpretation of
            the <em>format</em> and <em>type</em> arguments. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If <em>type</em> does not match the type originally used to define the texture, an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            If this function is called with an <code>HTMLImageElement</code>
            or <code>HTMLVideoElement</code> whose origin differs from the origin of the containing
            Document, or with an <code>HTMLCanvasElement</code> whose <i>origin-clean</i> flag is
            set to false, a <code>SECURITY_ERR</code> exception must be
            thrown. See <a href="#ORIGIN_RESTRICTIONS">Origin Restrictions</a>.<br><br>

            If <code>pixels</code> is null then an <code>INVALID_VALUE</code> error is
            generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Programs and Shaders</h4>

    <p>
        Rendering with OpenGL ES 2.0 requires the use of <i>shaders</i>, written in OpenGL ES's shading language, GLSL ES.
        Shaders must be loaded with a source string (shaderSource), compiled
        (compileShader) and attached to a <i>program</i> (attachShader) which must be linked
        (linkProgram) and then used (useProgram).
    </p>

    <dl class="methods">
        <dt class="idl-code">void attachShader(WebGLProgram? program, WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glAttachShader.xml">man page</a>)</span>
        <dt class="idl-code">void bindAttribLocation(WebGLProgram? program, GLuint index, DOMString name)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindAttribLocation.xml">man page</a>)</span>
        <dd>
            If the passed name is longer than the restriction defined
            in <a href="#MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a>,
            generates an <code>INVALID_VALUE</code> error. <br><br>

            See <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source Character
            Set</a> for additional validation performed by WebGL implementations.
        <dt class="idl-code">void compileShader(WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompileShader.xml">man page</a>)</span>
        <dt class="idl-code">WebGLProgram? createProgram()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateProgram.xml">man page</a>)</span>
        <dd>
            Create a WebGLProgram object and initialize it with a program object name as if by
            calling glCreateProgram.
            
        <dt class="idl-code">WebGLShader? createShader(type)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateShader.xml">man page</a>)</span>
        <dd>
            Create a WebGLShader object and initialize it with a shader object name as if by
            calling glCreateShader.
            
        <dt class="idl-code">void deleteProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteProgram.xml">man page</a>)</span>
        <dd>
            Delete the program object contained in the passed WebGLProgram as if by calling
            glDeleteProgram. If the program has already been deleted the call has no effect.
            Note that the program object will be deleted when the WebGLProgram object is destroyed.
            This method merely gives the author greater control over when the program object is
            destroyed.
        <dt class="idl-code">void deleteShader(WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteShader.xml">man page</a>)</span>
        <dd>
            Delete the shader object contained in the passed WebGLShader as if by calling
            glDeleteShader. If the shader has already been deleted the call has no effect.
            Note that the shader object will be deleted when the WebGLShader object is destroyed.
            This method merely gives the author greater control over when the shader object is
            destroyed.
        <dt class="idl-code">void detachShader(WebGLProgram? program, WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDetachShader.xml">man page</a>)</span>
        <dt class="idl-code">sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetAttachedShaders.xml">man page</a>)</span>
        <dd>
            <p>Returns a new object representing the list of shaders attached to the passed program.</p>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">any getProgramParameter(WebGLProgram? program, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetProgramiv.xml">man page</a>)</span>
        <dd>
            Return the value for the passed pname given the passed program. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>LINK_STATUS</td><td>boolean</td></tr>
                <tr><td>VALIDATE_STATUS</td><td>boolean</td></tr>
                <tr><td>ATTACHED_SHADERS</td><td>long</td></tr>
                <tr><td>ACTIVE_ATTRIBUTES</td><td>long</td></tr>
                <tr><td>ACTIVE_UNIFORMS</td><td>long</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">DOMString? getProgramInfoLog(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetProgramInfoLog.xml">man page</a>)</span>
        <dd>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">any getShaderParameter(WebGLShader? shader, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderiv.xml">man page</a>)</span>
        <dd>
            Return the value for the passed pname given the passed shader. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>SHADER_TYPE</td><td>unsigned long</td></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>COMPILE_STATUS</td><td>boolean</td></tr>
            </table>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">WebGLShaderPrecisionFormat getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetShaderPrecisionFormat.xml">man page</a>)</span>
        <dd>
            Return a new <code>WebGLShaderPrecisionFormat</code> describing the range and precision
            for the specified shader numeric format. The shadertype value can be FRAGMENT_SHADER or
            VERTEX_SHADER. The precisiontype value can be LOW_FLOAT, MEDIUM_FLOAT, HIGH_FLOAT,
            LOW_INT, MEDIUM_INT or HIGH_INT.
        <dt class="idl-code">DOMString? getShaderInfoLog(WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderInfoLog.xml">man page</a>)</span>
        <dd>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">DOMString? getShaderSource(WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderSource.xml">man page</a>)</span>
        <dd>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsProgram.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLProgram is valid and false otherwise. <br><br>

            Returns false if the program's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isShader(WebGLShader? shader)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsShader.xml">man page</a>)</span>
        <dd>
            Return true if the passed WebGLShader is valid and false otherwise. <br><br>

            Returns false if the shader's <a href="#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
        <dt class="idl-code">void linkProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glLinkProgram.xml">man page</a>)</span>
        <dt class="idl-code">void shaderSource(WebGLShader? shader, DOMString source)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES 2.0 &sect;2.10.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glShaderSource.xml">man page</a>)</span>
        <dd>
            See <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL
            Constructs</a>, <a href="#MAX_GLSL_TOKEN_SIZE">Maximum GLSL Token
            Size</a>, <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source
            Character Set</a>, and <a href="#MAX_STRUCT_NESTING">Maximum Nesting of Structures in
            GLSL Shaders</a> for additional constraints enforced in, additional constructs supported
            by, and validation performed by WebGL implementations.
        <dt class="idl-code">void useProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES 2.0 &sect;2.10.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUseProgram.xml">man page</a>)</span>
        <dt class="idl-code">void validateProgram(WebGLProgram? program)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.5">OpenGL ES 2.0 &sect;2.10.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glValidateProgram.xml">man page</a>)</span>
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Uniforms and attributes</h4>

    <p>
        Values used by the shaders are passed in as uniforms or vertex attributes.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void disableVertexAttribArray(GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDisableVertexAttribArray.xml">man page</a>)</span>
        <dt class="idl-code">void enableVertexAttribArray(GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glEnableVertexAttribArray.xml">man page</a>)</span>
        <dd>
            Enable the vertex attribute at <code>index</code> as an array. WebGL imposes additional
            rules beyond OpenGL ES 2.0 regarding enabled vertex attributes;
            see <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range
            Checking</a>.
        <dt class="idl-code">WebGLActiveInfo? getActiveAttrib(WebGLProgram? program, GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetActiveAttrib.xml">man page</a>)</span>
        <dd>
            Returns a new <code>WebGLActiveInfo</code> object describing the size, type and name of
            the vertex attribute at the passed index of the passed program object. If the passed
            index is out of range, generates an <code>INVALID_VALUE</code> error and returns null.
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">WebGLActiveInfo? getActiveUniform(WebGLProgram? program, GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetActiveUniform.xml">man page</a>)</span>
        <dd>
            Returns a new <code>WebGLActiveInfo</code> object describing the size, type and name of
            the uniform at the passed index of the passed program object. If the passed index is out
            of range, generates an <code>INVALID_VALUE</code> error and returns null.
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLint getAttribLocation(WebGLProgram? program, DOMString name)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetAttribLocation.xml">man page</a>)</span>
        <dd>
            If the passed name is longer than the restriction defined
            in <a href="#MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a>,
            generates an <code>INVALID_VALUE</code> error and returns -1. <br><br>

            Returns -1 if the context's <a href="#webgl-context-lost-flag">webgl context lost
            flag</a> is set. <br><br>

            If the <a href="#webgl-object-invalidated-flag">invalidated flag</a> of the passed
            program is set, generates an <code>INVALID_OPERATION</code> error and returns
            -1. <br><br>

            See <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source Character
            Set</a> for additional validation performed by WebGL implementations.
        <dt class="idl-code">any getUniform(WebGLProgram? program, WebGLUniformLocation? location)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetUniform.xml">man page</a>)</span>
        <dd>
            Return the uniform value at the passed location in the passed program. The type returned is 
            dependent on the uniform type, as shown in the following table:
            <table class="foo">
                <tr><th>uniform type</th><th>returned type</th></tr>
                <tr><td>boolean</td><td>boolean</td></tr>
                <tr><td>int</td><td>long</td></tr>
                <tr><td>float</td><td>float</td></tr>
                <tr><td>vec2</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ivec2</td><td>Int32Array (with 2 elements)</td></tr>
                <tr><td>bvec2</td><td>sequence&lt;boolean&gt; (with 2 elements)</td></tr>
                <tr><td>vec3</td><td>Float32Array (with 3 elements)</td></tr>
                <tr><td>ivec3</td><td>Int32Array (with 3 elements)</td></tr>
                <tr><td>bvec3</td><td>sequence&lt;boolean&gt; (with 3 elements)</td></tr>
                <tr><td>vec4</td><td>Float32Array (with 4 elements)</td></tr>
                <tr><td>ivec4</td><td>Int32Array (with 4 elements)</td></tr>
                <tr><td>bvec4</td><td>sequence&lt;boolean&gt; (with 4 elements)</td></tr>
                <tr><td>mat2</td><td>Float32Array (with 4 elements)</td></tr>
                <tr><td>mat3</td><td>Float32Array (with 9 elements)</td></tr>
                <tr><td>mat4</td><td>Float32Array (with 16 elements)</td></tr>
                <tr><td>sampler2D</td><td>long</td></tr>
                <tr><td>samplerCube</td><td>long</td></tr>
            </table>
            <p>All queries returning sequences or typed arrays return a new object each time.</p>
            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">WebGLUniformLocation? getUniformLocation(WebGLProgram? program, DOMString name)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetUniformLocation.xml">man page</a>)</span>
        <dd>
            <p>Return a new <code>WebGLUniformLocation</code> that represents the location of a
            specific uniform variable within a program object. The return value is null if name does
            not correspond to an active uniform variable in the passed program.</p>

            <p>If the passed name is longer than the restriction defined
            in <a href="#MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a>,
            generates an <code>INVALID_VALUE</code> error and returns null.</p>

            <p>See <a href="#CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source
            Character Set</a> for additional validation performed by WebGL implementations.</p>

            <p>Returns null if any OpenGL errors are generated during the execution of this
            function.</p>
        <dt class="idl-code">any getVertexAttrib(GLuint index, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetVertexAttrib.xml">man page</a>)</span>
        <dd>
            Return the information requested in pname about the vertex attribute at the passed index. The 
            type returned is dependent on the information requested, as shown in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_ENABLED</td><td>boolean</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_SIZE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_STRIDE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_TYPE</td><td>unsigned long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_NORMALIZED</td><td>boolean</td></tr>
                <tr><td>CURRENT_VERTEX_ATTRIB</td><td>Float32Array (with 4 elements)</td></tr>
            </table>
            <p>All queries returning sequences or typed arrays return a new object each time.</p>
            <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code">[WebGLHandlesContextLoss] GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES 2.0 &sect;6.1.8</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetVertexAttribPointerv.xml">man page</a>)</span>
        <dd>
            Returns 0 if the context's <a href="#webgl-context-lost-flag">webgl context lost
            flag</a> is set.
        <dt><p class="idl-code">void uniform[1234][fi](WebGLUniformLocation? location, ...)</p>
            <p class="idl-code">void uniform[1234][fi]v(WebGLUniformLocation? location, ...)
            <p class="idl-code">void uniformMatrix[234]fv(WebGLUniformLocation? location, GLboolean transpose, ...)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES 2.0 &sect;2.10.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUniform.xml">man page</a>)</span></p>
       <dd>
            Each of the uniform* functions above sets the specified uniform or uniforms to the
            values provided. If the passed <code>location</code> is not null and was not obtained
            from the currently used program via an earlier call to <code>getUniformLocation</code>,
            an <code>INVALID_OPERATION</code> error will be generated. If the passed
            <code>location</code> is null, the data passed in will be silently ignored and
            no uniform variables will be changed.
            <br><br>
            If the array passed to any of the vector forms (those ending in <code>v</code>) has an 
            invalid length, an <code>INVALID_VALUE</code> error will be generated. The length is 
            invalid if it is too short for or is not an integer multiple of the assigned type.
        <dt><p class="idl-code">void vertexAttrib[1234]f(GLuint indx, ...)</p>
            <p class="idl-code">void vertexAttrib[1234]fv(GLuint indx, ...)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.7">OpenGL ES 2.0 &sect;2.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glVertexAttrib.xml">man page</a>)</span></p>
       <dd>
           Sets the vertex attribute at the passed index to the given constant value. Values set via the
           <code>vertexAttrib</code> are guaranteed to be returned from the <code>getVertexAttrib</code> function
           with the <code>CURRENT_VERTEX_ATTRIB</code> param, even if there have been intervening calls to 
           <code>drawArrays</code> or <code>drawElements</code>.
       <dt class="idl-code">void vertexAttribPointer(GLuint indx, GLint size, GLenum type, 
                            GLboolean normalized, GLsizei stride, GLintptr offset)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glVertexAttribPointer.xml">man page</a>)</span>
        <dd>
            Assign the WebGLBuffer object currently bound to the ARRAY_BUFFER target to the vertex
            attribute at the passed index. Size is number of components per attribute. Stride and
            offset are in units of bytes. Passed stride and offset must be appropriate for the
            passed type and size or an <code>INVALID_OPERATION</code> error will be generated;
            see <a href="#BUFFER_OFFSET_AND_STRIDE">Buffer Offset and Stride Requirements</a>. If
            offset is negative, an <code>INVALID_VALUE</code> error will be generated. If no
            WebGLBuffer is bound to the ARRAY_BUFFER target, an <code>INVALID_OPERATION</code> error
            will be generated. In WebGL, the maximum supported stride is 255;
            see <a href="#VERTEX_STRIDE"> Vertex Attribute Data Stride</a>.
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Writing to the drawing buffer</h4>

    <p>
        OpenGL ES 2.0 has 3 calls which can render to the drawing buffer: <code>clear</code>, 
        <code>drawArrays</code> and <code>drawElements</code>. Furthermore rendering can
        be directed to the drawing buffer or to a Framebuffer object. When rendering is
        directed to the drawing buffer, making any of the 3 rendering calls shall 
        cause the drawing buffer to be presented to the HTML page compositor at the start
        of the next compositing operation.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void clear(GLbitfield mask)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES 2.0 &sect;4.2.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClear.xml">man page</a>)</span>
        <dt class="idl-code">void drawArrays(GLenum mode, GLint first, GLsizei count)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDrawArrays.xml">man page</a>)</span>
            <dd>
            If <em>first</em> is negative, an <code>INVALID_VALUE</code> error will be generated.
        <dt class="idl-code">void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES 2.0 &sect;2.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDrawElements.xml">man page</a>)</span>
        <dd>
            Draw using the currently bound element array buffer.  The given offset is in bytes, and
            must be a valid multiple of the size of the given type or an <code>INVALID_OPERATION</code>
            error will be generated; see <a href="#BUFFER_OFFSET_AND_STRIDE">Buffer Offset and Stride
            Requirements</a>. If <code>count</code> is greater than zero, then a non-null
            <code>WebGLBuffer</code> must be bound to the <code>ELEMENT_ARRAY_BUFFER</code> binding
            point or an <code>INVALID_OPERATION</code> error will be generated.<br><br>

            WebGL performs additional error checking beyond that specified in OpenGL ES 2.0 during
            calls to <code>drawArrays</code>
            and <code>drawElements</code>. See <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex
            Attributes and Range Checking</a>.
        <dt class="idl-code">void finish()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.1">OpenGL ES 2.0 &sect;5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFinish.xml">man page</a>)</span>
        <dt class="idl-code">void flush()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.1">OpenGL ES 2.0 &sect;5.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFlush.xml">man page</a>)</span>
    </dl>

<!-- ======================================================================================================= -->

    <h4><a name="readpixels">Reading back pixels</a></h4>

    <p>
        Pixels in the current framebuffer can be read back into an ArrayBufferView object.
    </p>

    <dl class="methods">
        <dt class="idl-code">void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                           GLenum format, GLenum type, ArrayBufferView? pixels)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.3.1">OpenGL ES 2.0 &sect;4.3.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glReadPixels.xml">man page</a>)</span>
        <dd>
            Fills <code>pixels</code> with the pixel data in the specified rectangle of the frame
            buffer. The data returned from readPixels must be up-to-date as of the most recently
            sent drawing command.
            <br><br>

            The type of <code>pixels</code> must match the type of the data to be read. For example,
	    if it is UNSIGNED_BYTE, a Uint8Array must be supplied; if it is UNSIGNED_SHORT_5_6_5,
            UNSIGNED_SHORT_4_4_4_4, or UNSIGNED_SHORT_5_5_5_1, a Uint16Array must be supplied. If
            the types do not match, an INVALID_OPERATION error is generated.
            <br><br>

	    The following are the allowed format and type combinations:

            <table class="foo">
              <tr><th>format</th><th>type</th></tr>
              <tr><td>RGBA</td><td>UNSIGNED_BYTE</td></tr>
            </table>

            If <code>pixels</code> is null, an INVALID_VALUE error is generated. If
            <code>pixels</code> is non-null, but is not large enough to retrieve all of the pixels
            in the specified rectangle taking into account pixel store modes, an INVALID_OPERATION
            error is generated.
            <br><br>

            For any pixel lying outside the frame buffer, the value read contains 0 in all channels;
            see <a href="#READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the Framebuffer</a>.
            <br><br>

    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Detecting context lost events</h4>

    <p>
        Occurrences such as power events on mobile devices may cause the WebGL rendering context to
        be lost at any time and require the application to rebuild it;
        see <a href="#WEBGLCONTEXTEVENT">WebGLContextEvent</a> for more details. The
        following method assists in detecting context lost events.
    </p>

    <dl class="methods">
        <dt class="idl-code">[WebGLHandlesContextLoss] boolean isContextLost()
        <dd>
            Return true if the <a href="#webgl-context-lost-flag">webgl context lost flag</a> is
            set, otherwise return false.
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Detecting and enabling extensions</h4>

    <p>
        An implementation of WebGL must not support any additional parameters, constants or functions
        without first enabling that functionality through the extension mechanism. The 
        <code>getSupportedExtensions</code> function returns an array of the extension strings
        supported by this implementation. An extension is enabled by passing one of those strings to
        the <code>getExtension</code> function. This call returns an object which contains any
        constants or functions defined by that extension. The definition of that object is specific
        to the extension and must be defined by the extension specification.
    </p>
    <p>
        Once an extension is enabled, no mechanism is provided to disable it. Multiple calls to
        <code>getExtension</code> with the same extension string, taking into account
        case-insensitive comparison, shall return the same object. An attempt to use any features of
        an extension without first calling getExtension to enable it must generate an appropriate GL
        error and must not make use of the feature.
    </p>
    <p>
        This specification does not define any extensions. A separate <a href="#refsREGISTRY">WebGL
        extension registry</a> defines extensions that may be supported by a particular WebGL
        implementation.
    </p>

    <dl class="methods">
        <dt class="idl-code">sequence&lt;DOMString&gt;? getSupportedExtensions()
        <dd>
            Returns a list of all the supported extension strings.
            
        <dt class="idl-code">object? getExtension(DOMString name)
        <dd>
            Returns an object if, and only if, <em>name</em> is
            an <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#ascii-case-insensitive">ASCII
            case-insensitive match</a> <a href="#refsHTML">[HTML]</a> for one of the names returned
            from <code>getSupportedExtensions</code>; otherwise, returns <code>null</code>. The
            object returned from <code>getExtension</code> contains any constants or functions
            provided by the extension. A returned object may have no constants or functions if the
            extension does not define any, but a unique object must still be returned. That object
            is used to indicate that the extension has been enabled.
    </dl>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLCONTEXTEVENT">WebGLContextEvent</a></h3>

    <p>
        WebGL generates a <code>WebGLContextEvent</code> event in response to a status change to the
        WebGL rendering context associated with the HTMLCanvasElement which has a listener for this
        event. Events are sent using the DOM Event
        System <a href="#refsDOM3EVENTS">[DOM3EVENTS]</a>. Event types can include the loss or
        restoration of state, or the inability to create a context.
        <a href="http://www.w3.org/TR/domcore/#eventinit">EventInit</a> is defined in the DOM4
        specification <a href="#refsDOM4">[DOM4]</a>.
    </p>
        To <b><a name="fire-a-webgl-context-event">fire a WebGL context event named e</a></b> means that
        an <a href="http://www.w3.org/TR/domcore/#concept-event">event</a>
        using the <code>WebGLContextEvent</code> interface, with
        its <a href="http://www.w3.org/TR/domcore/#dom-event-type"><code>type</code></a>
        attribute <a href="#refsDOM4">[DOM4]</a> initialized to <em>e</em>, and
        its <a href="http://www.w3.org/TR/domcore/#dom-event-istrusted"><code>isTrusted</code></a>
        attribute <a href="#refsDOM4">[DOM4]</a> initialized to true, is to
        be <a href="http://www.w3.org/TR/domcore/#concept-event-dispatch">dispatched</a>
        at the given object.
    <p>
    </p>
    <pre class="idl">
[Constructor(DOMString type, optional WebGLContextEventInit eventInit)]
interface <dfn id="WebGLContextLostEvent">WebGLContextEvent</dfn> : <a href="http://www.w3.org/TR/domcore/#event">Event</a> {
    readonly attribute DOMString statusMessage;
};

// EventInit is defined in the DOM4 specification.
dictionary WebGLContextEventInit : <a href="http://www.w3.org/TR/domcore/#eventinit">EventInit</a> {
    DOMString statusMessage;
};</pre>

    <p>
    The <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#task-source">task
    source</a> for
    all <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#concept-task">tasks</a> <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#queue-a-task">queued</a> <a href="#refsHTML">[HTML]</a>
    in this section is the <b>WebGL task source</b>.
    </p>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt><span class="prop-name"><code>statusMessage</code></span> of type <code>DOMString</code>
        <dd>
            A string containing additional information, or the empty string if no additional information
            is available.
    </dl>

    <h4><a name="CONTEXT_LOST">The Context Lost Event</a></h4>

    <p>
        When the user agent detects that the <em>drawing buffer</em> associated with
        a <code>WebGLRenderingContext</code> <em>context</em> has been lost, it must run the
        following steps:

        <ol class="nestedlist">

        <li> Let <em>canvas</em> be the <em>context's</em>
        <a href="#context-canvas">canvas</a>. </li>

        <li> If </em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost</a> flag
        is set, abort these steps. </li>

        <li> Set <em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost</a>
        flag. </li>

        <li> Set the <a href="#webgl-object-invalidated-flag">invalidated flag</a> of
        each <code>WebGLObject</code> instance created by this context. </li>

        <li> <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to
        perform the following steps:

            <ol class="nestedlist">

            <li> <a href="#fire-a-webgl-context-event">Fire a WebGL context event</a> named
            "webglcontextlost" at <em>canvas</em>, with its <code>statusMessage</code> attribute set
            to "". </li>

            <li> If the
            event's <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#canceled-flag">canceled
            flag</a> is not set, abort these steps. </li>

            <li> Perform the following steps asynchronously. </li>

            <li> Await a restorable <em>drawing buffer</em>. </li>

            <li> Queue a task to <a href="#restore-the-drawing-buffer">restore the drawing
            buffer</a> for <em>context</em>. </li>

            </ol>

        </li>
        </ol>
    </p>
    <div class="example">
        The following code prevents the default behavior of the <code>webglcontextlost</code>
        event and enables the <code>webglcontextrestored</code> event to be delivered:
    <pre>canvas.addEventListener("webglcontextlost", function(e) { e.preventDefault(); }, false); </pre>
    </div>

    <h4>The Context Restored Event</h4>

    <p>

        When the user agent is to <b><a name="restore-the-drawing-buffer">restore the drawing
        buffer</a></b> for a <code>WebGLRenderingContext</code> <em>context</em>, it must run the
        following steps:

        <ol class="nestedlist">

        <li> Let <em>canvas</em> be the canvas object associated with <em>context</em>.

        <li> If <em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost flag</a> is
        not set, abort these steps.

        <li> <a href="#create-a-drawing-buffer">Create a <em>drawing buffer</em></a> using the
        settings specified in <em>context's</em> <a href="#context-creation-parameters">context
        creation parameters</a>, and associate the <em>drawing buffer</em> with <em>context</em>,
        discarding any previous <em>drawing buffer</em>.

        <li> Clear <em>context's</em> <a href="#webgl-context-lost-flag">webgl context lost
        flag</a>.

        <li> Reset <em>context's</em> OpenGL error state.

        <li> <a href="#fire-a-webgl-context-event">Fire a WebGL context event</a> named
        "webglcontextrestored" at <em>canvas</em>, with its <code>statusMessage</code> attribute set
        to "".

        </ol>

    </p>

    <div class="note"> 
        Once the context is restored, WebGL resources such as textures and buffers that were created
        before the context was lost are no longer valid. The application needs to reinitialize the
        context's state and recreate all such resources.
    </div>

    <div class="example">
        The following code illustrates how an application can handle context loss and restoration:
<pre>function initializeGame() {
  initializeWorld();
  initializeResources();
}

function initializeResources() {
  initializeShaders();
  initializeBuffers();
  initializeTextures();

  // ready to draw, start the main loop
  renderFrame();
}

function renderFrame() {
  updateWorld();
  drawSkyBox();
  drawWalls();
  drawMonsters();

  requestId = window.requestAnimationFrame(
      renderFrame, canvas);
}

canvas.addEventListener(
    "webglcontextlost", function (event) {

  // inform WebGL that we handle context restoration
  event.preventDefault();

  // Stop rendering
  window.cancelAnimationFrame(requestId);
}, false);

canvas.addEventListener(
    "webglcontextrestored", function (event) {

  initializeResources();
}, false);

initializeGame();</pre>
    </div>

    <h4>The Context Creation Error Event</h4>

    <p>
        When the user agent is to <b><a name="fire-a-webgl-context-creation-error">fire a WebGL
        context creation error</a></b> at a <em>canvas</em>, it must perform the following steps:

        <ol class="nestedlist">

        <li> <a href="#fire-a-webgl-context-event">Fire a WebGL context event</a> named
        "webglcontextcreationerror" at <em>canvas</em>, optionally with its <code>statusMessage</code>
        attribute set to a platform dependent string about the nature of the failure. </li>

        </ol>

    </p>

    <div class="example">

        The following code illustrates how an application can retrieve information about context creation failure:

<pre>var errorInfo = "";
function onContextCreationError(event) {

  canvas.removeEventListener(
     "webglcontextcreationerror",
     onContextCreationError, false);

  errorInfo = e.statusMessage || "Unknown";
}

canvas.addEventListener(
    "webglcontextcreationerror",
    onContextCreationError, false);

var gl = canvas.getContext("experimental-webgl");
if(!gl) {
  alert("A WebGL context could not be created.\nReason: " +
        errorInfo);
}</pre>
    </div>

<!-- ======================================================================================================= -->

    <h2><a name="webgl_gl_differences">Differences Between WebGL and OpenGL ES 2.0</a></h2>
    
<p>

This section describes changes made to the WebGL API relative to the OpenGL ES 2.0 API to improve
portability across various operating systems and devices.

</p>

    <h3>Buffer Object Binding</h3>

<p>

In the WebGL API, a given buffer object may only be bound to one of the <code>ARRAY_BUFFER</code> or
<code>ELEMENT_ARRAY_BUFFER</code> binding points in its lifetime. This restriction implies that a
given buffer object may contain either vertices or indices, but not both.

</p>
<p>

The type of a WebGLBuffer is initialized the first time it is passed as an argument
to <code>bindBuffer</code>. A subsequent call to <code>bindBuffer</code> which attempts to bind the
same WebGLBuffer to the other binding point will generate an <code>INVALID_OPERATION</code> error, and
the state of the binding point will remain untouched.

</p>

    <h3>No Client Side Arrays</h3>

<p>

The WebGL API does not support client-side arrays. If <code>vertexAttribPointer</code> is called
without a <code>WebGLBuffer</code> bound to the <code>ARRAY_BUFFER</code> binding point,
an <code>INVALID_OPERATION</code> error is generated. If <code>drawElements</code> is called with
a <code>count</code> greater than zero, and no <code>WebGLBuffer</code> is bound to
the <code>ELEMENT_ARRAY_BUFFER</code> binding point, an <code>INVALID_OPERATION</code> error is
generated.

</p>

    <h3>No Default Textures</h3>

<p>

The WebGL API does not support default textures. A non-null <code>WebGLTexture</code> object must be
bound in order for texture-related operations and queries to succeed.

</p>

    <h3><a name="BUFFER_OFFSET_AND_STRIDE">Buffer Offset and Stride Requirements</a></h3>

<p>

The <code>offset</code> arguments to <code>drawElements</code> and <code>vertexAttribPointer</code>,
and the <code>stride</code> argument to <code>vertexAttribPointer</code>, must be a multiple of the
size of the data type passed to the call, or an <code>INVALID_OPERATION</code> error is generated.

</p>


    <h3><a name="ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range Checking</a></h3>

<p>

If a vertex attribute is enabled as an array via <code>enableVertexAttribArray</code> but no buffer
is bound to that attribute via <code>bindBuffer</code> and <code>vertexAttribPointer</code>, then
calls to <code>drawArrays</code> or <code>drawElements</code> will generate an
<code>INVALID_OPERATION</code> error.

</p>
<p>

If a vertex attribute is enabled as an array, a buffer is bound to that attribute, and the attribute
is consumed by the current program, then calls to <code>drawArrays</code>
and <code>drawElements</code> will verify that each referenced vertex lies within the storage of the
bound buffer. If the range specified in <code>drawArrays</code> or any referenced index
in <code>drawElements</code> lies outside the storage of the bound buffer, an INVALID_OPERATION
error is generated and no geometry is drawn.

</p>
<p>

If a vertex attribute is enabled as an array, a buffer is bound to that attribute, but the attribute
is not consumed by the current program, then regardless of the size of the bound buffer, it will not
cause any error to be generated during a call to <code>drawArrays</code>
or <code>drawElements</code>.

</p>

    <h3>Framebuffer Object Attachments</h3>

<p>

WebGL adds the <code>DEPTH_STENCIL_ATTACHMENT</code> framebuffer object attachment point and
the <code>DEPTH_STENCIL</code> renderbuffer internal format. To attach both depth and stencil
buffers to a framebuffer object, call <code>renderbufferStorage</code> with
the <code>DEPTH_STENCIL</code> internal format, and then call <code>framebufferRenderbuffer</code>
with the <code>DEPTH_STENCIL_ATTACHMENT</code> attachment point.

</p>
<p>

A renderbuffer attached to the <code>DEPTH_ATTACHMENT</code> attachment point must be allocated with
the <code>DEPTH_COMPONENT16</code> internal format. A renderbuffer attached to
the <code>STENCIL_ATTACHMENT</code> attachment point must be allocated with
the <code>STENCIL_INDEX8</code> internal format. A renderbuffer attached to
the <code>DEPTH_STENCIL_ATTACHMENT</code> attachment point must be allocated with
the <code>DEPTH_STENCIL</code> internal format.

</p>
<p>

In the WebGL API, it is an error to concurrently attach renderbuffers to the following combinations
of attachment points:

<ul>
<li> <code>DEPTH_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
<li> <code>STENCIL_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
<li> <code>DEPTH_ATTACHMENT + STENCIL_ATTACHMENT</code>
</ul>

If any of the constraints above are violated, then:

<ul>
<li> <code>checkFramebufferStatus</code> must return <code>FRAMEBUFFER_UNSUPPORTED</code>.
<li> The following calls, which either modify or read the framebuffer, must generate
     an <code>INVALID_FRAMEBUFFER_OPERATION</code> error and return early, leaving the contents of
     the framebuffer, destination texture or destination memory untouched.
  <ul>
  <li> clear
  <li> copyTexImage2D
  <li> copyTexSubImage2D
  <li> drawArrays
  <li> drawElements
  <li> readPixels
  </ul>
</ul>

<h3><a name="PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a></h3>

<p>
The WebGL API supports the following additional parameters to <code>pixelStorei</code>.

<dl>
<dt><code>UNPACK_FLIP_Y_WEBGL</code> of type <code>boolean</code>
<dd>If set, then during any subsequent calls to <code>texImage2D</code> or
<code>texSubImage2D</code>, the source data is flipped along the vertical axis, so that conceptually
the last row is the first one transferred. The initial value is <code>false</code>. Any non-zero
value is interpreted as <code>true</code>.

<dt><code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> of type <code>boolean</code>
<dd>If set, then during any subsequent calls to <code>texImage2D</code>
or <code>texSubImage2D</code>, the alpha channel of the source data, if present, is multiplied into
the color channels during the data transfer. The initial value is <code>false</code>. Any non-zero
value is interpreted as <code>true</code>.

<dt><code>UNPACK_COLORSPACE_CONVERSION_WEBGL</code> of type <code>unsigned long</code>
<dd>If set to <code>BROWSER_DEFAULT_WEBGL</code>, then the browser's default colorspace conversion
is applied during subsequent <code>texImage2D</code> and <code>texSubImage2D</code> calls
taking <code>HTMLImageElement</code>. The precise conversions may be specific to both the browser
and file type. If set to <code>NONE</code>, no colorspace conversion is applied. The initial value
is <code>BROWSER_DEFAULT_WEBGL</code>.

</dl>

<h3><a name="READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside the Framebuffer</a></h3>

<p>
In the WebGL API, functions which read the framebuffer
(<code>copyTexImage2D</code>, <code>copyTexSubImage2D</code>, and <code>readPixels</code>) are
defined to generate the RGBA value (0, 0, 0, 0) for any pixel which is outside of the bound
framebuffer.
</p>

<h3><a name="STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a></h3>

<p>
In the WebGL API it is illegal to specify a different mask or reference value for front facing and
back facing triangles in stencil operations. A call to <code>drawArrays</code>
or <code>drawElements</code> will generate an <code>INVALID_OPERATION</code> error if:

<ul>
<li> <code>STENCIL_WRITEMASK</code> != <code>STENCIL_BACK_WRITEMASK</code> (as specified by <code>stencilMaskSeparate</code> for the <code>mask</code> parameter associated with the FRONT and BACK values of <code>face</code>, respectively)
<li> <code>STENCIL_VALUE_MASK</code> != <code>STENCIL_BACK_VALUE_MASK</code> (as specified by <code>stencilFuncSeparate</code> for the <code>mask</code> parameter associated with the FRONT and BACK values of <code>face</code>, respectively)
<li> <code>STENCIL_REF</code> != <code>STENCIL_BACK_REF</code> (as specified by <code>stencilFuncSeparate</code> for the <code>ref</code> parameter associated with the FRONT and BACK values of <code>face</code>, respectively)
</ul>

</p>

    <h3><a name="VERTEX_STRIDE">Vertex Attribute Data Stride</a></h3>

<p>
The WebGL API supports vertex attribute data strides up to 255 bytes. A call to
<code>vertexAttribPointer</code> will generate an <code>INVALID_VALUE</code> error if the value for
the stride parameter exceeds 255.
</p>

    <h3><a name="VIEWPORT_DEPTH_RANGE">Viewport Depth Range</a></h3>

<p>
The WebGL API does not support depth ranges with where the near plane is mapped to a value greater
than that of the far plane. A call to <code>depthRange</code> will generate an
<code>INVALID_OPERATION</code> error if <code>zNear</code> is greater than <code>zFar</code>.
</p>

    <h3><a name="CONSTANT_COLOR_BLEND">Blending With Constant Color</a></h3>

<p>
In the WebGL API, constant color and constant alpha cannot be used together as source and
destination factors in the blend function. A call to <code>blendFunc</code> will generate an
<code>INVALID_OPERATION</code> error if one of the two factors is set to <code>CONSTANT_COLOR</code>
or <code>ONE_MINUS_CONSTANT_COLOR</code> and the other to <code>CONSTANT_ALPHA</code> or
<code>ONE_MINUS_CONSTANT_ALPHA</code>. A call to <code>blendFuncSeparate</code> will generate an
<code>INVALID_OPERATION</code> error if <code>srcRGB</code> is set to <code>CONSTANT_COLOR</code>
or <code>ONE_MINUS_CONSTANT_COLOR</code> and <code>dstRGB</code> is set to <code>CONSTANT_ALPHA</code> or
<code>ONE_MINUS_CONSTANT_ALPHA</code> or vice versa.
</p>

    <h3>Fixed point support</h3>

The WebGL API does not support the <code>GL_FIXED</code> data type.

    <h3>GLSL Constructs</h3>

<p>
Per <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a>, identifiers starting with
"webgl_" and "_webgl_" are reserved for use by WebGL.
</p>

    <h3><a name="EXTENSION_QUERIES">Extension Queries</a></h3>

<p>

In the OpenGL ES 2.0 API, the available extensions are determined by calling
<code>glGetString(GL_EXTENSIONS)</code>, which returns a space-separated list of extension strings.
In the WebGL API, the <code>EXTENSIONS</code> enumerant has been removed.
Instead, <code>getSupportedExtensions</code> must be called to determine the set of available
extensions.

</p>

    <h3><a name="IMPLEMENTATION_READ_FORMAT">Implementation Color Read Format and Type</a></h3>

<p>

    In the OpenGL ES 2.0 API, the
    <code>IMPLEMENTATION_COLOR_READ_FORMAT</code> and
    <code>IMPLEMENTATION_COLOR_READ_TYPE</code> parameters are used to inform applications of an
    additional format and type combination that may be passed to <code>ReadPixels</code>, in
    addition to the required <ncode>RGBA</code>/<code>UNSIGNED_BYTE</code> pair.  In WebGL 1.0,
    the supported format and type combinations to <code>ReadPixels</code> are documented in the
    <a href="#readpixels">Reading back pixels</a> section.  The <code>IMPLEMENTATION_COLOR_READ_FORMAT</code>
    and <code>IMPLEMENTATION_COLOR_READ_TYPE</code> enumerants have been removed.
</p>

    <h3><a name="COMPRESSED_TEXTURE_SUPPORT">Compressed Texture Support</a></h3>

<p>
    The core WebGL specification does not define any supported compressed texture formats.
    Therefore, in the absence of any other extensions being enabled:

    <ul>

      <li> The <a href="#COMPRESSEDTEXIMAGE2D"><code>compressedTexImage2D</code></a>
           and <a href="#COMPRESSEDTEXSUBIMAGE2D"><code>compressedTexSubImage2D</code></a> methods
           generate an <code>INVALID_ENUM</code> error. </li>

      <li> Calling <a href="#GETPARAMETER"><code>getParameter</code></a> with the
           argument <code>COMPRESSED_TEXTURE_FORMATS</code> returns a zero-length array (of
           type <code>Uint32Array</code>). </li>

    </ul>
</p>

    <h3><a name="MAX_GLSL_TOKEN_SIZE">Maximum GLSL Token Size</a></h3>

<p>
    The GLSL ES spec <a href="#refsGLES20GLSL">[GLES20GLSL]</a> does not define a limit to the
    length of tokens. WebGL requires support of tokens up to 256 characters in length. Shaders
    containing tokens longer than 256 characters must fail to compile.
</p>

    <h3><a name="CHARACTERS_OUTSIDE_VALID_SET">Characters Outside the GLSL Source Character Set</a></h3>

<p>
    The GLSL ES spec <a href="#refsGLES20GLSL">[GLES20GLSL]</a> defines the source character set for
    the OpenGL ES shading language to be ISO/IEC 646:1991, commonly called ASCII <a href="#refsASCII">[ASCII]</a>. 
    If a string containing a character not in this set is passed to any of the shader-related entry
    points <code>bindAttribLocation</code>, <code>getAttribLocation</code>, <code>getUniformLocation</code>,
    or <code>shaderSource</code>, an <code>INVALID_VALUE</code> error will be generated. The exception is
    that any character allowed in an HTML DOMString <a href="#refsDOMSTRING">[DOMSTRING]</a> may be used
    in GLSL comments. Such use must not generate an error.
</p>

<div class="note">        
    <p>
        Some GLSL implementations disallow characters outside the ASCII range, even in comments. The
        WebGL implementation needs to prevent errors in such cases. The recommended technique is to
        preprocess the GLSL string, removing all comments, but maintaining the line numbering for
        debugging purposes by inserting newline characters as needed. 
    </p>
</div>
    
    <h3><a name="MAX_STRUCT_NESTING">Maximum Nesting of Structures in GLSL Shaders</a></h3>

<p>
    WebGL imposes a limit on the nesting of structures in GLSL shaders. Nesting occurs when a field
    in a struct refers to another struct type; the GLSL ES
    spec <a href="#refsGLES20GLSL">[GLES20GLSL]</a> forbids embedded structure definitions. The
    fields in a top-level struct definition have a nesting level of 1.
</p>
<p>
    WebGL requires support of a structure nesting level of 4. Shaders containing structures nested
    more than 4 levels deep must fail to compile.
</p>

    <h3><a name="MAX_LOCATION_LENGTHS">Maximum Uniform and Attribute Location Lengths</a></h3>

<p>
    WebGL imposes a limit of 256 characters on the lengths of uniform and attribute locations.
</p>

    <h3>String Length Queries</h3>

<p>
    In the WebGL API, the enumerants <code>INFO_LOG_LENGTH</code>, <code>SHADER_SOURCE_LENGTH</code>,
    <code>ACTIVE_UNIFORM_MAX_LENGTH</code>, and <code>ACTIVE_ATTRIB_MAX_LENGTH</code> have been removed. In
    the OpenGL ES 2.0 API, these enumerants are needed to determine the size of buffers passed to calls
    like <code>glGetActiveAttrib</code>. In the WebGL API, the analogous calls (<code>getActiveAttrib</code>,
    <code>getActiveUniform</code>, <code>getProgramInfoLog</code>, <code>getShaderInfoLog</code>, and
    <code>getShaderSource</code>) all return <code>DOMString</code>.
</p>

<h3>Texture Type in TexSubImage2D Calls</h3>

<p>
    In the WebGL API, the <em>type</em> argument passed to <code>texSubImage2D</code> must match the
    type used to originally define the texture object (i.e., using <code>texImage2D</code>).
</p>



<!-- ======================================================================================================= -->

    <h2>References</h2>
    
    <h3>Normative references</h3>
    <dl>
    
        <dt id="refsCANVAS">[CANVAS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/html5/the-canvas-element.html">
            HTML5: The Canvas Element</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>

        <dt id="refsCANVASCONTEXTS">[CANVASCONTEXTS]</dt>
        <dd><cite><a href="http://wiki.whatwg.org/wiki/CanvasContexts">
            Canvas Context Registry</a></cite>,
            WHATWG.
        </dd>
        <dt id="refsTYPEDARRAYS">[TYPEDARRAYS]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/typedarray/specs/latest/">
            Typed Array Specification: Editor's Draft</a></cite>,
            V. Vukicevic, K. Russell, May 2010.
        </dd>
        <dt id="refsGLES20">[GLES20]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf">
            OpenGL&reg; ES Common Profile Specification Version 2.0.25</a></cite>, 
            A. Munshi, J. Leech, November 2010.
        </dd>
        <dt id="refsGLES20GLSL">[GLES20GLSL]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">
            The OpenGL&reg; ES Shading Language Version 1.00</a></cite>, 
            R. Simpson, May 2009.
        </dd>
        <dt id="refsREGISTRY">[REGISTRY]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webgl/extensions/">
            WebGL Extension Registry</a></cite>
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsCSS">[CSS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/CSS21/">
            Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a></cite>,
            B. Bos, T. Celik, I. Hickson, H. W. Lie, June 2011.
        </dd>
        <dt id="refsCORS">[CORS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/cors/">
            Cross-Origin Resource Sharing</a></cite>,
            A. van Kesteren, July 2010.
        </dd>
        <dt id="refsDOM4">[DOM4]</dt>
        <dd><cite><a href="http://www.w3.org/TR/domcore/">
            DOM4</a></cite>,
            A. van Kesteren, A. Gregor, Ms2ger.
        </dd>
        <dt id="refsDOM3EVENTS">[DOM3EVENTS]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html">
            Document Object Model (DOM) Level 3 Events Specification</a></cite>,
            Doug Schepers and Jacob Rossi. W3C.
        </dd>
        <dt id="refsHTML">[HTML]</dt>
        <dd><cite><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">
            HTML</a></cite>,
            I. Hickson, June 2011.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">
            Web IDL: W3C Editor’s Draft</a></cite>, 
            C. McCormack.
        </dd>
        <dt id="refsASCII">[ASCII]</dt>
        <dd><cite>International Standard ISO/IEC 646:1991. Information technology - 
            ISO 7-bit coded character set for information interchange</cite>
        </dd>
        <dt id="refsDOMSTRING">[DOMSTRING]</dt>
        <dd><cite><a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#DOMString">
            Document Object Model Core: The DOMString type</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>
    </dl>

    <h3>Other references</h3>

<!-- ======================================================================================================= -->
    
    <h2>Acknowledgments</h2>
    <p>This specification is produced by the Khronos WebGL Working Group.</p>
    
    <p>
       Special thanks to: Arun Ranganathan (Mozilla), Jon Leech, Kenneth Russell (Google), 
       Kenneth Waters (Google), Mark Callow (HI), Mark Steele (Mozilla), Oliver Hunt (Apple), 
       Tim Johansson (Opera), Vangelis Kokkevis (Google), Vladimir Vukicevic (Mozilla),
       Gregg Tavares (Google)
    </p>
    <p>
        Additional thanks to: Alan Hudson (Yumetech), Bill Licea Kane (AMD), Boris Zbarsky
        (Mozilla), Cameron McCormack (Mozilla), Cedric Vivier (Zegami), Dan Gessel (Apple), David
        Ligon (Qualcomm), David Sheets (Ashima Arts), Glenn Maynard, Greg Roth (Nvidia), Jacob Strom
        (Ericsson), Kari Pulli (Nokia), Leddie Stenvie (ST-Ericsson), Neil Trevett (Nvidia), Per
        Wennersten (Ericsson), Per-Erik Brodin (Ericsson), Shiki Okasaka (Google), Tom Olson (ARM),
        Zhengrong Yao (Ericsson), and the members of the Khronos WebGL Working Group.
</p>

</body>
</html>
