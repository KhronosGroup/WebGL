<!--

/*
** Copyright (c) 2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

-->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="../../resources/js-test-style.css"/>
<script src="../../js/js-test-pre.js"></script>
<script src="../../js/webgl-test-utils.js"></script>
<script id="myWorker" type="text/worker">
var canvas;
var gl;
var WEBGL_lose_context;
var new_WEBGL_lose_context;
var program;
var allowRestore;
var contextLostEventFired;
var contextRestoredEventFired;
var OES_vertex_array_object;
var old_OES_vertex_array_object;
var OES_texture_float;
var newExtension;

function compareGLError(glError, evalStr)
{
  var exception;
  try {
    eval(evalStr);
  } catch (e) {
    exception = e;
  }
  if (exception) {
    return false;
  } else {
    if (gl.getError() == glError)
      return true;
    return false;
  }
}

self.onmessage = function(e) {
    if (!setupTest())
        self.postMessage("Test failed");

    canvas.addEventListener("webglcontextlost", function(e) {
        if (!testLostContext(e))
            self.postMessage("Test failed");
        // restore the context after this event has exited.
        setTimeout(function() {
            // we didn't call prevent default so we should not be able to restore the context
            if (!compareGLError(gl.INVALID_OPERATION, "WEBGL_lose_context.restoreContext()"))
                self.postMessage("Test failed");
            testLosingAndRestoringContext().then(function() {
                self.postMessage("Test passed");
            }, function() {
                self.postMessage("Test failed");
            });
        }, 0);
    });
    canvas.addEventListener("webglcontextrestored", testShouldNotRestoreContext);
    allowRestore = false;
    contextLostEventFired = false;
    contextRestoredEventFired = false;

    if (!testOriginalContext())
        self.postMessage("Test failed");
    WEBGL_lose_context.loseContext();
    // The context should be lost immediately.
    if (!gl.isContextLost())
        self.postMessage("Test failed");
    if (gl.getError() != gl.CONTEXT_LOST_WEBGL)
        self.postMessage("Test failed");
    if (gl.getError() != gl.NO_ERROR)
        self.postMessage("Test failed");
    // gl methods should be no-ops
    if (!compareGLError(gl.NO_ERROR, "gl.blendFunc(gl.TEXTURE_2D, gl.TEXTURE_CUBE_MAP)"))
        self.postMessage("Test failed");
    // but the event should not have been fired.
    if (contextLostEventFired)
        self.postMessage("Test failed");
}

function setupTest()
{
    canvas = new OffscreenCanvas(10, 10);
    gl = canvas.getContext('webgl');
    WEBGL_lose_context = gl.getExtension("WEBGL_lose_context");
    if (!WEBGL_lose_context)
        return false;

    // Try to get a few extensions
    OES_vertex_array_object = gl.getExtension("OES_vertex_array_object");
    OES_texture_float = gl.getExtension("OES_texture_float");

    return true;
}

function reGetExtensionAndTestForProperty(gl, name, expectProperty) {
  newExtension = gl.getExtension(name);
  // NOTE: while getting a extension after context lost/restored is allowed to fail
  // for the purpose the conformance tests it is not.
  //
  // Hypothetically the user can switch GPUs live. For example on Windows, install 2 GPUs,
  // then in the control panen enable 1, disable the others and visa versa. Since the GPUs
  // have different capabilities one or the other may not support a particlar extension.
  //
  // But, for the purpose of the conformance tests the context is expected to restore
  // on the same GPU and therefore the extensions that succeeded previously should
  // succeed on restore.
  if (newExtension == null)
    return false;
  if (expectProperty) {
    if (!(newExtension.webglTestProperty === true))
      return false;
  } else {
    if (!(newExtension.webglTestProperty === undefined))
      return false;
  }
  return newExtension;
}

function testLosingAndRestoringContext()
{
    return new Promise(function(resolve, reject) {
        if (!setupTest())
            reject("Test failed");

        canvas.addEventListener("webglcontextlost", function(e) {
            if (!testLostContext(e))
              reject("Test failed");
            // restore the context after this event has exited.
            setTimeout(function() {
                if (!compareGLError(gl.NO_ERROR, "WEBGL_lose_context.restoreContext()"))
                    reject("Test failed");
                // The context should still be lost. It will not get restored until the
                // webglrestorecontext event is fired.
                if (!gl.isContextLost())
                    reject("Test failed");
                if (gl.getError() != gl.NO_ERROR)
                    reject("Test failed");
                // gl methods should still be no-ops
                if (!compareGLError(gl.NO_ERROR, "gl.blendFunc(gl.TEXTURE_2D, gl.TEXTURE_CUBE_MAP)"))
                    reject("Test failed");
            }, 0);
        });
        canvas.addEventListener("webglcontextrestored", function() {
            if (!testRestoredContext())
                reject("Test failed");
            else
                resolve("Test passed");
        });
        allowRestore = true;
        contextLostEventFired = false;
        contextRestoredEventFired = false;

        if (!testOriginalContext())
            reject("Test failed");
        WEBGL_lose_context.loseContext();
        // The context should be lost immediately.
        if (!gl.isContextLost())
            reject("Test failed");
        if (gl.getError() != gl.CONTEXT_LOST_WEBGL)
            reject("Test failed");
        if (gl.getError() != gl.NO_ERROR)
            reject("Test failed");
        // gl methods should be no-ops
        if (!compareGLError(gl.NO_ERROR, "gl.blendFunc(gl.TEXTURE_2D, gl.TEXTURE_CUBE_MAP)"))
            reject("Test failed");
        // but the event should not have been fired.
        if (contextLostEventFired)
            reject("Test failed");
    });
}

function testOriginalContext()
{
    if (gl.isContextLost())
        return false;
    if (gl.getError() != gl.NO_ERROR)
        return false;
    return true;
}

function testLostContext(e)
{
    if (contextLostEventFired)
        return false;
    contextLostEventFired = true;
    if (!gl.isContextLost())
        return false;
    if (gl.getError() != gl.NO_ERROR)
        return false;
    if (allowRestore)
      e.preventDefault();
    return true;
}

function testShouldNotRestoreContext(e)
{
    self.postMessage("Test failed");
}

function testOESTextureFloat() {
  if (OES_texture_float) {
    // Extension must still be lost.
    var tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    if (!compareGLError(gl.INVALID_ENUM, "gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, null)"))
        return false;
    // Try re-enabling extension
    OES_texture_float = reGetExtensionAndTestForProperty(gl, "OES_texture_float", false);
    if (!compareGLError(gl.NO_ERROR, "gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, null)"))
        return false;
    return true;
  }
}

function testOESVertexArrayObject() {
  if (OES_vertex_array_object) {
    // Extension must still be lost.
    if (OES_vertex_array_object.createVertexArrayOES() != null)
        return false;
    // Try re-enabling extension

    old_OES_vertex_array_object = OES_vertex_array_object;
    OES_vertex_array_object = reGetExtensionAndTestForProperty(gl, "OES_vertex_array_object", false);
    if (OES_vertex_array_object.createVertexArrayOES() == null)
        return false;
    if (old_OES_vertex_array_object.createVertexArrayOES() != null)
        return false;
    return true;
  }
}

function testExtensions() {
  if (!testOESTextureFloat() || !testOESVertexArrayObject())
    return false;
  // Only the WEBGL_lose_context extension should be the same object after context lost.
  if (!reGetExtensionAndTestForProperty(gl, "WEBGL_lose_context", true))
    return false;
  return true;
}

function testRestoredContext()
{
    if (contextRestoredEventFired)
        return false;
    contextRestoredEventFired = true;
    if (gl.isContextLost())
        return false;
    if (gl.getError() != gl.NO_ERROR) {
        console.log("getError failed");
        return false;
    }

    /*if (!testExtensions())
        return false;*/
    return true;
}
</script>
<script>
function init()
{
  description("Tests behavior under a restored context for OffscreenCanvas in a worker.");

  if (!window.OffscreenCanvas) {
    finishTest();
  }

  function makeWorker(script) {
    var blob = new Blob([script]);
    return new Worker(URL.createObjectURL(blob));
  }

  var successfullyParsed = false;
  var worker = makeWorker(document.getElementById("myWorker").textContent);
  worker.postMessage("Start worker");
  worker.onmessage = function(e) {
    if (e.data == "Test passed") {
      testPassed("All tests have passed");
      successfullyParsed = true;
    } else {
      testFailed("Some test failed");
      successfullyParsed = false;
    }
    finishTest();
  }
}

</script>
</head>
<body onload="init()">
<div id="description"></div>
<div id="console"></div>
</body>
</html>
