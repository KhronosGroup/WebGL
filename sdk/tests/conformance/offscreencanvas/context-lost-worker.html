<!--

/*
** Copyright (c) 2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

-->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="../../resources/js-test-style.css"/>
<script src="../../js/js-test-pre.js"></script>
<script src="../../js/webgl-test-utils.js"></script>
<script id="myWorker" type="text/worker">
var canvas;
var gl;
var extensionName;
var extension;

var buffer;
var framebuffer;
var program;
var renderbuffer;
var shader;
var texture;
var uniformLocation;
var arrayBuffer;
var arrayBufferView
var image;
var video;
var canvas2d;
var ctx2d;
var imageData;
var float32array;
var int32array;
var OES_vertex_array_object;
var vertexArrayObject;

function compareGLError(glError, evalStr)
{
  var exception;
  try {
    eval(evalStr);
  } catch (e) {
    exception = e;
  }
  if (exception) {
    return false;
  } else {
    if (gl.getError() == glError)
      return true;
    return false;
  }
}

var simpleTextureVertexShader = [
  'attribute vec4 vPosition;',
  'attribute vec2 texCoord0;',
  'varying vec2 texCoord;',
  'void main() {',
  '    gl_Position = vPosition;',
  '    texCoord = texCoord0;',
  '}'].join('\n');

var simpleTextureFragmentShader = [
  'precision mediump float;',
  'uniform sampler2D tex;',
  'varying vec2 texCoord;',
  'void main() {',
  '    gl_FragData[0] = texture2D(tex, texCoord);',
  '}'].join('\n');

function getShader(gl, shaderStr, type)
{
  var shader = gl.createShader(type);
  gl.shaderSource(shader, shaderStr);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    return null;
  return shader;
}

function setupProgram(gl, shaders, opt_attribs, opt_locations)
{
  var vertexShader = getShader(gl, simpleTextureVertexShader, gl.VERTEX_SHADER);
  var fragmentShader = getShader(gl, simpleTextureFragmentShader, gl.FRAGMENT_SHADER);
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  if (opt_attribs) {
    for (var ii = 0; ii < opt_attribs.length; ++ii) {
      gl.bindAttribLocation(
          program,
          opt_locations ? opt_locations[ii] : ii,
          opt_attribs[ii]);
    }
  }
  gl.linkProgram(program);

  // Check the link status
  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!linked) {
      // something went wrong with the link
      gl.deleteProgram(program);
      return null;
  }
  gl.useProgram(program);
  return program;
}

function setupSimpleTextureProgram(gl, opt_positionLocation, opt_texcoordLocation)
{
  opt_positionLocation = opt_positionLocation || 0;
  opt_texcoordLocation = opt_texcoordLocation || 1;
  return setupProgram(gl,
                      [simpleTextureVertexShader, simpleTextureFragmentShader],
                      ['vPosition', 'texCoord0'],
                      [opt_positionLocation, opt_texcoordLocation]);
}

self.onmessage = function(e) {
    var canvas = new OffscreenCanvas(10, 10);
    gl = canvas.getContext('webgl');

    // call testValidContext() before checking for the extension, because this is where we check
    // for the isContextLost() method, which we want to do regardless of the extension's presence.
    if (!testValidContext())
        self.postMessage("Test failed");

    extension = gl.getExtension("WEBGL_lose_context");
    if (extension == null)
        self.postMessage("Test failed");

    // need an extension that exposes new API methods.
    OES_vertex_array_object = gl.getExtension("OES_vertex_array_object");

    canvas.addEventListener("webglcontextlost", testLostContext, false);

    // We need to initialize |uniformLocation| before losing context.
    // Otherwise gl.getUniform() when context is lost will throw.
    uniformLocation = gl.getUniformLocation(program, "tex");
    loseContext();
}

function loseContext()
{
    // Note: this will cause the context to be lost, but the
    // webglcontextlost event listener to be queued.
    extension.loseContext();
}

function testValidContext()
{
    if (gl.isContextLost())
        return false;

    arrayBuffer = new ArrayBuffer(4);
    arrayBufferView = new Int8Array(arrayBuffer);

    // Generate resources for testing.
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    program = setupSimpleTextureProgram(gl);
    renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    shader = gl.createShader(gl.VERTEX_SHADER);
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    if (gl.getError() != gl.NO_ERROR)
        return false;

    // Test is queries that will later be false
    if (!compareGLError(gl.NO_ERROR, "gl.enable(gl.BLEND)"))
        return false;
    if (!gl.isBuffer(buffer) || !gl.isEnabled(gl.BLEND) || !gl.isFramebuffer(framebuffer) ||
        !gl.isProgram(program) || !gl.isRenderbuffer(renderbuffer) || !gl.isShader(shader) ||
        !gl.isTexture(texture))
        return false;

    if (OES_vertex_array_object) {
        vertexArrayObject = OES_vertex_array_object.createVertexArrayOES();
        if (gl.getError() != gl.NO_ERROR)
            return false;
        if (!OES_vertex_array_object.isVertexArrayOES(vertexArrayObject))
            return false;
    }
    return true;
}

function testLostContext()
{
    // Functions with special return values.
    if (!gl.isContextLost())
        self.postMessage("Test failed");

    if (gl.getError() != gl.CONTEXT_LOST_WEBGL)
        self.postMessage("Test failed");
    if (gl.getError() != gl.NO_ERROR)
        self.postMessage("Test failed");

    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_UNSUPPORTED ||
        gl.getAttribLocation(program, 'u_modelViewProjMatrix') != -1 ||
        gl.getVertexAttribOffset(0, gl.VERTEX_ATTRIB_ARRAY_POINTER) != 0)
        self.postMessage("Test failed");

    // Test the extension itself.
    if (!compareGLError(gl.INVALID_OPERATION, "extension.loseContext()"))
        self.postMessage("Test failed");

    imageData = new ImageData(1, 1);
    float32array = new Float32Array(1);
    int32array = new Int32Array(1);

    // Functions returning void should return immediately.
    // This is untestable, but we can at least be sure they cause no errors
    // and the codepaths are exercised.
    if (!compareGLError(gl.NO_ERROR, "gl.activeTexture(gl.TEXTURE0)") ||
        !compareGLError(gl.NO_ERROR, "gl.attachShader(program, shader)") ||
        !compareGLError(gl.NO_ERROR, "gl.bindBuffer(gl.ARRAY_BUFFER, buffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.bindTexture(gl.TEXTURE_2D, texture)") ||
        !compareGLError(gl.NO_ERROR, "gl.blendColor(1.0, 1.0, 1.0, 1.0)") ||
        !compareGLError(gl.NO_ERROR, "gl.blendEquation(gl.FUNC_ADD)") ||
        !compareGLError(gl.NO_ERROR, "gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD)") ||
        !compareGLError(gl.NO_ERROR, "gl.blendFunc(gl.ONE, gl.ONE)") ||
        !compareGLError(gl.NO_ERROR, "gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE)") ||
        !compareGLError(gl.NO_ERROR, "gl.bufferData(gl.ARRAY_BUFFER, 0, gl.STATIC_DRAW)") ||
        !compareGLError(gl.NO_ERROR, "gl.bufferData(gl.ARRAY_BUFFER, arrayBufferView, gl.STATIC_DRAW)") ||
        !compareGLError(gl.NO_ERROR, "gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW)") ||
        !compareGLError(gl.NO_ERROR, "gl.bufferSubData(gl.ARRAY_BUFFRE, 0, arrayBufferView)") ||
        !compareGLError(gl.NO_ERROR, "gl.bufferSubData(gl.ARRAY_BUFFRE, 0, arrayBuffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.clear(gl.COLOR_BUFFER_BIT)") ||
        !compareGLError(gl.NO_ERROR, "gl.clearColor(1, 1, 1, 1)") ||
        !compareGLError(gl.NO_ERROR, "gl.clearDepth(1)") ||
        !compareGLError(gl.NO_ERROR, "gl.clearStencil(0)") ||
        !compareGLError(gl.NO_ERROR, "gl.colorMask(1, 1, 1, 1)") ||
        !compareGLError(gl.NO_ERROR, "gl.compileShader(shader)") ||
        !compareGLError(gl.NO_ERROR, "gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.cullFace(gl.FRONT)") ||
        !compareGLError(gl.NO_ERROR, "gl.deleteBuffer(buffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.deleteFramebuffer(framebuffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.deleteProgram(program)") ||
        !compareGLError(gl.NO_ERROR, "gl.deleteRenderbuffer(renderbuffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.deleteShader(shader)") ||
        !compareGLError(gl.NO_ERROR, "gl.deleteTexture(texture)") ||
        !compareGLError(gl.NO_ERROR, "gl.depthFunc(gl.NEVER)") ||
        !compareGLError(gl.NO_ERROR, "gl.depthMask(0)") ||
        !compareGLError(gl.NO_ERROR, "gl.depthRange(0, 1)") ||
        !compareGLError(gl.NO_ERROR, "gl.detachShader(program, shader)") ||
        !compareGLError(gl.NO_ERROR, "gl.disable(gl.BLEND)") ||
        !compareGLError(gl.NO_ERROR, "gl.disableVertexAttribArray(0)") ||
        !compareGLError(gl.NO_ERROR, "gl.drawArrays(gl.POINTS, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.drawElements(gl.POINTS, 0, gl.UNSIGNED_SHORT, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.enable(gl.BLEND)") ||
        !compareGLError(gl.NO_ERROR, "gl.enableVertexAttribArray(0)") ||
        !compareGLError(gl.NO_ERROR, "gl.finish()") ||
        !compareGLError(gl.NO_ERROR, "gl.flush()") ||
        !compareGLError(gl.NO_ERROR, "gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, renderbuffer)") ||
        !compareGLError(gl.NO_ERROR, "gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.frontFace(gl.CW)") ||
        !compareGLError(gl.NO_ERROR, "gl.generateMipmap(gl.TEXTURE_2D)") ||
        !compareGLError(gl.NO_ERROR, "gl.hint(gl.GENERATE_MIPMAP_HINT, gl.FASTEST)") ||
        !compareGLError(gl.NO_ERROR, "gl.lineWidth(0)") ||
        !compareGLError(gl.NO_ERROR, "gl.linkProgram(program)") ||
        !compareGLError(gl.NO_ERROR, "gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.polygonOffset(0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.readPixels(0, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, arrayBufferView)") ||
        !compareGLError(gl.NO_ERROR, "gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.sampleCoverage(0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.scissor(0, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.shaderSource(shader, '')") ||
        !compareGLError(gl.NO_ERROR, "gl.stencilFunc(gl.NEVER, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.stencilFuncSeparate(gl.FRONT, gl.NEVER, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.stencilMask(0)") ||
        !compareGLError(gl.NO_ERROR, "gl.stencilMaskSeparate(gl.FRONT, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP)") ||
        !compareGLError(gl.NO_ERROR, "gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP)") ||
        !compareGLError(gl.NO_ERROR, "gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, arrayBufferView)") ||
        !compareGLError(gl.NO_ERROR, "gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageData)") ||
        !compareGLError(gl.NO_ERROR, "gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)") ||
        !compareGLError(gl.NO_ERROR, "gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)") ||
        !compareGLError(gl.NO_ERROR, "gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, arrayBufferView)") ||
        !compareGLError(gl.NO_ERROR, "gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform1f(uniformLocation, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform1fv(uniformLocation, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform1fv(uniformLocation, [0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform1i(uniformLocation, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform1iv(uniformLocation, int32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform1iv(uniformLocation, [0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform2f(uniformLocation, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform2fv(uniformLocation, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform2fv(uniformLocation, [0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform2i(uniformLocation, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform2iv(uniformLocation, int32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform2iv(uniformLocation, [0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform3f(uniformLocation, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform3fv(uniformLocation, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform3fv(uniformLocation, [0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform3i(uniformLocation, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform3iv(uniformLocation, int32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform3iv(uniformLocation, [0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform4f(uniformLocation, 0, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform4fv(uniformLocation, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform4fv(uniformLocation, [0, 0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform4i(uniformLocation, 0, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform4iv(uniformLocation, int32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniform4iv(uniformLocation, [0, 0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniformMatrix2fv(uniformLocation, false, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniformMatrix2fv(uniformLocation, false, [0, 0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniformMatrix3fv(uniformLocation, false, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniformMatrix3fv(uniformLocation, false, [0, 0, 0, 0, 0, 0, 0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.uniformMatrix4fv(uniformLocation, false, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.uniformMatrix4fv(uniformLocation, false, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.useProgram(program)") ||
        !compareGLError(gl.NO_ERROR, "gl.validateProgram(program)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib1f(0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib1fv(0, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib1fv(0, [0])") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib2f(0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib2fv(0, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib2fv(0, [0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib3f(0, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib3fv(0, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib3fv(0, [0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib4f(0, 0, 0, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib4fv(0, float32array)") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttrib4fv(0, [0, 0, 0, 0])") ||
        !compareGLError(gl.NO_ERROR, "gl.vertexAttribPointer(0, 0, gl.FLOAT, false, 0, 0)") ||
        !compareGLError(gl.NO_ERROR, "gl.viewport(0, 0, 0, 0)"))
        self.postMessage("Test failed");

    // Functions return nullable values should all return null.
    if (gl.createBuffer() != null ||
        gl.createFramebuffer() != null ||
        gl.createProgram() != null ||
        gl.createRenderbuffer() != null ||
        gl.createShader(gl.GL_VERTEX_SHADER) != null ||
        gl.createTexture() != null ||
        gl.getActiveAttrib(program, 0) != null ||
        gl.getActiveUniform(program, 0) != null ||
        gl.getAttachedShaders(program) != null ||
        gl.getBufferParameter(gl.ARRAY_BUFFER, gl.BUFFER_SIZE) != null ||
        gl.getContextAttributes() != null ||
        gl.getFramebufferAttachmentParameter(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) != null ||
        gl.getParameter(gl.CURRENT_PROGRAM) != null ||
        gl.getProgramInfoLog(program) != null ||
        gl.getProgramParameter(program, gl.LINK_STATUS) != null ||
        gl.getRenderbufferParameter(gl.RENDERBUFFER, gl.RENDERBUFFER_WIDTH) != null ||
        gl.getShaderInfoLog(shader) != null ||
        gl.getShaderParameter(shader, gl.SHADER_TYPE) != null ||
        gl.getShaderSource(shader) != null ||
        gl.getTexParameter(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S) != null ||
        gl.getUniform(program, uniformLocation) != null ||
        gl.getUniformLocation(program, 'vPosition') != null ||
        gl.getVertexAttrib(0, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING) != null ||
        gl.getSupportedExtensions() != null ||
        eval("gl.getExtension('" + extensionName + "')") != null)
        self.postMessage("Test failed");

    // "Is" queries should all return false.
    if (gl.isBuffer(buffer) || gl.isEnabled(gl.BLEND) || gl.isFramebuffer(framebuffer) ||
        gl.isProgram(program) || gl.isRenderbuffer(renderbuffer) || gl.isShader(shader) ||
        gl.isTexture(texture))
        self.postMessage("Test failed");

    if (gl.getError() != gl.NO_ERROR)
        self.postMessage("Test failed");

    // test extensions
    if (OES_vertex_array_object) {
        if (!compareGLError(gl.NO_ERROR, "OES_vertex_array_object.bindVertexArrayOES(vertexArrayObject)") ||
            !compareGLError(gl.NO_ERROR, "OES_vertex_array_object.isVertexArrayOES(vertexArrayObject)") ||
            !compareGLError(gl.NO_ERROR, "OES_vertex_array_object.deleteVertexArrayOES(vertexArrayObject)"))
            self.postMessage("Test failed");
        if (OES_vertex_array_object.createVertexArrayOES() != null)
            self.postMessage("Test failed");
    }
    self.postMessage("Test passed");
}

</script>

<script>
function init()
{
  description("Tests behavior under a lost context for OffscreenCanvas in a worker");

  if (!window.OffscreenCanvas) {
    finishTest();
  }

  function makeWorker(script) {
    var blob = new Blob([script]);
    return new Worker(URL.createObjectURL(blob));
  }

  var successfullyParsed = false;
  var worker = makeWorker(document.getElementById("myWorker").textContent);
  worker.postMessage("Start worker");
  worker.onmessage = function(e) {
    if (e.data == "Test passed") {
      testPassed("All tests have passed");
      successfullyParsed = true;
      finishTest();
    } else {
      testFailed("Some tests failed");
      successfullyParsed = false;
      finishTest();
    }
  }
}
</script>
</head>
<body onload="init()">
<div id="description"></div>
<div id="console"></div>
</body>
</html>
