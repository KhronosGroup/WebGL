<!--
Copyright (c) 2020 The Khronos Group Inc.
Use of this source code is governed by an MIT-style license that can be
found in the LICENSE.txt file.
-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>RASTERIZER_DISCARD doesn't affect implicit clears</title>
<link rel="stylesheet" href="../../resources/js-test-style.css"/>
<script src="../../js/js-test-pre.js"></script>
<script src="../../js/webgl-test-utils.js"></script>
<script id="vshader" type="x-shader/x-vertex">#version 300 es
layout(location=0) in vec2 vPosition;
uniform float xTranslation;
void main(void) {
  gl_Position = vec4(vPosition[0] + xTranslation, vPosition[1], 0.0, 1.0);
}
</script>
<script id="fshader" type="x-shader/x-fragment">#version 300 es
precision mediump float;
uniform vec4 color;
out vec4 outColor;
void main() {
  outColor = color;
}
</script>
</head>
<body>
<canvas id="example" width="256" height="256"></canvas>
<div id="description"></div>
<div id="console"></div>
<script>
"use strict";
debug("");

description("Enabling RASTERIZER_DISCARD should not affect implicit clears");

const wtu = WebGLTestUtils;
const gl = wtu.create3DContext("example", undefined, 2);
let leftRectBuffer;
let numFrames = 30;
let xTranslationLoc;
let colorLoc;
const positionLocation = 0;
const red = [ 1.0, 0.0, 0.0, 1.0 ];
const green = [ 0.0, 1.0, 0.0, 1.0 ];
const transparentBlackRender = [ 0, 0, 0, 0 ];
const greenRender = [ 0, 255, 0, 255 ];
const sz = 256; // Must equal canvas width/height

if (!gl) {
    testFailed("WebGL context creation failed");
} else {
    testPassed("WebGL context creation succeeded");
    runTest();
}

function runTest() {
    let prog = wtu.loadProgramFromScript(gl, "vshader", "fshader");
    gl.useProgram(prog);
    xTranslationLoc = gl.getUniformLocation(prog, "xTranslation");
    colorLoc = gl.getUniformLocation(prog, "color");
    leftRectBuffer = gl.createBuffer();
    gl.enableVertexAttribArray(positionLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, leftRectBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
         0.0,  1.0,
        -1.0,  1.0,
        -1.0, -1.0,
         0.0,  1.0,
        -1.0, -1.0,
         0.0, -1.0]), gl.STATIC_DRAW);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    requestAnimationFrame(renderFrame);
}

function renderFrame() {
    // Animation is required in order to expose this bug.
    gl.uniform1f(xTranslationLoc, 0.0);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.uniform4fv(colorLoc, red);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disable(gl.RASTERIZER_DISCARD);

    gl.uniform1f(xTranslationLoc, (30.0 - numFrames) / 30.0);
    gl.uniform4fv(colorLoc, green);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    if (numFrames-- == 0) {
        wtu.checkCanvasRect(gl, 0, 0, sz / 2, sz, transparentBlackRender, undefined, 3);
        wtu.checkCanvasRect(gl, sz / 2, 0, sz / 2, sz, greenRender, undefined, 3);
        finishTest();
    } else {
        requestAnimationFrame(renderFrame);
    }
}

</script>

</body>
</html>
