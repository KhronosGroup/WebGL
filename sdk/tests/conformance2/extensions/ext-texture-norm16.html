<!--
Copyright (c) 2020 The Khronos Group Inc.
Use of this source code is governed by an MIT-style license that can be
found in the LICENSE.txt file.
-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>WebGL EXT_texture_norm16 Conformance Tests</title>
<LINK rel="stylesheet" href="../../resources/js-test-style.css"/>
<script src="../../js/js-test-pre.js"></script>
<script src="../../js/webgl-test-utils.js"></script>
</head>
<body>
<div id="description"></div>
<div id="console"></div>
<script>
"use strict";
description("This test verifies the functionality of the EXT_texture_norm16 extension, if it is available.");

debug("");

var wtu = WebGLTestUtils;
var gl = wtu.create3DContext(null, null, 2);
var ext;

var formats = null;
var textures;
var fbos;
var renderbuffer;
var readbackBuf = new Uint16Array(4);

// DOM image element of different types
var typedArrays = {};
var imageBitmaps = {};
var imageSrc = {};

function loadImage(url) {
  return new Promise((resolve, reject) => {
    let img = new Image();
    img.addEventListener('load', e => resolve(img));
    img.addEventListener('error', () => {
      console.error(`Failed to load image's URL: ${url}`);
      reject(new Error(`Failed to load image's URL: ${url}`));
    });
    img.src = url;
  });
}

function prepareTypedArrays() {
  let pixelValue;

  pixelValue = 0x7fff;
  typedArrays[gl.SHORT] = new Int16Array(4).fill(pixelValue);

  pixelValue = 0x6a35;
  typedArrays[gl.UNSIGNED_SHORT] = new Uint16Array(4).fill(pixelValue);
}

async function prepareImageSrc() {
  await Promise.all([
    loadImage("../../../../resources/1x1-0x7fff-s.png").then((img) => {
      imageSrc[gl.SHORT] = img;
    }),
    loadImage("../../../../resources/1x1-0x6a35.png").then((img) => {
      imageSrc[gl.UNSIGNED_SHORT] = img;

    })
  ]);
}

async function prepareImageBitmaps() {
  if(!window.createImageBitmap || !window.ImageBitmap) {
    debug("ImageBitmap isn't supported");
    return;
  }

  await createImageBitmap(imageSrc[gl.SHORT], 0, 0, 1, 1).then((img) => {
    imageBitmaps[gl.SHORT] = img;
  });

  await createImageBitmap(imageSrc[gl.UNSIGNED_SHORT], 0, 0, 1, 1).then((img) => {
    imageBitmaps[gl.UNSIGNED_SHORT] = img;
  });

  console.log("finish prepare ImageBitmaps");
}

function generateFormatColor(format, value, alpha) {
  alpha = alpha !== undefined ? alpha : 255;
  switch(format) {
    case gl.RED:
      return [value, 0, 0, alpha];
    case gl.RG:
      return [value, value, 0, alpha];
    case gl.RGB:
      return [value, value, value, alpha];
    case gl.RGBA:
      return [value, value, value, value];
    default:
      wtu.error("Unreachable: Unknown format.");
      return null;
  }
}

function texImageSrc(internalFormat, format, type) {
  debug("texFunc: texImageSrc");
  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, format, type, imageSrc[type]);
}

function texImageBitmap(internalFormat, format, type) {
  if(!window.createImageBitmap || !window.ImageBitmap) {
    debug("ImageBitmap isn't supported");
    return;
  }
  debug("texFunc: texImageBitmap");
  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, format, type, imageBitmaps[type]);
}

function texImageTypedArray(internalFormat, format, type) {
  debug("texFunc: texImageTypedArray");
  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, format, type, typedArrays[type]);
}

function testNorm16Texture(texImageFunc, internalFormat, format, type) {
  let expectedValue;
  switch (type) {
    case gl.SHORT:
      expectedValue = 0xffff;
      break;
    case gl.UNSIGNED_SHORT:
      expectedValue = 0x6a35;
      break;
    default:
      wtu.error("Unreachable: Unknown texture type.");
      break;
  }

  // Render to fbo texture attachment test
  gl.bindTexture(gl.TEXTURE_2D, textures[1]);
  gl.texImage2D(gl.TEXTURE_2D, 0, ext.RGBA16_EXT, 1, 1, 0, gl.RGBA, gl.UNSIGNED_SHORT, null);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "rtt bindings succeed");

  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[0]);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[1], 0);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "fbo bindings succeed");

  // Texture sampled from
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, textures[0]);
  texImageFunc(internalFormat, format, type);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "texture bindings succeed");

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  let readbackBuf = new Uint16Array(4);
  wtu.checkCanvasRect(gl, 0, 0, 1, 1, generateFormatColor(format, expectedValue, 0xffff), undefined, 0, readbackBuf, gl.UNSIGNED_SHORT);
}

function testSNorm16TextureImageDisallowed(texImageFunc, internalFormat, format, type) {
  gl.bindTexture(gl.TEXTURE_2D, textures[0]);
  texImageFunc(internalFormat, format, type);
  wtu.glErrorShouldBe(gl, gl.INVALID_ENUM, "uploads from DOM elements to 16-bit SNORM textures are disallowed");
}

function testNorm16Render(texImageFunc, internalFormat, format, type, tolerance) {
  // Only UNSIGNED_SHORT are renderable
  assertMsg(type === gl.UNSIGNED_SHORT, "Only UNSIGNED_SHORT types are renderable");
  let expectedValue = 0x6a35;

  // Render to fbo texture attachment test
  gl.bindTexture(gl.TEXTURE_2D, textures[1]);
  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, format, type, null);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "rtt bindings succeed");

  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[0]);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[1], 0);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "fbo bindings succeed");

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, textures[0]);
  texImageFunc(internalFormat, format, type);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "texture bindings succeed");

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  wtu.checkCanvasRect(gl, 0, 0, 1, 1, generateFormatColor(format, expectedValue, 0xffff), undefined, tolerance, readbackBuf, type);

  // Renderbuffer test
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[1]);
  gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, 1, 1);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER,
                            renderbuffer);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "renderbuffer bindings succeed");

  gl.clearColor(1, 1, 1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  wtu.checkCanvasRect(gl, 0, 0, 1, 1, generateFormatColor(format, 0xffff, 0xffff), undefined, tolerance, readbackBuf, type);

  // Copy from renderbuffer to textures[1] test
  gl.bindTexture(gl.TEXTURE_2D, textures[1]);
  gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, 1, 1);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "copy succeed");

  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[0]);
  wtu.checkCanvasRect(gl, 0, 0, 1, 1, generateFormatColor(format, 0xffff, 0xffff), undefined, tolerance, readbackBuf, type);

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
}

function testSnorm16Unrenderable(internalFormat, format, type) {
  gl.bindTexture(gl.TEXTURE_2D, textures[1]);
  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, format, type, null);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "texture definition succeeded");

  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[0]);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[1], 0);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "fbo binding succeeded");

  wtu.framebufferStatusShouldBe(gl, gl.FRAMEBUFFER, [ gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT, gl.FRAMEBUFFER_UNSUPPORTED ],
                                "framebuffer should not be complete with SNORM16 texture attached");
}

async function runTestExtension() {
  prepareTypedArrays();
  await prepareImageSrc();
  await prepareImageBitmaps();

  textures = [gl.createTexture(), gl.createTexture()];
  fbos = [gl.createFramebuffer(), gl.createFramebuffer()];
  renderbuffer = gl.createRenderbuffer();

  for (let i = 0; i < 2; i++) {
    gl.bindTexture(gl.TEXTURE_2D, textures[i]);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  }

  gl.bindTexture(gl.TEXTURE_2D, null);

  wtu.glErrorShouldBe(gl, gl.NO_ERROR, "texture and framebuffer setup succeed");

  let program300 = wtu.setupSimpleTextureProgramESSL300(gl);
  let program100 = wtu.setupTexturedQuad(gl, 0, 1, wtu.simpleHighPrecisionTextureFragmentShader);

  // Currently skip test for ImageBitmaps and other types
  let texImageFuncs = [texImageTypedArray, texImageSrc];
  for (let i = 0, len = texImageFuncs.length; i < len; i++) {
    testNorm16Texture(texImageFuncs[i], ext.R16_EXT, gl.RED, gl.UNSIGNED_SHORT);
    testNorm16Texture(texImageFuncs[i], ext.RG16_EXT, gl.RG, gl.UNSIGNED_SHORT);
    testNorm16Texture(texImageFuncs[i], ext.RGB16_EXT, gl.RGB, gl.UNSIGNED_SHORT);
    testNorm16Texture(texImageFuncs[i], ext.RGBA16_EXT, gl.RGBA, gl.UNSIGNED_SHORT);
    
    if (texImageFuncs[i] === texImageTypedArray) {
      testNorm16Texture(texImageFuncs[i], ext.R16_SNORM_EXT, gl.RED, gl.SHORT);
      testNorm16Texture(texImageFuncs[i], ext.RG16_SNORM_EXT, gl.RG, gl.SHORT);
      testNorm16Texture(texImageFuncs[i], ext.RGB16_SNORM_EXT, gl.RGB, gl.SHORT);
      testNorm16Texture(texImageFuncs[i], ext.RGBA16_SNORM_EXT, gl.RGBA, gl.SHORT);
    } else {
      testSNorm16TextureImageDisallowed(texImageFuncs[i], ext.R16_SNORM_EXT, gl.RED, gl.SHORT);
      testSNorm16TextureImageDisallowed(texImageFuncs[i], ext.RG16_SNORM_EXT, gl.RG, gl.SHORT);
      testSNorm16TextureImageDisallowed(texImageFuncs[i], ext.RGB16_SNORM_EXT, gl.RGB, gl.SHORT);
      testSNorm16TextureImageDisallowed(texImageFuncs[i], ext.RGBA16_SNORM_EXT, gl.RGBA, gl.SHORT);
    }
  }

  gl.useProgram(program300);

  for (let i = 0, len = texImageFuncs.length; i < len; i++) {
    testNorm16Render(texImageFuncs[i], ext.R16_EXT, gl.RED, gl.UNSIGNED_SHORT, 0);
    testNorm16Render(texImageFuncs[i], ext.RG16_EXT, gl.RG, gl.UNSIGNED_SHORT, 0);
    testNorm16Render(texImageFuncs[i], ext.RGBA16_EXT, gl.RGBA, gl.UNSIGNED_SHORT, 0);
  }

  testSnorm16Unrenderable(ext.R16_SNORM_EXT, gl.RED, gl.SHORT);
  testSnorm16Unrenderable(ext.RG16_SNORM_EXT, gl.RG, gl.SHORT);
  testSnorm16Unrenderable(ext.RGB16_SNORM_EXT, gl.RGB, gl.SHORT);
  testSnorm16Unrenderable(ext.RGBA16_SNORM_EXT, gl.RGBA, gl.SHORT);
};

async function runTest() {
  if (!gl) {
    testFailed("context does not exist");
  } else {
    testPassed("context exists");

    ext = gl.getExtension("EXT_texture_norm16");

    wtu.runExtensionSupportedTest(gl, "EXT_texture_norm16", ext !== null);

    if (ext !== null) {
      await runTestExtension();
    } else {
      testPassed("No EXT_texture_norm16 support -- this is legal");
    }
  }
  finishTest();
}

runTest();

var successfullyParsed = true;
</script>
</body>
</html>
