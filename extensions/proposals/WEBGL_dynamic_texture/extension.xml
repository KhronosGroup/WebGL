<?xml version="1.0" encoding="UTF-8"?>
<!-- vi:set sw=2 ts=4: -->
<proposal href="proposals/WEBGL_dynamic_texture/">
  <name>WEBGL_dynamic_texture</name>

  <contact><a href="https://www.khronos.org/webgl/public-mailing-list/">WebGL
  working group</a> (public_webgl 'at' khronos.org) </contact>

  <contributors>
    <contributor>Mark Callow</contributor>

    <contributor>Ken Russell</contributor>

    <contributor>Acorn Pooley</contributor>

    <contributor>Members of the WebGL working group</contributor>
  </contributors>

  <number>NN</number>

  <depends>
    <api version="1.0"/>
  </depends>

  <overview>
    <p>Texturing with video is currently achieved by using the
    <code>TEXTURE2D</code> target and passing an HTMLVideoElement to
    <code>texImage2D</code>. It is difficult, if not impossible to implement
    video texturing with zero-copy efficiency via this API and it leaves
    synchronization entirely up to the implementation with no way for the
    application to indicate when it needs a complete and stable image and when
    it does not.</p>

    <p>This extension adds the ability to manage video and other textures
    whose image data changes dynamically. Data may be sourced from
    HTMLVideoElements, CanvasElements and ImageElements having multiple frames
    such as animated GIF, APNG and MNG files. It provides functions for
    synchronizing the dynamic source decoder and 3D rendering.</p>

    <mirrors href="http://www.khronos.org/registry/gles/extensions/OES/OES_EGL_image_external.txt"
             name="OES_EGL_image_external">
      <!-- list the deviations here if there are any -->

      <addendum>
        <p>The function <code>EGLImageTargetTexture2DOES</code> and the
        typedef <code>GLeglImageOES</code> are not supported. All references
        to them are omitted. An alternative mechanism is provided for binding
        a dynamic source to a texture.</p>
      </addendum>

      <addendum>
        <p>The paragraph describing synchronization beginning <cite>Sampling
        an external texture which has been modified ...</cite> and ending
        <cite>... to ensure they have taken effect on the the texture, before
        the call to BindTexture is made.)</cite> in section 3.7.14 of the
        amended OpenGL ES 2.0 API specification is replaced with: <blockquote>
        If <code>dynamicTextureAcquireImage()</code> has not been called,
        sampling an external texture will return samples which may correspond
        to image values before, during or after external modification. Calling
        <code>dynamicTextureAcquireImage()</code> guarantees that
        modifications are complete and sampling will always return samples
        corresponding to the image values at the time
        <code>dynamicTextureAcquireImage()</code> returned. To permit external
        modifications to the image once again,
        <code>dynamicTextureReleaseImage()</code> must be called.
        </blockquote></p>
      </addendum>
    </mirrors>

    <features>
      <feature>
        <p>The functions <code>dynamicTextureSetSource</code> for binding
        <code>HTML{Canvas,Image,Video}Elements</code> to a texture are
        available. </p>
      </feature>

      <feature>
        <p>The function <code>dynamicTextureGetSource</code> for querying the
        current dynamic source of a texture is available.</p>
      </feature>

      <feature>
        <p>The functions <code>dynamicTextureAcquireImage</code> and
        <code>dynamicTextureReleaseImage</code> are available. These calls are
        used before and after 3D rendering to prevent modification of the
        image during sampling.</p>
      </feature>

      <glsl extname="OES_EGL_image_external">
        <stage type="fragment"/>
        
        <stage type="vertex"/>
        
        <type name="samplerExternalOES"/>
        
        <function name="texture2D" type="vec4">
          <param name="sampler" type="samplerExternalOES"/>
          
          <param name="coord" type="vec2"/>
        </function>
        
        <function name="texture2DProj" type="vec4">
          <param name="sampler" type="samplerExternalOES"/>
          
          <param name="coord" type="vec3"/>
        </function>
        
        <function name="texture2DProj" type="vec4">
          <param name="sampler" type="samplerExternalOES"/>
          
          <param name="coord" type="vec4"/>
        </function>
      </glsl>
    </features>
  </overview>

  <idl xml:space="preserve">module webgl {
  interface WEBGL_dynamic_texture {
    const GLenum TEXTURE_EXTERNAL_OES = 0x8D65;
    const GLenum SAMPLER_EXTERNAL_OES = 0x8D66;
    const GLenum TEXTURE_BINDING_EXTERNAL_OES = 0x8D67;
    const GLenum REQUIRED_TEXTURE_IMAGE_UNITS_OES = 0x8D68;

    void dynamicTextureSetSource(WebGLTexture texture, HTMLCanvasElement? source);
    void dynamicTextureSetSource(WebGLTexture texture, HTMLImageElement? source);
    void dynamicTextureSetSource(WebGLTexture texture, HTMLVideoElement? source);
    any dynamicTextureGetSource(WebGLTexture texture);
    void dynamicTextureAcquireImage(WebGLTexture texture);
    void dynamicTextureReleaseImage(WebGLTexture texture);
  }; // interface WEBGL_dynamic_texture
}; // module webgl </idl>

  <!-- new functions -->

  <newfun>
    <function name="dynamicTextureSetSource" type="void"><param name="texture"
    type="WebGLTexture"/><param name="source" type="HTMLCanvasElement?"/>Binds
    source <code>source</code> to <code>WebGLTexture texture</code> as the
    source of dynamic images.</function>

    <function name="dynamicTextureSetSource" type="void"><param name="texture"
    type="WebGLTexture"/><param name="source" type="HTMLImageElement?"/>Binds
    source <code>source</code> to <code>WebGLTexture texture</code> as the
    source of dynamic images.</function>

    <function name="dynamicTextureSetSource" type="void"><param name="texture"
    type="WebGLTexture"/><param name="source" type="HTMLVideoElement?"/>Binds
    source <code>source</code> to <code>WebGLTexture texture</code> as the
    source of dynamic images.</function>

    <function name="dynamicTextureGetSource" type="any"/>

    <function name="dynamicTextureAcquireImage" type="void"><param
    name="texture" type="WebGLTexture"/>Acquires a frame from the dynamic
    image source of the <code>texture</code>. The image data is guaranteed not
    to change until <code>dynamicTextureReleaseImage</code> is called.
    Sampling will return samples corresponding to image values at the time
    <code>dynamicTextureAcquireImage</code> returned.</function>

    <function name="dynamicTextureReleaseImage" type="void"><param
    name="texture" type="WebGLTexture"/>Releases the frame lock on the dynamic
    image source of the <code>texture</code>. After this the image data can
    change and sampling will return samples which may correspond to image
    values before, during or after the modification.</function>
  </newfun>

  <!-- new tokens -->

  <newtok>
    <p>The meaning and use of these tokens is exactly as described in <a
    href="http://www.khronos.org/registry/gles/extensions/OES/OES_EGL_image_external.txt">OES_EGL_image_external</a></p>

    <function name="bindTexture" type="void"><param name="target"
    type="GLenum"/><param name="texture"
    type="WebGLTexture?"/><code>TEXTURE_EXTERNAL_OES</code> is accepted as a
    target by the <code>target</code> parameter of
    <code>bindTexture()</code></function>

    <function name="getActiveUniform" type="WebGLActiveInfo?"><param
    name="program" type="WebGLProgram?"/><param name="index"
    type="GLuint"/><code>SAMPLER_EXTERNAL_OES</code> can be returned in the
    <code>type</code> field of the <code>WebGLActiveInfo</code> returned by
    <code>getActiveUniform()</code></function>

    <function name="getParameter" type="any"><param name="pname"
    type="GLenum"/><code>TEXTURE_BINDING_EXTERNAL_OES</code> is accepted by
    the <code>pname</code> parameter of
    <code>getParameter()</code>.</function>

    <function name="getTexParameter*" type="any"><param name="target"
    type="GLenum"/><param name="pname"
    type="GLenum"/><code>REQUIRED_TEXTURE_IMAGE_UNITS_OES</code> is accepted
    as the <code>pname</code> parameter of
    <code>GetTexParameter*()</code></function>
  </newtok>

  <!-- Refer to the <http://www.opengl.org/registry/doc/template.txt> OpenGL
       extension template for a description of these sections. These sections
       should be eliminated for WebGL extensions simply mirroring OpenGL or
       OpenGL ES extensions.
  -->

  <!-- these take XHTML markup as contents -->

  <security/>

  <ipstatus>No known IP claims.</ipstatus>

  <newtypes/>

  <additions>
    <!-- Additions to Chapters of the WebGL Specification-->

    <p>In section 4.3 <cite>Supported GLSL Constructs</cite>, replace the
    paragraph beginning <cite>A WebGL implementation must ...</cite> with the
    following paragraph:<blockquote>A WebGL implementation must only accept
    shaders which conform to The OpenGL ES Shading Language, Version 1.00 <a
    href="https://www.khronos.org/registry/webgl/specs/1.0/#refsGLES20GLSL">[GLES20GLSL]</a>,
    as extended by <a
    href="http://www.khronos.org/registry/gles/extensions/OES/OES_EGL_image_external.txt">OES_EGL_image_external</a>,
    and which do not exceed the minimum functionality mandated in Sections 4
    and 5 of Appendix A. In particular, a shader referencing state variables
    or commands that are available in other versions of GLSL (such as that
    found in versions of OpenGL for the desktop), must not be allowed to
    load.</blockquote></p>

    <p>In section 5.13 <cite>The WebGL Context</cite> , add the following to
    the WebGLRenderingContext interface. Note that until such time as this
    extension enters core WebGL the tokens and commands mentioned below will
    be located on the WebGL_dynamic_texture extension interface shown
    above.<li>In the list following <code>/* GetPName */</code>:<pre
    xml:space="preserve">TEXTURE_BINDING_EXTERNAL = 0x8D67;</pre></li><li>In
    the list following <code>/* TextureParameterName */</code>:<pre
    xml:space="preserve">REQUIRED_TEXTURE_IMAGE_UNITS = 0x8D68;</pre></li><li>In
    the list following <code>/* TextureTarget */</code>:<pre
    xml:space="preserve">TEXTURE_EXTERNAL = 0x8D65;</pre></li><li>In the list
    following <code>/* Uniform Types */</code>:<pre xml:space="preserve">SAMPLER_EXTERNAL = 0x8D66;</pre></li><li>In
    the alphabetical list of commands add the following :<pre
    xml:space="preserve">void dynamicTextureAcquireImage(WebGLTexture texture);
any dynamicTextureGetSource(WebGLTexture texture);
void dynamicTextureReleaseImage(WebGLTexture texture);
void dynamicTextureSetSource(WebGLTexture texture, HTMLCanvasElement? source);
void dynamicTextureSetSource(WebGLTexture texture, HTMLImageElement? source);
void dynamicTextureSetSource(WebGLTexture texture, HTMLVideoElement? source);</pre></li></p>

    <p>In section 5.13.3 <cite>Setting and getting state</cite>, add the
    following to the table under <code>getParameter</code>.</p>

    <table>
      <tr>
        <td>TEXTURE_BINDING_EXTERNAL</td>

        <td>int</td>
      </tr>
    </table>

    <p/>

    <p>In section 5.13.8<cite>Texture objects</cite>, add the following to the
    table under <code>getTexParameter</code>.</p>

    <table>
      <tr>
        <td>REQUIRED_TEXTURE_IMAGE_UNITS</td>

        <td>int</td>
      </tr>
    </table>

    <p/>

    <p>Add a new section 5.13.8.1 Dynamic textures.</p>

    <blockquote>
      <h3>5.13.8.1 Dynamic textures</h3>

      <p>Dynamic textures are texture objects whose images change outside the
      control of the WebGL application and asynchronously with its rendering.
      The commands<pre class="idl-code" xml:space="preserve">void dynamicTextureSetSource(WebGLTexture texture, HTMLCanvasElement? source);
void dynamicTextureSetSource(WebGLTexture texture, HTMLImageElement? source);
void dynamicTextureSetSource(WebGLTexture texture, HTMLVideoElement? source);</pre>bind
      the given dynamic source <code>source</code> to the texture object. If
      <code>source</code> is null any previous source binding is removed.</p>

      <p>The command<pre class="idl-code" xml:space="preserve">any? dynamicTextureGetSource(WebGLTexture texture, HTMLCanvasElement? source);</pre>returns
      a handle to the currently bound dynamic source.</p>

      <p>The command<pre class="idl-code" xml:space="preserve">void dynamicTextureAcquireImage(WebGLTexture texture);</pre>waits
      for any pending modifications to the image to complete and locks the
      image to prevent further changes. The image is guaranteed not to change
      until the command<pre class="idl-code" xml:space="preserve">void dynamicTextureReleaseImage(WebGLTexture texture);</pre>is
      called. If <code>dynamicTextureAcquireImage</code> is not called before
      the texture is sampled, the returned sample may be taken before, during
      or after external modifications to the image data potentially causing
      tearing of the image on the textured primitive.</p>

      <p><code>dynamicTextureAcquireImage</code> and
      <code>dynamicTextureReleaseImage</code> generate an INVALID_OPERATION
      error if no dynamic source is bound to the texture.</p>

      <p>To sample a dynamic texture, the texture object must be bound to the
      target <code>TEXTURE_EXTERNAL</code> and the sampler uniform must be of
      type <code>samplerExternal</code>. If the texture object bound to
      <code>TEXTURE_EXTERNAL</code> is not bound to a dynamic source the
      sampler will return the RGBA value (0,0,0,1). If a texture object to
      which a dynamic source is bound is bound to a texture target other than
      <code>TEXTURE_EXTERNAL</code> the dynamic source will be ignored. Data
      will be sampled from the texture object's regular data store.</p>
    </blockquote>

    <p>In section 5.13.10 <cite>Uniforms and attributes</cite>, add the
    following to the table under <code>getUniform</code>.</p>

    <table>
      <tr>
        <td>samplerExternal</td>

        <td>long</td>
      </tr>
    </table>

    <p/>

    <p>At the end of section 6 <cite>Differences between WebGL and OpenGL
    ES</cite>, add the following new sections.</p>

    <blockquote>
      <h3>EGLImage Support</h3>

      <p>The function <code>EGLImageTargetTexture2DOES</code> and the typedef
      <code>GLeglImageOES</code> are not supported by WebGL. Instead use
      <code>dynamicTextureSetSource</code> with HTML canvas, image and video
      elements.</p>

      <h3>Synchronizing dynamic images and rendering</h3>

      <p>The paragraph about using external mechanisms for synchronizing
      external images and rendering in section <cite>3.7.14 External
      Textures</cite> beginning <cite>Sampling an external texture which has
      been modified ...</cite> and ending <cite>... to ensure they have taken
      effect on the the texture, before the call to BindTexture is
      made.)</cite> is not applicable to WebGL as those external mechanisms do
      not exist in WebGL or in the web browser. Synchronization is
      accomplished with <code>dynamicTextureAcquireImage()</code> and
      <code>dynamicTextureReleaseImage()</code>. If
      <code>dynamicTextureAcquireImage()</code> has not been called, sampling
      a dynamic texture will return samples which may correspond to image
      values before, during or after external modification. Calling
      <code>dynamicTextureAcquireImage()</code> guarantees that modifications
      are complete and sampling will always return samples corresponding to
      the image values at the time <code>dynamicTextureAcquireImage()</code>
      returned. To permit external modifications to the image once again,
      <code>dynamicTextureReleaseImage()</code> must be called.</p>
    </blockquote>
  </additions>

  <errors/>

  <newstate/>

  <newimplstate/>

  <!-- New Implementation-Dependent State -->

  <samplecode>
    <div class="example">This a fragment shader that samples a video texture.
    Note that the surrounding <code>&lt;script&gt;</code> tag is not
    essential; it is merely one way to include shader text in an HTML
    file.<pre xml:space="preserve">&lt;script id="fshader" type="x-shader/x-fragment"&gt;
  #extension OES_EGL_image_external : enable 
  precision mediump float;

  uniform samplerExternalOES videoSampler;

  varying float v_Dot;
  varying vec2 v_texCoord;

  void main()
  {
    vec2 texCoord = vec2(v_texCoord.s, 1.0 - v_texCoord.t);
    vec4 color = texture2D(videoSampler, texCoord);
    color += vec4(0.1, 0.1, 0.1, 1);
    gl_FragColor = vec4(color.xyz * v_Dot, color.a);
  }
&lt;/script&gt;</pre></div>

    <div class="example">This shows fragments from an application that renders
    a spinning cube textured with a live video.<pre xml:space="preserve">&lt;html&gt;
&lt;script type="text/javascript"&gt;

  ///////////////////////////////////////////////////////////////////////
  // Create a video texture and bind a source to it.
  ///////////////////////////////////////////////////////////////////////

  // Array of files currently loading
  g_loadingFiles = [];

  // Clears all the files currently loading.
  // This is used to handle context lost events.
  function clearLoadingFiles() {
    for (var ii = 0; ii &lt; g_loadingFiles.length; ++ii) {
      g_loadingFiles[ii].onload = undefined;
    }
    g_loadingFiles = [];
  }

  //
  // createVideoTexture
  //
  // Load video from the passed HTMLVideoElement id, bind it to a new WebGLTexture object
  // and return the WebGLTexture.
  //
  // Is their a constructor for an HTMLVideoElement so you can do like "new Image()?"
  //
  function createVideoTexture(ctx, videoId)
  {
    var texture = ctx.createTexture();
    var video = document.getElementById(videoId);
    g_loadingFiles.push(video);
    video.onload = function() { doBindVideo(ctx, video, texture) }
    return texture;
  }

  function doBindVideo(ctx, video, texture)
  {
    g_loadingFiles.splice(g_loadingFiles.indexOf(image), 1);
    ctx.bindTexture(ctx.TEXTURE_EXTERNAL_OES, texture);
    ctx.dynamicTextureSetSource(texture, video);
    // These are the default values of these properties so the following
    // 4 lines are not necessary.
    ctx.texParameteri(ctx.TEXTURE_EXTERNAL_OES, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_EXTERNAL_OES, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_EXTERNAL_OES, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_EXTERNAL_OES, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_EXTERNAL_OES, null);
  }

  ///////////////////////////////////////////////////////////////////////
  // Initialize the application.
  ///////////////////////////////////////////////////////////////////////

  var g = {};
  var videoTexture;

  function init()
  {
    // Initialize
    var gl = initWebGL(
        // The id of the Canvas Element
        "example");
    if (!gl) {
      return;
    }
    var program = simpleSetup(
        gl,
        // The ids of the vertex and fragment shaders
        "vshader", "fshader",
        // The vertex attribute names used by the shaders.
        // The order they appear here corresponds to their index
        // used later.
        [ "vNormal", "vColor", "vPosition"],
        // The clear color and depth values
        [ 0, 0, 0.5, 1 ], 10000);

    // Set some uniform variables for the shaders
    gl.uniform3f(gl.getUniformLocation(program, "lightDir"), 0, 0, 1);
    // Use the default texture unit 0 for the video
    gl.uniform1i(gl.getUniformLocation(program, "samplerExternal"), 0);

    // Create a box. On return 'gl' contains a 'box' property with
    // the BufferObjects containing the arrays for vertices,
    // normals, texture coords, and indices.
    g.box = makeBox(gl);

    // Load an image to use. Returns a WebGLTexture object
    videoTexture = createVideoTexture(gl, "video");
    // Bind the video texture
    gl.bindTexture(gl.TEXTURE_EXTERNAL_OES, videoTexture);

    // Create some matrices to use later and save their locations in the shaders
    g.mvMatrix = new J3DIMatrix4();
    g.u_normalMatrixLoc = gl.getUniformLocation(program, "u_normalMatrix");
    g.normalMatrix = new J3DIMatrix4();
    g.u_modelViewProjMatrixLoc =
            gl.getUniformLocation(program, "u_modelViewProjMatrix");
    g.mvpMatrix = new J3DIMatrix4();

    // Enable all of the vertex attribute arrays.
    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);
    gl.enableVertexAttribArray(2);

    // Set up all the vertex attributes for vertices, normals and texCoords
    gl.bindBuffer(gl.ARRAY_BUFFER, g.box.vertexObject);
    gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, g.box.normalObject);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, g.box.texCoordObject);
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);

    // Bind the index array
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, g.box.indexObject);

    return gl;
  }

  // ...

  ///////////////////////////////////////////////////////////////////////
  // Draw a frame
  ///////////////////////////////////////////////////////////////////////
  function draw(gl)
  {
    // Make sure the canvas is sized correctly.
    reshape(gl);

    // Clear the canvas
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Make a model/view matrix.
    g.mvMatrix.makeIdentity();
    g.mvMatrix.rotate(20, 1,0,0);
    g.mvMatrix.rotate(currentAngle, 0,1,0);

    // Construct the normal matrix from the model-view matrix and pass it in
    g.normalMatrix.load(g.mvMatrix);
    g.normalMatrix.invert();
    g.normalMatrix.transpose();
    g.normalMatrix.setUniform(gl, g.u_normalMatrixLoc, false);

    // Construct the model-view * projection matrix and pass it in
    g.mvpMatrix.load(g.perspectiveMatrix);
    g.mvpMatrix.multiply(g.mvMatrix);
    g.mvpMatrix.setUniform(gl, g.u_modelViewProjMatrixLoc, false);

    // Acquire the latest video image
    gl.dynamicTextureAcquireImage(videoTexture);

    // Draw the cube
    gl.drawElements(gl.TRIANGLES, g.box.numIndices, gl.UNSIGNED_BYTE, 0);

    // Allow updates to the image again
    gl.dynamicTextureReleaseImage(videoTexture);

    // Show the framerate
    framerate.snapshot();

    currentAngle += incAngle;
    if (currentAngle &gt; 360)
      currentAngle -= 360;
  }
&lt;/script&gt;

&lt;body onload="start()"&gt;
&lt;video id="video" src="resources/video.ogv" autoplay="true" style="visibility: hidden"&gt;
&lt;/video&gt;
&lt;canvas id="example"&gt;
    If you're seeing this your web browser doesn't support the &amp;lt;canvas&amp;gt; element. Ouch!
&lt;/canvas&gt;
&lt;div id="framerate"&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</pre></div>
  </samplecode>

  <tests/>

  <issues>
    <ol>
      <li>
        <p>Why not use <code>TexImage2D</code> and the <code>TEXTURE2D</code>
        target?</p>

        <p>RESOLVED: Use a new texture target and sampler type and new
        commands. Using <code>TexImage2D</code>, it is very difficult to build
        an implementation that doe not require copying or converting the data
        from the dynamic image. A zero-copy implementation is likely to need
        special code when sampling a YUV format dynamic image in a shader.
        Identifying which calls in a shader program will sample from a static
        image and which from a dynamic image with only one sampler type is
        difficult and may require run-time recompilation. Furthermore the
        existing API offers no mechanism by which an application can indicate
        when it will be rendering using a particular dynamic source. In order
        to avoid tearing, an implementation has to lock the dynamic image
        around the entire call into the WebGL application's Javascript
        potentially stalling the video decoder. Lastly interactions with, or
        lack thereof, with <code>TexSubImage*</code>,
        <code>CopyTexImage*</code> and the myriad other parameters of
        the<code>{Copy,}Tex*Image*</code> family of commands need to be
        documented, coded and conformance tested, opening up a large surface
        for the introduction of bugs. </p>
      </li>

      <li>
        <p>Why not mirror all of <a
        href="http://www.khronos.org/registry/gles/extensions/OES/OES_EGL_image_external.txt">
        OES_EGL_image_external</a>?</p>

        <p>RESOLVED: Do not mirror all of <a
        href="http://www.khronos.org/registry/gles/extensions/OES/OES_EGL_image_external.txt">
        OES_EGL_image_external</a>. On the Web platform, a
        <code>GLeglImageOES</code> has no use other than as an intermediary to
        pass the handle of a dynamic HTMLElement to a texture. The mechanism
        by which applications are expected to synchronize GL rendering and
        video decoding requires exposing eglFenceSync commands that may not be
        available on every platform. It is better to replace these parts with
        methods better suited to the Web platform that are at a level
        high-enough to be implementable on any hardware platform.</p>
      </li>

      <li>
        <p>Should the API be implemented as methods on the texture object or
        commands taking a texture object as a parameter?</p>

        <p>UNRESOLVED: the ideal way to provide this API is to add
        <code>setSource()</code>, <code>acquireImage()</code>and
        <code>releaseImage()</code> as methods on <code>WebGLTexture</code>.
        This is not in the spirit of the WebGL API due to its heritage from
        OpenGL ES. Also it is not clear if enabling an extension can cause
        methods to be added to an object. If not then a new object type
        derived from <code>WebGLTexture</code> can be used, should this more
        object oriented approach be desired. See also issue #4.</p>
      </li>

      <li>
        <p>Should dynamic textures be a new texture type or can
        <code>WebGLTexture</code> be reused?</p>

        <p>UNRESOLVED: Other than as explained in issue #3 there seems to be
        no benefit to creating a new texture type as the target to which the
        texture is bound and the type of sampler used determine how to sample
        the texture and the presence or absence of a dynamic source affects
        only the result of sampling.</p>
      </li>

      <li>
        <p>Should we re-use <code>#extension OES_EGL_image_external</code>,
        create our own GLSL extension name or have both this and a
        WebGL-specific name?</p>

        <p>UNRESOLVED: Having EGL_IMAGE in the name is confusing but using the
        same name permits the same shader to be used with both WebGL and
        OpenGL ES 2.0.</p>
      </li>

      <li>
        <p>What should happen when an object of type
        <code>HTMLCanvasElement</code>, <code>HTMLImageElement</code> or
        <code>HTMLVideoElement</code>is passed to the existing
        <code>tex*Image2D</code> commands?</p>

        <p>UNRESOLVED: Suggestion: for single-frame HTMLImageElement set the
        texture image to the HTMLImageElement; for an animated
        HTMLImageElement set the texture image to the first frame of the
        animation; for an HTMLCanvasElement, set the texture image to the
        current canvas image that would be returned by toDataURL; for an
        HTMLVideoElement, set the texture image to the current frame. In all
        cases, the texture image does not change until a subsequent call to a
        <code>tex*Image2D</code> command. <em>Is this a change from the way
        any of these elements are handled today?</em></p>
      </li>

      <li>
        <p>Should <code>dynamicTextureAcquireImage</code> and
        <code>dynamicTextureReleaseImage</code> generate errors if called when
        the image is already in the state to be set or ignore those extra
        calls?</p>

        <p>UNRESOLVED:</p>
      </li>

      <li>
        <p>This API is implementable on any platform at varying levels of
        efficiency. Should it therefore move directly to core rather than
        being an extension?</p>

        <p>UNRESOLVED:</p>
      </li>

      <li>
        <p>Should this extension use direct texture access commands or should
        it use <code>texParameter</code> and <code>getTexParameter</code>?</p>

        <p>UNRESOLVED: Currently direct texture access commands are used.
        Using <code>texParameter</code> doesn't seem unreasonable for binding
        the dynamic source but doesn't feel right for acquireImage and
        releaseImage as that state is not a texture parameter. For an
        application with dynamic sources bound to multiple texture units,
        direct texture access is much more convenient.</p>
      </li>
    </ol>
  </issues>

  <history>
    <revision date="2012/07/05">
      <change>Initial revision.</change>
    </revision>

    <revision date="2012/07/06">
      <change>Fixed incorrect dependency and minor naming inconsistencies.
      Fixed missing parameter error and moved the location of the bindTexture
      call in the sample code.</change>
    </revision>
  </history>
</proposal>
