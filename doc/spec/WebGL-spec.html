<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>WebGL Specification</title>
    <meta name="generator" content="BBEdit 9.1">
    <link rel="stylesheet" type="text/css" href="Khronos-WD.css" />
    <link rel="stylesheet" type="text/css" href="default.css" />
    <script src="jquery-1.3.2.min.js" type="text/javascript"></script>
    <script src="generateTOC.js" type="text/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class=head>
        <p>
            <a href="http://khronos.org/">
                <img alt=Khronos height=60 src="KhronosGroup-3D.png" width=220>
            </a>
        </p>
    </div>
    <!--end-logo-->
    
    <h1>WebGL Specification</h1>
    <h2 class="no-toc">Editor's Draft 8 October 2009</h2>
    <dl>
        <dt>This version:
            <dd>
                <a href="https://cvs.khronos.org/svn/repos/3dweb/trunk/doc/spec/WebGL-spec.html">
                    https://cvs.khronos.org/svn/repos/3dweb/trunk/doc/spec/WebGL-spec.html
                </a>
            </dd>
        <dt>Latest version:
            <dd>
                <a href="https://cvs.khronos.org/svn/repos/3dweb/trunk/doc/spec/WebGL-spec.html">
                    https://cvs.khronos.org/svn/repos/3dweb/trunk/doc/spec/WebGL-spec.html
                </a>
            </dd>
        <dt>Previous version:
            <dd>
                <a href="https://cvs.khronos.org/svn/repos/3dweb/trunk/doc/spec/Overview.html">
                    https://cvs.khronos.org/svn/repos/3dweb/trunk/doc/spec/Overview.html
                </a>
            </dd>
        <dt>Editor:
            <dd>
                <a href="mailto:cmarrin@apple.com">Chris Marrin</a>
                <a href="http://www.apple.com/">(Apple Inc)</a>
            </dd>
    </dl>

    <!--begin-copyright-->
    <p class=copyright>
        This draft specification is Khronos Confidential
    </p>
    <!--end-copyright-->
    
    <hr />
    
    <h2 class="no-toc">Abstract</h2>
    <p>
        This specification describes an additional rendering context and support
        objects for the
        <a
            href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html"
            title="HTML 5 Canvas Element">
            HTML 5 <span class="prop-name">canvas</span> element.
        </a>
        This context allows rendering using an API that conforms closely to the OpenGL ES 2.0 API.
    </p>

    <h2 class="no-toc">Status of this document</h2>
    
    <!--begin-status-->
    <p>
        This is a private copy of the editors' draft. It is provided for
        internal discussion only and may change at any moment. Its publication here does
        not imply endorsement of its contents by Khronos. Don't cite this document
        other than as work in progress.
    </p>

    <p>
        The (<a href="https://www.khronos.org/members/login/list_archives/3dweb/">archived</a>) 
        internal mailing list <a href="mailto:3dweb@khronos.org">3dweb@khronos.org</a> (see
        <a href="http://www.khronos.org/cgi-bin/majordomo_ui/majordomo">instructions</a>) is 
        preferred for discussion of this specification.
    </p>
    <!--end-status-->
    
    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>
    <p>
        <em>This section is not normative.</em>
    </p>

    <p>
        The HTMLCanvasElement places an element on the page into which graphic
        images can be rendered using a programmatic interface. Currently the only
        such interface described is the CanvasRenderingContext2D. This document
        describes another such interface, WebGLRenderingContext, which presents
        and API derived from the OpenGL ES 2.0 specification. This API provides a
        rich set of functions allowing realistic 3D graphics to be rendered.
    </p>
    <p>
        More details needed here...
    </p>

    <div class=issue>
        <p>
            This is where issues would go
        </p>
    </div>

<!-- ======================================================================================================= -->

    <h2>Context Creation and Drawing Buffer Presentation</h2>

    <p>
        Before using the WebGL API, the author must obtain a WebGLRenderingContext object
        for a given HTMLCanvasElement as described below. This object is used to manage 
        OpenGL state and render to the drawing context, which must also be created at the time of
        context creation.. The author may supply configuration options for this drawing buffer, otherwise
        default values shall be used as specified elsewhere in this document. This drawing buffer
        is presented to the HTML page compositor immediately before an HTML page compositing operation, 
        but only if the drawing buffer has been modified since the last compositing operation.
    </p>
    
<!-- ======================================================================================================= -->

    <h3>The <span class=prop-name>&lsquo;<code class=property>canvas</code>&rsquo;</span> Element</h3>

    <p>
        A WebGLRenderingContext object shall be created by calling the getContext() method of 
        a given HTMLCanvasElement object with the exact string &lsquo;<code class=property>webgl</code>&rsquo;. 
        This string is case sensitive. When called for the first time, a 
        WebGLRenderingContext object is created and returned. Also at this time a drawing buffer
        shall be created. Subsequent calls to getContext() with the same string shall return the same object. 
        If getContext() is subsequently called with any other string, the WebGLRenderingContext shall 
        be detached from its Canvas object (the <code>canvas</code> attribute will be null). API calls may
        still be made on the WebGLRenderingContext object and readPixels() may be used
        to obtain the contents of the drawing buffer. But the contents shall no longer be shown
        on the page.
    </p>
        A second parameter may be passed to the getContext() function. If passed, this parameter 
        shall be a WebGLContextAttributes object containing configuration parameters to be used in 
        creating the drawing buffer. See <a href="#5.2">section 5.2</a> for more details. On subsequent 
        calls to getContext() with the &lsquo;<code class=property>webgl</code>&rsquo; string, the passed
        WebGLContextAttributes object, if any, shall be ignored.
    <p>
    </p>
    
<!-- ======================================================================================================= -->

    <h3>The Drawing Buffer</h3>

    <p>
        The drawing buffer into which the API calls are rendered shall be defined upon creation of
        the WebGLRenderingContext object. The size of this drawing buffer shall be determined by the
        <code>width</code> and <code>height</code> attributes of the HTMLCanvasElement. Changing
        either of these attributes shall cause the drawing buffer to resize and its contents to be
        cleared to (0,0,0,0).
    </p>
    <p>
        By default, the drawing buffer has an RGBA color buffer of at least 8 bits per component 
        and an integer depth buffer of at least 16 bits. The optional WebGLContextAttributes 
        object may be used to change these defaults. This object is only used on the first call
        to getContext. No facility is provided to change the attributes of the drawing buffer 
        after its creation.
    </p>
    <p>
        WebGL presents its drawing buffer to the HTML page compositor immediately before a compositing 
        operation, but only if the drawing buffer has been modified since the last compositing operation.
        Before the drawing buffer is presented for compositing the implementation shall ensure that all 
        rendering operations have been flushed to the drawing buffer. After compositing the contents of 
        the drawing buffer shall be undefined but must not contain uninitialized pixels.
    </p>
    
<!-- ======================================================================================================= -->

    <h2>WebGL Resources</h2>

    <p> 
        OpenGL manages several type of resources as part of its state. These are identified
        by integer object names and are obtained from OpenGL by various creation calls.
        In contrast WebGL represents these resources as DOM objects. Each object is derived 
        from the WebGLObject interface. Currently supported resources are:
        textures, buffers (i.e., VBOs) framebuffers, renderbuffers, shaders and
        programs. The WebGLRenderingContext interface has a method to create a 
        WebGLObject subclass for each type. Data from the underlying graphics library are
        stored in these objects and are fully managed by them. The resources represented
        by these objects are guaranteed to exist as long as the object exists.
        Furthermore, the DOM object is guaranteed to exist as long as the author has an explicit
        valid reference to it OR as long as it is bound by the underlying graphics library.
        When none of these conditions exist the user agent can, at any point, delete the object 
        using the equivalent of a delete call (e.g., deleteTexture). If authors wishes to control 
        when the underlying resource is released then the delete call can be made explicitly.
    </p>

<!-- ======================================================================================================= -->

    <h2>Security</h2>

    <p> 
    </p>

<!-- ======================================================================================================= -->

    <h3>WebGLArrayBuffer and Uninitialized Data</h3>

    <p>
        Data present in a <a href="WebGLArrayBuffer">WebGLArrayBuffer</a> can be read by the application directly 
        by creating a <a href="WebGLArrayBuffer">WebGLArray</a> view of the data or indirectly by via rendering 
        and using a method such as <code>readPixels</code>.  At creation time, a WebGLArrayBuffer 
        must be initialized from existing user data or must be cleared to 0.  
        Additionally, the WebGL implementation must ensure that no data outside of 
        the valid byte range for a WebGLArrayBuffer can be accessed.  If a caller 
        attempts to access any data outside of that range, an implementation may 
        choose to raise an exception, use the closest valid index, use 0, or any 
        other approach that prevents it from providing access to uninitialized data.
    </p>

<!-- ======================================================================================================= -->

    <h3>Resource Restrictions</h3>

    <p>
        WebGL resources such as textures and vertex buffer objects (VBOs) must always 
        contain initialized data, even if they were created without initial user 
        data values.  Creating a resource without initial values is commonly used to 
        reserve space for a texture or VBO, which is then modified using <code>texSubImage</code> or 
        <code>bufferSubData</code> calls.  If initial data is not provided to these calls, 
        the WebGL implementation must initialize their contents 
        to 0.  For example, this may require creating a temporary buffer of 0 
        values the size of a requested VBO, so that it can be initialized 
        correctly.  All other forms of loading data into a texture or VBO 
        involve either WebGLArrayBuffers or DOM objects such as images, 
        and are therefore already required to be initialized.
    </p>

    <p>
        When WebGL resources are accessed by shaders through a call such as 
        <code>drawElements</code> or <code>drawArrays</code>, the WebGL implementation must ensure 
        that the shader cannot access either out of bounds or uninitialized 
        data.  For drawArrays, each bound VBO must be at least as large as 
        needed to satisfy the given mode, offset, and count.  For drawElements, 
        the bound index buffer must be at least large enough to satisfy the 
        requested mode, count, type, and offset, and the highest index in the 
        index buffer range must be a valid index for every bound VBO.
    </p>

<!-- ======================================================================================================= -->

    <h3>Origin Restrictions</h3>

    <p>
        In order to prevent information leakage, the HTML5 canvas element has
        a <i>origin-clean</i> flag.  (See HTML5, section 4.8.11.3, "Security with canvas
        elements".)  For a WebGL context, the <i>origin-clean</i> flag must be set to false
        if any of the following actions occur:
    </p>
        <ul>
            <li>The <code>texImage2D</code> method is called with an <code>HTMLImageElement</code> or 
                <code>HTMLVideoElement</code> whose origin is not the same as that of the Document 
                object that owns the canvas element.
            <li>The <code>texImage2D</code> method is called with an <code>HTMLCanvasElement</code> 
                whose <i>origin-clean</i> flag is set to false.
        </ul>
    <p>
        Whenever the <code>readPixels</code> method of the 2D context of a <code>canvas</code> 
        element whose <i>origin-clean</i> flag is set to false is called with otherwise correct 
        arguments, the method must raise a <code>SECURITY_ERR</code> exception.
    </p>

<!-- ======================================================================================================= -->

    <h3>Supported GLSL Constructs</h3>

    <p>
        A user agent must not accept shaders which do not conform to The OpenGL ES Shading Language, 
        Version 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a>. In particular, a shader
        referencing state variables or functions that are available in other versions of GLSL (such
        as that found in versions of OpenGL for the desktop), must not be allowed to load.
    </p>

<!-- ======================================================================================================= -->

    <h3>Defense Against Denial of Service</h3>

    <p>
    <i>This section is non-normative.</i>
    </p>

    <p>
    It is possible to create, either intentionally or unintentionally, combinations of shaders and
    geometry that take an undesirably long time to render. This issue is analogous to that of
    long-running scripts, for which user agents already have safeguards. However, long-running draw
    calls can cause loss of interactivity for the entire window system, not just the user agent.
    </p>

    <p>
    In the general case it is not possible to impose limits on the structure of incoming shaders to
    guard against this problem. Experimentation has shown that even very strict structural limits
    are insufficient to prevent long rendering times, and such limits would prevent shader authors
    from implementing common algorithms.
    </p>

    <p>
    User agents should implement safeguards to prevent excessively long rendering times and
    associated loss of interactivity. Suggested safeguards include:
    </p>

    <ul>

    <li> Splitting up draw calls with large numbers of elements into smaller draw calls.

    <li> Timing individual draw calls and forbidding further rendering from a page if a certain
         timeout is exceeded.

    <li> Using any watchdog facilities available at the user level, graphics API level, or operating
         system level to limit the duration of draw calls.

    <li> Separating the graphics rendering of the user agent into a distinct operating system
         process which can be terminated and restarted without losing application state.

    </ul>

    <p>
    The supporting infrastructure at the OS and graphics API layer is expected to improve over time,
    which is why the exact nature of these safeguards is not specified.
    </p>

<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

<!-- ======================================================================================================= -->

    <h3>WebGLContextAttributes</h3>

    <p>
        The <code>WebGLContextAttributes</code> interface contains drawing surface attributes 
        and is passed as the second parameter to getContext. This interface holds key/value
        pairs, where each key and value is a string. The keys identify the feature being set to 
        the given value, which is typically a boolean ("true" or "false") or numeric value.
    </p>
    <pre class="idl">interface <dfn id="WebGLContextAttributes">WebGLContextAttributes</dfn> {
    [NameGetter] DOMString get(in DOMString name);
    [NameSetter, NameCreator] void set(in DOMString name, in DOMString value);
    [NameDeleter] void remove(in DOMString name);
};</pre>

    <h4>Context creation parameters</h4>

    <p>
        The following list describes each key/value pair in the WebGLContextAttributes 
        object and its use. For each key the default value is shown. If a key is present, 
        the value is a <code>DOMString</code>. For keys expecting a numerica value, the 
        string is converted to a number. For keys expecting a boolean value, the string 
        "true" (case-insensitive) or any string which converts to a number other than 0 
        is considered to be <code>true</code>. All other values are considered 
        <code>false</code>.
    </p>
    <dl>
        <dt><span class=prop-value>alpha</span></dt>
            <dd>
                <em>Default: true</em>. If the value is true, the drawing buffer has 
                an alpha channel for the purposes of performing OpenGL destination 
                alpha operations and compositing with the page. If the value is false, 
                no alpha buffer is available.
            </dd>
        <dt> <span class=prop-value>depth</span>
            <dd>
                <em>Default: true</em>. If the value is true,  the drawing buffer has a 
                depth buffer of at least 16 bits. If the value is false, 
                no depth buffer is available.
           </dd>
        <dt> <span class=prop-value>stencil</span>
            <dd>
                <em>Default: true</em>. If the value is true,  the drawing buffer has a 
                stencil buffer of at least 8 bits. If  the value is false, 
                no stencil buffer is available.
            </dd>
        <dt> <span class=prop-value>antialias</span>
            <dd>
                <em>Default: true</em>. If the value is true and the implementation 
                supports antialiasing the drawing buffer will perform antialiasing using 
                its choice of technique (multisample/supersample) and quality. If the value 
                is false or the implementation does not support antialiasing, no antialiasing 
                is performed.
            </dd>
        <dt> <span class=prop-value>premultipliedAlpha</span>
            <dd>
                <em>Default: true</em>. If the value is true the page compositor will assume 
                the drawing buffer contains colors with premultiplied alpha. If the value is 
                false the page compositor will assume that colors in the drawing buffer are not 
                premultiplied. This flag is ignored if the <strong>alpha</strong> flag is false.
            </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h3>WebGLObject</h3>

    <p>
        The <code>WebGLObject</code> interface is the parent interface for all GL objects.
    </p>
    <pre class="idl">interface <dfn id="WebGLObject">WebGLObject</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLBuffer</h3>

    <p>
        The <code>WebGLBuffer</code> interface represents an OpenGL Buffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenBuffers.xml">
            glGenBuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindBuffer.xml">
        glBindBuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteBuffers.xml">
        glDeleteBuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLBuffer">WebGLBuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLFramebuffer</h3>

    <p>
        The <code>WebGLFramebuffer</code> interface represents an OpenGL Framebuffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenFramebuffers.xml">
            glGenFramebuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindFramebuffer.xml">
        glBindFramebuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteFramebuffers.xml">
        glDeleteFramebuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLFramebuffer">WebGLFramebuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLProgram</h3>

    <p>
        The <code>WebGLProgram</code> interface represents an OpenGL Program Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateProgram.xml">
            glCreateProgram
        </a>
        , used as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUseProgram.xml">
        glUseProgram 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteProgram.xml">
        glDeleteProgram.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLProgram">WebGLProgram</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLRenderbuffer</h3>

    <p>
        The <code>WebGLRenderbuffer</code> interface represents an OpenGL Renderbuffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenRenderbuffers.xml">
            glGenRenderbuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindRenderbuffer.xml">
        glBindRenderbuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteRenderbuffers.xml">
        glDeleteRenderbuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderbuffer">WebGLRenderbuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLShader</h3>

    <p>
        The <code>WebGLShader</code> interface represents an OpenGL Shader Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateShader.xml">
            glCreateShader
        </a>
        , attached to a Program as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glAttachShader.xml">
        glAttachShader 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteShader.xml">
        glDeleteShader.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLShader">WebGLShader</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLTexture</h3>

    <p>
        The <code>WebGLTexture</code> interface represents an OpenGL Texture Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenTextures.xml">
            glGenTextures
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindTexture.xml">
        glBindTexture 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteTextures.xml">
        glDeleteTextures.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLTexture">WebGLTexture</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLObjectArray</h3>

    <p>
        The <code>WebGLObjectArray</code> interface represents an array of WebGLObject objects.
    </p>
    <pre class="idl">interface <dfn id="WebGLObjectArray">WebGLObjectArray</dfn> {
    readonly attribute unsigned long length;
    [IndexGetter] WebGLObject get(in unsigned long index);
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLUniformLocation</h3>

    <p>
        The <code>WebGLUniformLocation</code> interface represents the location of a uniform variable 
        in a shader program.
    </p>
    <pre class="idl">interface <dfn id="WebGLUniformLocation">WebGLUniformLocation</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLActiveInfo</h3>

    <p>
        The <code>WebGLActiveInfo</code> interface represents the information returned 
        from the getActiveAttrib and getActiveUniform calls.
    </p>
    <pre class="idl">interface <dfn id="WebGLActiveInfo">WebGLActiveInfo</dfn> {
    readonly attribute GLint size;
    readonly attribute GLenum type;
    readonly attribute DOMString name;
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-size">
                    size
                </a>
            </code> 
            of type <code>GLint</code>
        <dd>
            The size of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-type">
                    type
                </a>
            </code> 
            of type <code>GLenum</code>
        <dd>
            The data type of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-name">
                    name
                </a>
            </code> 
            of type <code>DOMString</code>
        <dd>
            The name of the requested variable.
    </dl>

<!-- ======================================================================================================= -->

    <h3>WebGLArrayBuffer</h3>

    <p>
        The <code>WebGLArrayBuffer</code> interface describes the buffer used to store data 
        for the WebGLArray interface and its subclasses.
    </p>
    <pre class="idl">
[ Constructor(in unsigned long length) ]
interface <dfn id="WebGLArrayBuffer">WebGLArrayBuffer</dfn> {
    readonly attribute unsigned long byteLength;
};</pre>

    <h4>Constructors</h4>

    <dl class="methods">
        <dt><code>Constructor(length)</code>
        <dd>
            Create a new WebGLArrayBuffer of the passed length in bytes. Data in the buffer is 
            initialized to 0.
    </dl>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArrayBuffer-byteLength">
                    byteLength
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The length of the buffer in bytes.  The length is fixed when the WebGLArrayBuffer is created.
    </dl>
    
<!-- ======================================================================================================= -->

    <h3>WebGLArray</h3>

    <p>
        The <code>WebGLArray</code> interface is the abstract base interface for all 
        the typed array interfaces.  Every <code>WebGLArray</code> subclass presents a typed view of a <a href="WebGLArrayBuffer">WebGLArrayBuffer</a> region.  Multiple <code>WebGLArray</code>s can reference the same or overlapping regions of a <a href="WebGLArrayBuffer">WebGLArrayBuffer</a>.
    </p>
    <pre class="idl">
interface <dfn id="WebGLArray">WebGLArray</dfn> {
    readonly attribute WebGLArrayBuffer buffer;
    readonly attribute unsigned long byteOffset;
    readonly attribute unsigned long byteLength;
    readonly attribute unsigned long length;

    WebGLArray slice(in unsigned long offset, in unsigned long length);
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-buffer">
                    buffer
                </a>
            </code> 
            of type <code>WebGLArrayBuffer</code>
        <dd>
            The WebGLArrayBuffer holding the data for this array.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-byteOffset">
                    byteOffset
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The offset of this data, in bytes, from the start of this <a id="WebGLArray">WebGLArray</a>'s <a id="WebGLArrayBuffer">WebGLArrayBuffer</a>.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-byteLength">
                    byteLength
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The length of this data in bytes.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-length">
                    length
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The length of this data in elements.
    </dl>

    <h4>slice method</h4>

    <dl class="methods">
        <dt><code>slice(offset, length)</code>
        <dd>
	  <p>
             Returns a new <a href="#WebGLArray">WebGLArray</a> view
             of the <a href="#WebGLArrayBuffer">WebGLArrayBuffer</a>
             store for this <a href="#WebGLArray">WebGLArray</a>,
             referencing the element at offset in the current view,
             and containing length elements.
	  </p>
	  <p>
	     The returned <a href="#WebGLArray">WebGLArray</a> will
	     be of the same underlying type as the
	     original <a href="#WebGLArray">WebGLArray</a>.
	  </p>
    </dl>

    <h4>Typed WebGLArray Interfaces</h4>

    <p>
      A <code>WebGLArray</code> is intended to be an abstract base
      interface for WebGLArrays of a specific type.  There is no way
      to create a <code>WebGLArray</code>, but there are constructors
      defined for each of the typed interfaces.  The following
      sections define the shared constructors and methods that each
      typed interface implements.
    </p>
    <p>
      The typed <code>WebGLArray</code> views provide access to data
      using indexing, and also provide a bulk set method for replacing
      a sequence of data from another array.  A summary of all the
      typed <code>WebGLArray</code> views is given in the
      following table.
    </p>

    <center><table>
      <thead>
	<tr><th><i>TypeName</i></th><th>Element Size<br>(bytes)</th><th>Type</th><th>Equivalent C Type</th></tr>
      </thead>
      <tbody>
	<tr><td>Byte</td><td>1</td><td>8-bit signed integer</td><td><code>signed char</code></td></tr>
	<tr><td>UnsignedByte</td><td>1</td><td>8-bit unsigned integer</td><td><code>unsigned char</code></td></tr>
	<tr><td>Short</td><td>2</td><td>16-bit signed integer</td><td><code>short</code></td></tr>
	<tr><td>UnsignedShort</td><td>2</td><td>16-bit unsigned integer</td><td><code>unsigned short</code></td></tr>
	<tr><td>Int</td><td>4</td><td>32-bit signed integer</td><td><code>int</code></td></tr>
	<tr><td>UnsignedInt</td><td>4</td><td>32-bit unsigned integer</td><td><code>unsigned int</code></td></tr>
	<tr><td>Float</td><td>4</td><td>32-bit floating point</td><td><code>float</code></td></tr>
      </tbody>
    </table></center>

    <p>
      All of the typed <code>WebGLArray</code> views have the following IDL template:
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGL<i>TypeName</i>Array array)
    Constructor(in sequence&lt;<i>type</i>&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface WebGL<i>TypeName</i>Array : WebGLArray {
    [IndexGetter] <i>type</i> get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in <i>type</i> value);
    void set(in WebGL<i>TypeName</i>Array array, [Optional] in unsigned long offset);
    void set(in sequence&lt;<i>type</i>&gt; array, [Optional] in unsigned long offset);
};</pre>


    <h5>Shared Constructors</h5>

    <dl class="methods">
        <dt><code>Constructor(length)</code>
        <dd>
            Create a new WebGL<i>TypeName</i>Array object of the given length with a new
            underlying WebGLArrayBuffer large enough to hold <code>length</code>
            elements of the specific type. Data in the buffer is initialized to 0.
        <dt><code>Constructor(array)</code>
        <dd>
            Create a new WebGL<i>TypeName</i>Array object with a new underlying
            WebGLArrayBuffer large enough to hold the given data, then copy the passed
            data into the buffer.
        <dt><code>Constructor(buffer, byteOffset, length)</code>
        <dd>
      <p>
            Create a new WebGL<i>TypeName</i>Array object using the passed
            WebGLArrayBuffer for its storage. Optional byteOffset and length can be used
            to limit the section of the buffer referenced. The byteOffset indicates the
            offset in bytes from the start of the WebGLArrayBuffer, and the length is the
            count of elements from the offset that this WebGLByteArray will reference.
            If both byteOffset and length are omitted, the WebGL<i>TypeName</i>Array
            spans the entire WebGLArrayBuffer range.  If the length is omitted, the
            WebGL<i>TypeName</i>Array extends from the given byteOffset until the end of
            the WebGLArrayBuffer.
      </p>
      <p>
        The given byteOffset must be a multiple of the element size of the specific
        type, otherwise an exception is raised.
      </p>
      <p>
        If a given byteOffset and length references an area beyond the end of the
            WebGLArrayBuffer an exception is raised.
      </p>
    </dl>

    <h5>Shared Getters and Setters</h5>

    <dl class="methods">
        <dt><code>get(index)</code>
        <dd>
      Return the element at the given index.  If the index is out of range, an exception is raised.  This is an index getter function, and may be invoked via array index syntax where applicable.
        <dt><code>set(index, value)</code>
        <dd>
      <p>
        Sets the element at the given index to the given value.  If the index is out of range, an exception is raised.  This is an index setter function, and may be invoked via array index syntax where applicable.
      </p>
      <p>
        If the given value is out of range for the type of the array, a C-style cast operation is performed to coerce the value to the valid range.  No clamping or rounding is performed.
      </p>
        <dt><code>set(array, offset)</code>
        <dd>
      <p>
        Set multiple values, reading input values from the array.  The optional offset
        value indicates the index in the current array where values are written.  If
        omitted, it is assumed to be 0.
      </p>
      <p>
	If the offset plus the length of the given array is out of
	range for the current <code>WebGLArray</code>, an exception
	is raised.
      </p>
    </dl>

    <h5>WebGLByteArray</h5>

    <p>
      A <code>WebGLByteArray</code> represents an array of 8-bit signed integer values.
    </p>
    <p>
      A <code>WebGLByteArray</code> has an element size of 1 byte.
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGLByteArray array)
    Constructor(in sequence&lt;long&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface <dfn id="WebGLByteArray">WebGLByteArray</dfn> : WebGLArray {
    [IndexGetter] long get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in long value);
    void set(in WebGLByteArray array, [Optional] in unsigned long offset);
    void set(in sequence&lt;long&gt; array, [Optional] in unsigned long offset);
};</pre>

    <h5>WebGLUnsignedByteArray</h5>

    <p>
      A <code>WebGLUnsignedByteArray</code> represents an array of 8-bit unsigned integer values.
    </p>
    <p>
      A <code>WebGLUnsignedByteArray</code> has an element size of 1 byte.
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGLUnsignedByteArray array)
    Constructor(in sequence&lt;unsigned long&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface <dfn id="WebGLUnsignedByteArray">WebGLUnsignedByteArray</dfn> : WebGLArray {
    [IndexGetter] unsigned long get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in unsigned long value);
    void set(in WebGLUnsignedByteArray array, [Optional] in unsigned long offset);
    void set(in sequence&lt;unsigned long&gt; array, [Optional] in unsigned long offset);
};</pre>

    <h5>WebGLShortArray</h5>

    <p>
      A <code>WebGLShortArray</code> represents an array of 16-bit signed integer values.
    </p>
    <p>
      A <code>WebGLShortArray</code> has an element size of 2 bytes.
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGLShortArray array)
    Constructor(in sequence&lt;long&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface <dfn id="WebGLShortArray">WebGLShortArray</dfn> : WebGLArray {
    [IndexGetter] long get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in long value);
    void set(in WebGLShortArray array, [Optional] in unsigned long offset);
    void set(in sequence&lt;long&gt; array, [Optional] in unsigned long offset);
};</pre>

    <h5>WebGLUnsignedShortArray</h5>

    <p>
      A <code>WebGLUnsignedShortArray</code> represents an array of 16-bit unsigned integer values.
    </p>
    <p>
      A <code>WebGLUnsignedShortArray</code> has an element size of 2 bytes.
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGLUnsignedShortArray array)
    Constructor(in sequence&lt;unsigned long&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface <dfn id="WebGLUnsignedShortArray">WebGLUnsignedShortArray</dfn> : WebGLArray {
    [IndexGetter] unsigned long get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in unsigned long value);
    void set(in WebGLUnsignedShortArray array, [Optional] in unsigned long offset);
    void set(in sequence&lt;unsigned long&gt; array, [Optional] in unsigned long offset);
};</pre>


    <h5>WebGLIntArray</h5>

    <p>
      A <code>WebGLIntArray</code> represents an array of 32-bit signed integer values.
    </p>
    <p>
      A <code>WebGLIntArray</code> has an element size of 4 bytes.
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGLIntArray array)
    Constructor(in sequence&lt;long&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface <dfn id="WebGLIntArray">WebGLIntArray</dfn> : WebGLArray {
    [IndexGetter] long get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in long value);
    void set(in WebGLIntArray array, [Optional] in unsigned long offset);
    void set(in sequence&lt;long&gt; array, [Optional] in unsigned long offset);
};</pre>

    <h5>WebGLUnsignedIntArray</h5>

    <p>
      A <code>WebGLUnsignedIntArray</code> represents an array of 32-bit unsigned integer values.
    </p>
    <p>
      A <code>WebGLUnsignedIntArray</code> has an element size of 4 bytes.
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGLUnsignedIntArray array)
    Constructor(in sequence&lt;unsigned long&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface <dfn id="WebGLUnsignedIntArray">WebGLUnsignedIntArray</dfn> : WebGLArray {
    [IndexGetter] unsigned long get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in unsigned long value);
    void set(in WebGLUnsignedIntArray array, [Optional] in unsigned long offset);
    void set(in sequence&lt;unsigned long&gt; array, [Optional] in unsigned long offset);
};</pre>

    <h5>WebGLFloatArray</h5>

    <p>
      A <code>WebGLFloatArray</code> represents an array of 32-bit floating point values.
    </p>
    <p>
      A <code>WebGLFloatArray</code> has an element size of 4 bytes.
    </p>

    <pre class="idl">
[
    Constructor(in unsigned long length),
    Constructor(in WebGLFloatArray array)
    Constructor(in sequence&lt;float&gt; array)
    Constructor(in WebGLArrayBuffer buffer, 
                [Optional] in unsigned long byteOffset, [Optional] in unsigned long length)
]
interface <dfn id="WebGLFloatArray">WebGLFloatArray</dfn> : WebGLArray {
    [IndexGetter] float get(in unsigned long index);
    [IndexSetter] void set(in unsigned long index, in float value);
    void set(in WebGLFloatArray array, [Optional] in unsigned long offset);
    void set(in sequence&lt;float&gt; array, [Optional] in unsigned long offset);
};</pre>

<!-- ======================================================================================================= -->

    <h3>The WebGL context</h3>

    <p>
        The <code>WebGLRenderingContext</code> represents the API allowing
        OpenGL ES 2.0 style rendering into the canvas element.
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderingContext">WebGLRenderingContext</dfn> {

    typedef unsigned long  GLenum;
    typedef boolean        GLboolean;
    typedef unsigned long  GLbitfield;
    typedef long           GLint;
    typedef long           GLsizei;
    typedef long           GLsizeiptr;
    typedef unsigned long  GLuint;
    typedef float          GLfloat;
    typedef float          GLclampf;
    
    /* ClearBufferMask */
    const GLenum DEPTH_BUFFER_BIT               = 0x00000100;
    const GLenum STENCIL_BUFFER_BIT             = 0x00000400;
    const GLenum COLOR_BUFFER_BIT               = 0x00004000;
    
    /* BeginMode */
    const GLenum POINTS                         = 0x0000;
    const GLenum LINES                          = 0x0001;
    const GLenum LINE_LOOP                      = 0x0002;
    const GLenum LINE_STRIP                     = 0x0003;
    const GLenum TRIANGLES                      = 0x0004;
    const GLenum TRIANGLE_STRIP                 = 0x0005;
    const GLenum TRIANGLE_FAN                   = 0x0006;
    
    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* BlendingFactorDest */
    const GLenum ZERO                           = 0;
    const GLenum ONE                            = 1;
    const GLenum SRC_COLOR                      = 0x0300;
    const GLenum ONE_MINUS_SRC_COLOR            = 0x0301;
    const GLenum SRC_ALPHA                      = 0x0302;
    const GLenum ONE_MINUS_SRC_ALPHA            = 0x0303;
    const GLenum DST_ALPHA                      = 0x0304;
    const GLenum ONE_MINUS_DST_ALPHA            = 0x0305;
    
    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    const GLenum DST_COLOR                      = 0x0306;
    const GLenum ONE_MINUS_DST_COLOR            = 0x0307;
    const GLenum SRC_ALPHA_SATURATE             = 0x0308;
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */
    
    /* BlendEquationSeparate */
    const GLenum FUNC_ADD                       = 0x8006;
    const GLenum BLEND_EQUATION                 = 0x8009;
    const GLenum BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
    const GLenum BLEND_EQUATION_ALPHA           = 0x883D;
    
    /* BlendSubtract */
    const GLenum FUNC_SUBTRACT                  = 0x800A;
    const GLenum FUNC_REVERSE_SUBTRACT          = 0x800B;
    
    /* Separate Blend Functions */
    const GLenum BLEND_DST_RGB                  = 0x80C8;
    const GLenum BLEND_SRC_RGB                  = 0x80C9;
    const GLenum BLEND_DST_ALPHA                = 0x80CA;
    const GLenum BLEND_SRC_ALPHA                = 0x80CB;
    const GLenum CONSTANT_COLOR                 = 0x8001;
    const GLenum ONE_MINUS_CONSTANT_COLOR       = 0x8002;
    const GLenum CONSTANT_ALPHA                 = 0x8003;
    const GLenum ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
    const GLenum BLEND_COLOR                    = 0x8005;
    
    /* Buffer Objects */
    const GLenum ARRAY_BUFFER                   = 0x8892;
    const GLenum ELEMENT_ARRAY_BUFFER           = 0x8893;
    const GLenum ARRAY_BUFFER_BINDING           = 0x8894;
    const GLenum ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;
    
    const GLenum STREAM_DRAW                    = 0x88E0;
    const GLenum STATIC_DRAW                    = 0x88E4;
    const GLenum DYNAMIC_DRAW                   = 0x88E8;
    
    const GLenum BUFFER_SIZE                    = 0x8764;
    const GLenum BUFFER_USAGE                   = 0x8765;
    
    const GLenum CURRENT_VERTEX_ATTRIB          = 0x8626;
    
    /* CullFaceMode */
    const GLenum FRONT                          = 0x0404;
    const GLenum BACK                           = 0x0405;
    const GLenum FRONT_AND_BACK                 = 0x0408;
    
    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* EnableCap */
    const GLenum TEXTURE_2D                     = 0x0DE1;
    const GLenum CULL_FACE                      = 0x0B44;
    const GLenum BLEND                          = 0x0BE2;
    const GLenum DITHER                         = 0x0BD0;
    const GLenum STENCIL_TEST                   = 0x0B90;
    const GLenum DEPTH_TEST                     = 0x0B71;
    const GLenum SCISSOR_TEST                   = 0x0C11;
    const GLenum POLYGON_OFFSET_FILL            = 0x8037;
    const GLenum SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
    const GLenum SAMPLE_COVERAGE                = 0x80A0;
    
    /* ErrorCode */
    const GLenum NO_ERROR                       = 0;
    const GLenum INVALID_ENUM                   = 0x0500;
    const GLenum INVALID_VALUE                  = 0x0501;
    const GLenum INVALID_OPERATION              = 0x0502;
    const GLenum OUT_OF_MEMORY                  = 0x0505;
    
    /* FrontFaceDirection */
    const GLenum CW                             = 0x0900;
    const GLenum CCW                            = 0x0901;
    
    /* GetPName */
    const GLenum LINE_WIDTH                     = 0x0B21;
    const GLenum ALIASED_POINT_SIZE_RANGE       = 0x846D;
    const GLenum ALIASED_LINE_WIDTH_RANGE       = 0x846E;
    const GLenum CULL_FACE_MODE                 = 0x0B45;
    const GLenum FRONT_FACE                     = 0x0B46;
    const GLenum DEPTH_RANGE                    = 0x0B70;
    const GLenum DEPTH_WRITEMASK                = 0x0B72;
    const GLenum DEPTH_CLEAR_VALUE              = 0x0B73;
    const GLenum DEPTH_FUNC                     = 0x0B74;
    const GLenum STENCIL_CLEAR_VALUE            = 0x0B91;
    const GLenum STENCIL_FUNC                   = 0x0B92;
    const GLenum STENCIL_FAIL                   = 0x0B94;
    const GLenum STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
    const GLenum STENCIL_PASS_DEPTH_PASS        = 0x0B96;
    const GLenum STENCIL_REF                    = 0x0B97;
    const GLenum STENCIL_VALUE_MASK             = 0x0B93;
    const GLenum STENCIL_WRITEMASK              = 0x0B98;
    const GLenum STENCIL_BACK_FUNC              = 0x8800;
    const GLenum STENCIL_BACK_FAIL              = 0x8801;
    const GLenum STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
    const GLenum STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
    const GLenum STENCIL_BACK_REF               = 0x8CA3;
    const GLenum STENCIL_BACK_VALUE_MASK        = 0x8CA4;
    const GLenum STENCIL_BACK_WRITEMASK         = 0x8CA5;
    const GLenum VIEWPORT                       = 0x0BA2;
    const GLenum SCISSOR_BOX                    = 0x0C10;
    /*      SCISSOR_TEST */
    const GLenum COLOR_CLEAR_VALUE              = 0x0C22;
    const GLenum COLOR_WRITEMASK                = 0x0C23;
    const GLenum UNPACK_ALIGNMENT               = 0x0CF5;
    const GLenum PACK_ALIGNMENT                 = 0x0D05;
    const GLenum MAX_TEXTURE_SIZE               = 0x0D33;
    const GLenum MAX_VIEWPORT_DIMS              = 0x0D3A;
    const GLenum SUBPIXEL_BITS                  = 0x0D50;
    const GLenum RED_BITS                       = 0x0D52;
    const GLenum GREEN_BITS                     = 0x0D53;
    const GLenum BLUE_BITS                      = 0x0D54;
    const GLenum ALPHA_BITS                     = 0x0D55;
    const GLenum DEPTH_BITS                     = 0x0D56;
    const GLenum STENCIL_BITS                   = 0x0D57;
    const GLenum POLYGON_OFFSET_UNITS           = 0x2A00;
    /*      POLYGON_OFFSET_FILL */
    const GLenum POLYGON_OFFSET_FACTOR          = 0x8038;
    const GLenum TEXTURE_BINDING_2D             = 0x8069;
    const GLenum SAMPLE_BUFFERS                 = 0x80A8;
    const GLenum SAMPLES                        = 0x80A9;
    const GLenum SAMPLE_COVERAGE_VALUE          = 0x80AA;
    const GLenum SAMPLE_COVERAGE_INVERT         = 0x80AB;
    
    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */
    
    const GLenum NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
    const GLenum COMPRESSED_TEXTURE_FORMATS     = 0x86A3;
    
    /* HintMode */
    const GLenum DONT_CARE                      = 0x1100;
    const GLenum FASTEST                        = 0x1101;
    const GLenum NICEST                         = 0x1102;
    
    /* HintTarget */
    const GLenum GENERATE_MIPMAP_HINT            = 0x8192;
    
    /* DataType */
    const GLenum BYTE                           = 0x1400;
    const GLenum UNSIGNED_BYTE                  = 0x1401;
    const GLenum SHORT                          = 0x1402;
    const GLenum UNSIGNED_SHORT                 = 0x1403;
    const GLenum INT                            = 0x1404;
    const GLenum UNSIGNED_INT                   = 0x1405;
    const GLenum FLOAT                          = 0x1406;
    
    /* PixelFormat */
    const GLenum DEPTH_COMPONENT                = 0x1902;
    const GLenum ALPHA                          = 0x1906;
    const GLenum RGB                            = 0x1907;
    const GLenum RGBA                           = 0x1908;
    const GLenum LUMINANCE                      = 0x1909;
    const GLenum LUMINANCE_ALPHA                = 0x190A;
    
    /* PixelType */
    /*      UNSIGNED_BYTE */
    const GLenum UNSIGNED_SHORT_4_4_4_4         = 0x8033;
    const GLenum UNSIGNED_SHORT_5_5_5_1         = 0x8034;
    const GLenum UNSIGNED_SHORT_5_6_5           = 0x8363;
    
    /* Shaders */
    const GLenum FRAGMENT_SHADER                  = 0x8B30;
    const GLenum VERTEX_SHADER                    = 0x8B31;
    const GLenum MAX_VERTEX_ATTRIBS               = 0x8869;
    const GLenum MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
    const GLenum MAX_VARYING_VECTORS              = 0x8DFC;
    const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
    const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
    const GLenum MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
    const GLenum MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
    const GLenum SHADER_TYPE                      = 0x8B4F;
    const GLenum DELETE_STATUS                    = 0x8B80;
    const GLenum LINK_STATUS                      = 0x8B82;
    const GLenum VALIDATE_STATUS                  = 0x8B83;
    const GLenum ATTACHED_SHADERS                 = 0x8B85;
    const GLenum ACTIVE_UNIFORMS                  = 0x8B86;
    const GLenum ACTIVE_UNIFORM_MAX_LENGTH        = 0x8B87;
    const GLenum ACTIVE_ATTRIBUTES                = 0x8B89;
    const GLenum ACTIVE_ATTRIBUTE_MAX_LENGTH      = 0x8B8A;
    const GLenum SHADING_LANGUAGE_VERSION         = 0x8B8C;
    const GLenum CURRENT_PROGRAM                  = 0x8B8D;
    
    /* StencilFunction */
    const GLenum NEVER                          = 0x0200;
    const GLenum LESS                           = 0x0201;
    const GLenum EQUAL                          = 0x0202;
    const GLenum LEQUAL                         = 0x0203;
    const GLenum GREATER                        = 0x0204;
    const GLenum NOTEQUAL                       = 0x0205;
    const GLenum GEQUAL                         = 0x0206;
    const GLenum ALWAYS                         = 0x0207;
    
    /* StencilOp */
    /*      ZERO */
    const GLenum KEEP                           = 0x1E00;
    const GLenum REPLACE                        = 0x1E01;
    const GLenum INCR                           = 0x1E02;
    const GLenum DECR                           = 0x1E03;
    const GLenum INVERT                         = 0x150A;
    const GLenum INCR_WRAP                      = 0x8507;
    const GLenum DECR_WRAP                      = 0x8508;
    
    /* StringName */
    const GLenum VENDOR                         = 0x1F00;
    const GLenum RENDERER                       = 0x1F01;
    const GLenum VERSION                        = 0x1F02;
    const GLenum EXTENSIONS                     = 0x1F03;
    
    /* TextureMagFilter */
    const GLenum NEAREST                        = 0x2600;
    const GLenum LINEAR                         = 0x2601;
    
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    const GLenum NEAREST_MIPMAP_NEAREST         = 0x2700;
    const GLenum LINEAR_MIPMAP_NEAREST          = 0x2701;
    const GLenum NEAREST_MIPMAP_LINEAR          = 0x2702;
    const GLenum LINEAR_MIPMAP_LINEAR           = 0x2703;
    
    /* TextureParameterName */
    const GLenum TEXTURE_MAG_FILTER             = 0x2800;
    const GLenum TEXTURE_MIN_FILTER             = 0x2801;
    const GLenum TEXTURE_WRAP_S                 = 0x2802;
    const GLenum TEXTURE_WRAP_T                 = 0x2803;
    
    /* TextureTarget */
    /*      TEXTURE_2D */
    const GLenum TEXTURE                        = 0x1702;
    
    const GLenum TEXTURE_CUBE_MAP               = 0x8513;
    const GLenum TEXTURE_BINDING_CUBE_MAP       = 0x8514;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
    const GLenum MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;
    
    /* TextureUnit */
    const GLenum TEXTURE0                       = 0x84C0;
    const GLenum TEXTURE1                       = 0x84C1;
    const GLenum TEXTURE2                       = 0x84C2;
    const GLenum TEXTURE3                       = 0x84C3;
    const GLenum TEXTURE4                       = 0x84C4;
    const GLenum TEXTURE5                       = 0x84C5;
    const GLenum TEXTURE6                       = 0x84C6;
    const GLenum TEXTURE7                       = 0x84C7;
    const GLenum TEXTURE8                       = 0x84C8;
    const GLenum TEXTURE9                       = 0x84C9;
    const GLenum TEXTURE10                      = 0x84CA;
    const GLenum TEXTURE11                      = 0x84CB;
    const GLenum TEXTURE12                      = 0x84CC;
    const GLenum TEXTURE13                      = 0x84CD;
    const GLenum TEXTURE14                      = 0x84CE;
    const GLenum TEXTURE15                      = 0x84CF;
    const GLenum TEXTURE16                      = 0x84D0;
    const GLenum TEXTURE17                      = 0x84D1;
    const GLenum TEXTURE18                      = 0x84D2;
    const GLenum TEXTURE19                      = 0x84D3;
    const GLenum TEXTURE20                      = 0x84D4;
    const GLenum TEXTURE21                      = 0x84D5;
    const GLenum TEXTURE22                      = 0x84D6;
    const GLenum TEXTURE23                      = 0x84D7;
    const GLenum TEXTURE24                      = 0x84D8;
    const GLenum TEXTURE25                      = 0x84D9;
    const GLenum TEXTURE26                      = 0x84DA;
    const GLenum TEXTURE27                      = 0x84DB;
    const GLenum TEXTURE28                      = 0x84DC;
    const GLenum TEXTURE29                      = 0x84DD;
    const GLenum TEXTURE30                      = 0x84DE;
    const GLenum TEXTURE31                      = 0x84DF;
    const GLenum ACTIVE_TEXTURE                 = 0x84E0;
    
    /* TextureWrapMode */
    const GLenum REPEAT                         = 0x2901;
    const GLenum CLAMP_TO_EDGE                  = 0x812F;
    const GLenum MIRRORED_REPEAT                = 0x8370;
    
    /* Uniform Types */
    const GLenum FLOAT_VEC2                     = 0x8B50;
    const GLenum FLOAT_VEC3                     = 0x8B51;
    const GLenum FLOAT_VEC4                     = 0x8B52;
    const GLenum INT_VEC2                       = 0x8B53;
    const GLenum INT_VEC3                       = 0x8B54;
    const GLenum INT_VEC4                       = 0x8B55;
    const GLenum BOOL                           = 0x8B56;
    const GLenum BOOL_VEC2                      = 0x8B57;
    const GLenum BOOL_VEC3                      = 0x8B58;
    const GLenum BOOL_VEC4                      = 0x8B59;
    const GLenum FLOAT_MAT2                     = 0x8B5A;
    const GLenum FLOAT_MAT3                     = 0x8B5B;
    const GLenum FLOAT_MAT4                     = 0x8B5C;
    const GLenum SAMPLER_2D                     = 0x8B5E;
    const GLenum SAMPLER_CUBE                   = 0x8B60;
    
    /* Vertex Arrays */
    const GLenum VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
    const GLenum VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
    const GLenum VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
    const GLenum VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
    const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
    const GLenum VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
    const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
    
    /* Read Format */
    const GLenum IMPLEMENTATION_COLOR_READ_TYPE   = 0x8B9A;
    const GLenum IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
    
    /* Shader Source */
    const GLenum COMPILE_STATUS                 = 0x8B81;
    const GLenum INFO_LOG_LENGTH                = 0x8B84;
    const GLenum SHADER_SOURCE_LENGTH           = 0x8B88;
    const GLenum SHADER_COMPILER                = 0x8DFA;
    
    /* Shader Precision-Specified Types */
    const GLenum LOW_FLOAT                      = 0x8DF0;
    const GLenum MEDIUM_FLOAT                   = 0x8DF1;
    const GLenum HIGH_FLOAT                     = 0x8DF2;
    const GLenum LOW_INT                        = 0x8DF3;
    const GLenum MEDIUM_INT                     = 0x8DF4;
    const GLenum HIGH_INT                       = 0x8DF5;
    
    /* Framebuffer Object. */
    const GLenum FRAMEBUFFER                    = 0x8D40;
    const GLenum RENDERBUFFER                   = 0x8D41;
    
    const GLenum RGBA4                          = 0x8056;
    const GLenum RGB5_A1                        = 0x8057;
    const GLenum RGB565                         = 0x8D62;
    const GLenum DEPTH_COMPONENT16              = 0x81A5;
    const GLenum STENCIL_INDEX                  = 0x1901;
    const GLenum STENCIL_INDEX8                 = 0x8D48;
    
    const GLenum RENDERBUFFER_WIDTH             = 0x8D42;
    const GLenum RENDERBUFFER_HEIGHT            = 0x8D43;
    const GLenum RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
    const GLenum RENDERBUFFER_RED_SIZE          = 0x8D50;
    const GLenum RENDERBUFFER_GREEN_SIZE        = 0x8D51;
    const GLenum RENDERBUFFER_BLUE_SIZE         = 0x8D52;
    const GLenum RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
    const GLenum RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
    const GLenum RENDERBUFFER_STENCIL_SIZE      = 0x8D55;
    
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
    
    const GLenum COLOR_ATTACHMENT0              = 0x8CE0;
    const GLenum DEPTH_ATTACHMENT               = 0x8D00;
    const GLenum STENCIL_ATTACHMENT             = 0x8D20;
    
    const GLenum NONE                           = 0;
    
    const GLenum FRAMEBUFFER_COMPLETE                      = 0x8CD5;
    const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
    const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
    const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
    const GLenum FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;
    
    const GLenum FRAMEBUFFER_BINDING            = 0x8CA6;
    const GLenum RENDERBUFFER_BINDING           = 0x8CA7;
    const GLenum MAX_RENDERBUFFER_SIZE          = 0x84E8;
    
    const GLenum INVALID_FRAMEBUFFER_OPERATION  = 0x0506;
    
    readonly attribute HTMLCanvasElement canvas;

    long sizeInBytes(in GLenum type);
    WebGLContextAttributes getContextAttributes();

    void activeTexture(in GLenum texture) raises(DOMException);
    void attachShader(in WebGLProgram program, in WebGLShader shader) raises(DOMException);
    void bindAttribLocation(in WebGLProgram program, in GLuint index, in DOMString name) 
                                                                        raises(DOMException);
    void bindBuffer(in GLenum target, in WebGLBuffer buffer) raises(DOMException);
    void bindFramebuffer(in GLenum target, in WebGLFramebuffer framebuffer) 
                                                                        raises(DOMException);
    void bindRenderbuffer(in GLenum target, in WebGLRenderbuffer renderbuffer) 
                                                                        raises(DOMException);
    void bindTexture(in GLenum target, in WebGLTexture texture) raises(DOMException);
    void blendColor(in GLclampf red, in GLclampf green, in GLclampf blue, in GLclampf alpha) 
                                                                        raises(DOMException);
    void blendEquation(in GLenum mode) raises(DOMException);
    void blendEquationSeparate(in GLenum modeRGB, in GLenum modeAlpha) raises(DOMException);
    void blendFunc(in GLenum sfactor, in GLenum dfactor) raises(DOMException);
    void blendFuncSeparate(in GLenum srcRGB, in GLenum dstRGB, 
                           in GLenum srcAlpha, in GLenum dstAlpha) raises(DOMException);

    void bufferData(in GLenum target, in GLsizei size, in GLenum usage) raises(DOMException);
    void bufferData(in GLenum target, in WebGLArray data, in GLenum usage) 
                                                                        raises(DOMException);
    void bufferData(in GLenum target, in WebGLArrayBuffer data, in GLenum usage) 
                                                                        raises(DOMException);
    void bufferSubData(in GLenum target, in GLsizeiptr offset, in WebGLArray data) 
                                                                        raises(DOMException);
    void bufferSubData(in GLenum target, in GLsizeiptr offset, in WebGLArrayBuffer data) 
                                                                        raises(DOMException);

    GLenum checkFramebufferStatus(in GLenum target) raises(DOMException);
    void clear(in GLbitfield mask) raises(DOMException);
    void clearColor(in GLclampf red, in GLclampf green, in GLclampf blue, in GLclampf alpha) 
                                                                        raises(DOMException);
    void clearDepth(in GLclampf depth) raises(DOMException);
    void clearStencil(in GLint s) raises(DOMException);
    void colorMask(in GLboolean red, in GLboolean green, in GLboolean blue, in GLboolean alpha) 
                                                                        raises(DOMException);
    void compileShader(in WebGLShader shader) raises(DOMException);

    void copyTexImage2D(in GLenum target, in GLint level, in GLenum internalformat, 
                        in GLint x, in GLint y, in GLsizei width, in GLsizei height, 
                        in GLint border) raises(DOMException);
    void copyTexSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
                           in GLint x, in GLint y, in GLsizei width, in GLsizei height) 
                                                                        raises(DOMException);

    WebGLBuffer createBuffer() raises(DOMException);
    WebGLFramebuffer createFramebuffer() raises(DOMException);
    WebGLProgram createProgram() raises(DOMException);
    WebGLRenderbuffer createRenderbuffer() raises(DOMException);
    WebGLShader createShader(in GLenum type) raises(DOMException);
    WebGLTexture createTexture() raises(DOMException);

    void cullFace(in GLenum mode) raises(DOMException);

    void deleteBuffer(in WebGLBuffer buffer) raises(DOMException);
    void deleteFramebuffer(in WebGLFramebuffer framebuffer) raises(DOMException);
    void deleteProgram(in WebGLProgram program) raises(DOMException);
    void deleteRenderbuffer(in WebGLRenderbuffer renderbuffer) raises(DOMException);
    void deleteShader(in WebGLShader shader) raises(DOMException);
    void deleteTexture(in WebGLTexture texture) raises(DOMException);

    void depthFunc(in GLenum func) raises(DOMException);
    void depthMask(in GLboolean flag) raises(DOMException);
    void depthRange(in GLclampf zNear, in GLclampf zFar) raises(DOMException);
    void detachShader(in WebGLProgram program, in WebGLShader shader) raises(DOMException);
    void disable(in GLenum cap) raises(DOMException);
    void disableVertexAttribArray(in GLuint index) raises(DOMException);
    void drawArrays(in GLenum mode, in GLint first, in GLsizei count) raises(DOMException);
    void drawElements(in GLenum mode, in GLsizei count, in GLenum type, in GLsizeiptr offset) 
                                                                        raises(DOMException);

    void enable(in GLenum cap) raises(DOMException);
    void enableVertexAttribArray(in GLuint index) raises(DOMException);
    void finish() raises(DOMException);
    void flush() raises(DOMException);
    void framebufferRenderbuffer(in GLenum target, in GLenum attachment, 
                                 in GLenum renderbuffertarget, 
                                 in WebGLRenderbuffer renderbuffer) raises(DOMException);
    void framebufferTexture2D(in GLenum target, in GLenum attachment, in GLenum textarget, 
                              in WebGLTexture texture, in GLint level) raises(DOMException);
    void frontFace(in GLenum mode) raises(DOMException);

    void generateMipmap(in GLenum target) raises(DOMException);

    WebGLActiveInfo getActiveAttrib(GLuint program, GLuint index) raises(DOMException);
    WebGLActiveInfo getActiveUniform(GLuint program, GLuint index) raises(DOMException);
    WebGLObjectArray getAttachedShaders(GLuint program) raises(DOMException);

    GLint getAttribLocation(in WebGLProgram program, DOMString name) raises(DOMException);

    any getParameter(in GLenum pname) raises(DOMException);
    any getBufferParameter(in GLenum target, in GLenum pname) raises(DOMException);

    GLenum getError() raises(DOMException);

    any getFramebufferAttachmentParameter(in GLenum target, in GLenum attachment, 
                                          in GLenum pname) raises(DOMException);
    any getProgramParameter(in WebGLProgram program, in GLenum pname) raises(DOMException);
    DOMString getProgramInfoLog(in WebGLProgram program) raises(DOMException);
    any getRenderbufferParameter(in GLenum target, in GLenum pname) raises(DOMException);
    any getShaderParameter(in WebGLShader shader, in GLenum pname) raises(DOMException);
    DOMString getShaderInfoLog(in WebGLShader shader) raises(DOMException);

    DOMString getShaderSource(in WebGLShader shader) raises(DOMException);
    DOMString getString(in GLenum name) raises(DOMException);

    any getTexParameter(in GLenum target, in GLenum pname) raises(DOMException);

    any getUniform(in WebGLProgram program, in WebGLUniformLocation location) raises(DOMException);

    WebGLUniformLocation getUniformLocation(in WebGLProgram program, DOMString name) raises(DOMException);

    any getVertexAttrib(in GLuint index, in GLenum pname) raises(DOMException);

    GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname) raises(DOMException);

    void hint(in GLenum target, in GLenum mode) raises(DOMException);
    GLboolean isBuffer(in WebGLObject buffer) raises(DOMException);
    GLboolean isEnabled(in GLenum cap) raises(DOMException);
    GLboolean isFramebuffer(in WebGLObject framebuffer) raises(DOMException);
    GLboolean isProgram(in WebGLObject program) raises(DOMException);
    GLboolean isRenderbuffer(in WebGLObject renderbuffer) raises(DOMException);
    GLboolean isShader(in WebGLObject shader) raises(DOMException);
    GLboolean isTexture(in WebGLObject texture) raises(DOMException);
    void lineWidth(in GLfloat width) raises(DOMException);
    void linkProgram(in WebGLProgram program) raises(DOMException);
    void pixelStorei(in GLenum pname, in GLint param) raises(DOMException);
    void polygonOffset(in GLfloat factor, in GLfloat units) raises(DOMException);

    WebGLArray readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                           GLenum format, GLenum type) raises(DOMException);

    void renderbufferStorage(in GLenum target, in GLenum internalformat, 
                             in GLsizei width, in GLsizei height) raises(DOMException);
    void sampleCoverage(in GLclampf value, in GLboolean invert) raises(DOMException);
    void scissor(in GLint x, in GLint y, in GLsizei width, in GLsizei height) 
                                                                        raises(DOMException);

    void shaderSource(in WebGLShader shader, in DOMString source) raises(DOMException);

    void stencilFunc(in GLenum func, in GLint ref, in GLuint mask) raises(DOMException);
    void stencilFuncSeparate(in GLenum face, in GLenum func, in GLint ref, in GLuint mask) 
                                                                        raises(DOMException);
    void stencilMask(in GLuint mask) raises(DOMException);
    void stencilMaskSeparate(in GLenum face, in GLuint mask) raises(DOMException);
    void stencilOp(in GLenum fail, in GLenum zfail, in GLenum zpass) raises(DOMException);
    void stencilOpSeparate(in GLenum face, in GLenum fail, in GLenum zfail, in GLenum zpass) 
                                                                        raises(DOMException);

    void texImage2D(in GLenum target, in GLint level, in GLenum internalformat, 
                    in GLsizei width, in GLsizei height, in GLint border, in GLenum format, 
                    in GLenum type, in WebGLArray pixels) raises(DOMException);
    void texImage2D(in GLenum target, in GLint level, in ImageData pixels,
                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texImage2D(in GLenum target, in GLint level, in HTMLImageElement image,
                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texImage2D(in GLenum target, in GLint level, in HTMLCanvasElement image,
                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texImage2D(in GLenum target, in GLint level, in HTMLVideoElement image,
                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha) 
                                                                        raises(DOMException);

    void texParameterf(in GLenum target, in GLenum pname, in GLfloat param) 
                                                                        raises(DOMException);
    void texParameteri(in GLenum target, in GLenum pname, in GLint param) raises(DOMException);

    void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
                       in GLsizei width, in GLsizei height, 
                       in GLenum format, in GLenum type, in WebGLArray pixels) 
                                                                        raises(DOMException);
    void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
                       in ImageData pixels,
                       [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
                                                                        raises(DOMException);
    void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
                       in HTMLImageElement image,
                       [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
                       in HTMLCanvasElement image,
                       [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
                       in HTMLVideoElement image,
                       [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha) 
                                                                        raises(DOMException);

    void uniform1f(in WebGLUniformLocation location, in GLfloat x) raises(DOMException);
    void uniform1fv(in WebGLUniformLocation location, in WebGLFloatArray v) raises(DOMException);
    void uniform1fv(in WebGLUniformLocation location, in sequence&lt;float&gt; v) raises(DOMException);
    void uniform1i(in WebGLUniformLocation location, in GLint x) raises(DOMException);
    void uniform1iv(in WebGLUniformLocation location, in WebGLIntArray v) raises(DOMException);
    void uniform1iv(in WebGLUniformLocation location, in sequence&lt;long&gt; v) raises(DOMException);
    void uniform2f(in WebGLUniformLocation location, in GLfloat x, in GLfloat y) raises(DOMException);
    void uniform2fv(in WebGLUniformLocation location, in WebGLFloatArray v) raises(DOMException);
    void uniform2fv(in WebGLUniformLocation location, in sequence&lt;float&gt; v) raises(DOMException);
    void uniform2i(in WebGLUniformLocation location, in GLint x, in GLint y) raises(DOMException);
    void uniform2iv(in WebGLUniformLocation location, in WebGLIntArray v) raises(DOMException);
    void uniform2iv(in WebGLUniformLocation location, in sequence&lt;long&gt; v) raises(DOMException);
    void uniform3f(in WebGLUniformLocation location, in GLfloat x, in GLfloat y, in GLfloat z) 
                                                                        raises(DOMException);
    void uniform3fv(in WebGLUniformLocation location, in WebGLFloatArray v) raises(DOMException);
    void uniform3fv(in WebGLUniformLocation location, in sequence&lt;float&gt; v) raises(DOMException);
    void uniform3i(in WebGLUniformLocation location, in GLint x, in GLint y, in GLint z) raises(DOMException);
    void uniform3iv(in WebGLUniformLocation location, in WebGLIntArray v) raises(DOMException);
    void uniform3iv(in WebGLUniformLocation location, in sequence&lt;long&gt; v) raises(DOMException);
    void uniform4f(in WebGLUniformLocation location, in GLfloat x, in GLfloat y, in GLfloat z, in GLfloat w) 
                                                                        raises(DOMException);
    void uniform4fv(in WebGLUniformLocation location, in WebGLFloatArray v) raises(DOMException);
    void uniform4fv(in WebGLUniformLocation location, in sequence&lt;float&gt; v) raises(DOMException);
    void uniform4i(in WebGLUniformLocation location, in GLint x, in GLint y, in GLint z, in GLint w) 
                                                                        raises(DOMException);
    void uniform4iv(in WebGLUniformLocation location, in WebGLIntArray v) raises(DOMException);
    void uniform4iv(in WebGLUniformLocation location, in sequence&lt;long&gt; v) raises(DOMException);

    void uniformMatrix2fv(in WebGLUniformLocation location, in GLboolean transpose, 
                          in WebGLFloatArray value) raises(DOMException);
    void uniformMatrix2fv(in WebGLUniformLocation location, in GLboolean transpose, 
                          in sequence&lt;float&gt; value) raises(DOMException);
    void uniformMatrix3fv(in WebGLUniformLocation location, in GLboolean transpose, 
                          in WebGLFloatArray value) raises(DOMException);
    void uniformMatrix3fv(in WebGLUniformLocation location, in GLboolean transpose, 
                          in sequence&lt;float&gt; value) raises(DOMException);
    void uniformMatrix4fv(in WebGLUniformLocation location, in GLboolean transpose, 
                          in WebGLFloatArray value) raises(DOMException);
    void uniformMatrix4fv(in WebGLUniformLocation location, in GLboolean transpose, 
                          in sequence&lt;float&gt; value) raises(DOMException);

    void useProgram(in WebGLProgram program) raises(DOMException);
    void validateProgram(in WebGLProgram program) raises(DOMException);

    void vertexAttrib1f(in GLuint indx, in GLfloat x) raises(DOMException);
    void vertexAttrib1fv(in GLuint indx, in WebGLFloatArray values) raises(DOMException);
    void vertexAttrib1fv(in GLuint indx, in sequence&lt;float&gt; values) raises(DOMException);
    void vertexAttrib2f(in GLuint indx, in GLfloat x, in GLfloat y) raises(DOMException);
    void vertexAttrib2fv(in GLuint indx, in WebGLFloatArray values) raises(DOMException);
    void vertexAttrib2fv(in GLuint indx, in sequence&lt;float&gt; values) raises(DOMException);
    void vertexAttrib3f(in GLuint indx, in GLfloat x, in GLfloat y, in GLfloat z) 
                                                                        raises(DOMException);
    void vertexAttrib3fv(in GLuint indx, in WebGLFloatArray values) raises(DOMException);
    void vertexAttrib3fv(in GLuint indx, in sequence&lt;float&gt; values) raises(DOMException);
    void vertexAttrib4f(in GLuint indx, in GLfloat x, in GLfloat y, in GLfloat z, in GLfloat w) 
                                                                        raises(DOMException);
    void vertexAttrib4fv(in GLuint indx, in WebGLFloatArray values) raises(DOMException);
    void vertexAttrib4fv(in GLuint indx, in sequence&lt;float&gt; values) raises(DOMException);
    void vertexAttribPointer(in GLuint indx, in GLint size, in GLenum type, 
                             in GLboolean normalized, GLsizei stride, GLsizeiptr offset) 
                                                                        raises(DOMException);

    void viewport(in GLint x, in GLint y, in GLsizei width, in GLsizei height) 
                                                                        raises(DOMException);
};</pre>

<!-- ======================================================================================================= -->

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-canvas">
                    canvas
                </a>
            </code> 
            of type <code>HTMLCanvasElement</code>
        <dd>
            A reference to the canvas element which created this context.

    </dl>

<!-- ======================================================================================================= -->

    <h4>The <code>sizeInBytes</code> method</h4>

    <dl class="methods">
        <dt><code>sizeInBytes()</code>
        <dd>
            Returns the number of bytes used to represent the
            passed GL data type on the current platform.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>The <code>getContextAttributes</code> method</h4>

    <dl class="methods">
        <dt><code>getContextAttributes()</code>
        <dd>
            Returns the WebGLContextAttributes desribing the current drawing buffer.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Setting and getting state</h4>

    <p>
        OpenGL ES 2.0 maintains state values for use in rendering. All the calls in this
        group behave identically to their OpenGL counterparts unless otherwise noted.
        The get calls return a WebGLArray of the appropriate type filled with the returned
        state value(s). For convenience a version of each get call is provided which returns
        a single value of the appropriate type for use with state variables that have only
        a single numeric value. If used for state variables that have multiple values, an
        exception is raised.
    </p>
    
    <dl class="methods">
        <dt><code>activeTexture(texture)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glActiveTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>blendColor(red, green, blue, alpha)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendColor.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>blendEquation(mode)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendEquation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>blendEquationSeparate(modeRGB, modeAlpha)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendEquationSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>blendFunc(sfactor, dfactor)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendFuncSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>clearColor(red, green, blue, alpha)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClearColor.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>clearDepth(depth)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClearDepthf.xml">
                (OpenGL ES 2.0 man page)
            </a>
            <dd>
                <code>depth</code> value is clamped to the range 0 to 1.
        <dt><code>clearStencil(s)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClearStencil.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>colorMask(red, green, blue, alpha)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glColorMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>cullFace(mode)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCullFace.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>depthFunc(func)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDepthFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>depthMask(flag)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDepthMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>depthRange(zNear, zFar)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDepthRangef.xml">
                (OpenGL ES 2.0 man page)
            </a>
            <dd>
                <code>zNear</code> and <code>zFar</code> values are clamped to the range 0 to 1.
        <dt><code>disable(cap)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDisable.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>enable(cap)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glEnable.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>frontFace(mode)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFrontFace.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getParameter(pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGet.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>ACTIVE_TEXTURE</td><td>unsigned long</td></tr>
                <tr><td>ALIASED_LINE_WIDTH_RANGE</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>ALIASED_POINT_SIZE_RANGE</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>ALPHA_BITS</td><td>long</td></tr>
                <tr><td>ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>BLEND</td><td>boolean</td></tr>
                <tr><td>BLEND_COLOR</td><td>WebGLFloatArray (with 4 values)</td></tr>
                <tr><td>BLEND_DST_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_DST_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLUE_BITS</td><td>long</td></tr>
                <tr><td>COLOR_CLEAR_VALUE</td><td>WebGLFloatArray (with 4 values)</td></tr>
                <tr><td>COLOR_WRITEMASK</td><td>WebGLUnsignedByteArray (with 4 values)</td></tr>
                <tr><td>COMPRESSED_TEXTURE_FORMATS</td><td>null</td></tr>
                <tr><td>CULL_FACE</td><td>boolean</td></tr>
                <tr><td>CULL_FACE_MODE</td><td>unsigned long</td></tr>
                <tr><td>CURRENT_PROGRAM</td><td>WebGLProgram</td></tr>
                <tr><td>DEPTH_BITS</td><td>long</td></tr>
                <tr><td>DEPTH_CLEAR_VALUE</td><td>float</td></tr>
                <tr><td>DEPTH_FUNC</td><td>unsigned long</td></tr>
                <tr><td>DEPTH_RANGE</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>DEPTH_TEST</td><td>boolean</td></tr>
                <tr><td>DEPTH_WRITEMASK</td><td>boolean</td></tr>
                <tr><td>DITHER</td><td>boolean</td></tr>
                <tr><td>ELEMENT_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>FRONT_FACE</td><td>unsigned long</td></tr>
                <tr><td>GENERATE_MIPMAP_HINT</td><td>unsigned long</td></tr>
                <tr><td>GREEN_BITS</td><td>long</td></tr>
                <tr><td>LINE_WIDTH</td><td>float</td></tr>
                <tr><td>MAX_COMBINED_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_CUBE_MAP_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_RENDERBUFFER_SIZE</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_VARYING_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_ATTRIBS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VIEWPORT_DIMS</td><td>WebGLIntArray (with 2 elements)</td></tr>
                <tr><td>NUM_COMPRESSED_TEXTURE_FORMATS</td><td>long</td></tr>
                <tr><td>NUM_SHADER_BINARY_FORMATS</td><td>long</td></tr>
                <tr><td>PACK_ALIGNMENT</td><td>long</td></tr>
                <tr><td>POLYGON_OFFSET_FACTOR</td><td>float</td></tr>
                <tr><td>POLYGON_OFFSET_FILL</td><td>boolean</td></tr>
                <tr><td>POLYGON_OFFSET_UNITS</td><td>float</td></tr>
                <tr><td>RED_BITS</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BINDING</td><td>WebGLRenderbuffer</td></tr>
                <tr><td>SAMPLE_BUFFERS</td><td>long</td></tr>
                <tr><td>SAMPLE_COVERAGE_INVERT</td><td>boolean</td></tr>
                <tr><td>SAMPLE_COVERAGE_VALUE</td><td>float</td></tr>
                <tr><td>SAMPLES</td><td>long</td></tr>
                <tr><td>SCISSOR_BOX</td><td>WebGLIntArray (with 4 elements)</td></tr>
                <tr><td>SCISSOR_TEST</td><td>boolean</td></tr>
                <tr><td>STENCIL_BACK_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_REF</td><td>long</td></tr>
                <tr><td>STENCIL_BACK_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BITS</td><td>long</td></tr>
                <tr><td>STENCIL_CLEAR_VALUE</td><td>long</td></tr>
                <tr><td>STENCIL_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_REF</td><td>long</td></tr>
                <tr><td>STENCIL_TEST</td><td>boolean</td></tr>
                <tr><td>STENCIL_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>SUBPIXEL_BITS</td><td>long</td></tr>
                <tr><td>TEXTURE_BINDING_2D</td><td>WebGLTexture</td></tr>
                <tr><td>TEXTURE_BINDING_CUBE_MAP</td><td>WebGLTexture</td></tr>
                <tr><td>UNPACK_ALIGNMENT</td><td>int</td></tr>
                <tr><td>VIEWPORT</td><td>WebGLIntArray (with 4 elements)</td></tr>
            </table>
        <dt><code>getError()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetError.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getString(name)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetString.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>hint(target, mode)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glHint.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>isEnabled(cap)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsEnabled.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>lineWidth(width)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>pixelStorei(pname, param)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glPixelStorei.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>polygonOffset(factor, units)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glPolygonOffset.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>sampleCoverage(value, invert)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glPolygonOffset.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>stencilFunc(func, ref, mask)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>stencilFuncSeparate(face, func, ref, mask)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>stencilMask(mask)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>stencilMaskSeparate(face, mask)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>stencilOp(fail, zfail, zpass)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>stencilOpSeparate(face, fail, zfail, zpass)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Viewing and clipping</h4>

    <p>
        The viewport specifies the affine transformation of x and y from normalized device 
        coordinates to window coordinates. The size of the drawing buffer is determined by 
        the HTMLCanvasElement. The scissor box defines a rectangle which constrains drawing.
        When the scissor test is enabled only pixels that lie within  the scissor box can 
        be modified by drawing commands. When enabled drawing can only occur inside the 
        intersection of the viewport, canvas area and the scissor box. When the scissor test
        is not enabled drawing can only occur inside the intersection of the viewport and 
        canvas area.
    </p>

    <dl class="methods">
        <dt><code>scissor(x, y, width, height)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glViewport.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>viewport(x, y, width, height)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glViewport.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Buffer objects</h4>

    <p>
        Buffer objects (sometimes referred to as VBOs) hold vertex attribute data for the GLSL
        shaders.
    </p>
     
    <dl class="methods">
        <dt><code>bindBuffer(target, buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindBuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        
        <dt><code>bufferData(target, size, usage)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBufferData.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target. The
            buffer is initialized to 0.
            
        <dt><code>bufferData(target, data, usage)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBufferData.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target to the 
            size of the passed data, then write the contents of data to the buffer object.
            
        <dt><code>bufferSubData(target, offset, data)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBufferSubData.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            For the WebGLBuffer object bound to the passed target write the passed data starting
            at the passed offset. If the data would be written past the end of the buffer object
            an exception is raised.
            
        <dt><code>createBuffer()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenBuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLBuffer object and initialize it with a buffer object name as if by
            calling glGenBuffers.
            
        <dt><code>deleteBuffer(buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteBuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the buffer object contained in the passed WebGLBuffer as if by calling
            glDeleteBuffers. If the buffer has already been deleted the call has no effect.
            Note that the buffer object will be deleted when the WebGLBuffer object is destroyed.
            This method merely gives the author greater control over when the buffer object is
            destroyed.

        <dt><code>getBufferParameter(target, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetBufferParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>BUFFER_SIZE</td><td>long</td></tr>
                <tr><td>BUFFER_USAGE</td><td>unsigned long</td></tr>
            </table>
        <dt><code>isBuffer(buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsBuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Framebuffer objects</h4>

    <p>
        Framebuffer objects provide an alternative rendering target to the drawing buffer. They
        are a collection of color, alpha, depth and stencil buffers and are often used to 
        render an image that will later be used as a texture.
    </p>
     
    <dl class="methods">
        <dt><code>bindFramebuffer(target, buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindFramebuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        
        <dt><code>checkFramebufferStatus(target)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCheckFrameBufferStatus.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>createFramebuffer()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenFramebuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLFramebuffer object and initialize it with a framebuffer object name as if by
            calling glGenFramebuffers.
            
        <dt><code>deleteFramebuffer(buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteFramebuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the framebuffer object contained in the passed WebGLFramebuffer as if by calling
            glDeleteFramebuffers. If the framebuffer has already been deleted the call has no effect.
            Note that the framebuffer object will be deleted when the WebGLFramebuffer object is destroyed.
            This method merely gives the author greater control over when the framebuffer object is
            destroyed.

        <dt><code>framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFramebufferRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>framebufferTexture2D(target, attachment, textarget, texture, level)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFramebufferTexture2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getFramebufferAttachmentParameter(target, attachment, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetFramebufferAttachmentParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed target and attachment. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</td><td>unsigned long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</td><td>WebGLRenderbuffer or WebGLTexture</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</td><td>long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</td><td>long</td></tr>
            </table>
        <dt><code>isFramebuffer(buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsFramebuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLObject is a WebGLFramebuffer and false otherwise.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Renderbuffer objects</h4>

    <p>
        Renderbuffer objects are used to provide storage for the individual buffers used in a
        framebuffer object.
    </p>
     
    <dl class="methods">
        <dt><code>bindRenderbuffer(target, buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        
        <dt><code>createRenderbuffer()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenRenderbuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLRenderbuffer object and initialize it with a renderbuffer object name as if by
            calling glGenRenderbuffers.
            
        <dt><code>deleteRenderbuffer(buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteRenderbuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the renderbuffer object contained in the passed WebGLRenderbuffer as if by calling
            glDeleteRenderbuffers. If the renderbuffer has already been deleted the call has no effect.
            Note that the renderbuffer object will be deleted when the WebGLRenderbuffer object is destroyed.
            This method merely gives the author greater control over when the renderbuffer object is
            destroyed.
        <dt><code>getRenderbufferParameter(target, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetRenderbufferParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>RENDERBUFFER_WIDTH</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_HEIGHT</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_INTERNAL_FORMAT</td><td>unsigned long</td></tr>
                <tr><td>RENDERBUFFER_RED_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_GREEN_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BLUE_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_ALPHA_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_DEPTH_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_STENCIL_SIZE</td><td>long</td></tr>
            </table>
        <dt><code>isRenderbuffer(buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLObject is a WebGLRenderbuffer and false otherwise.
        <dt><code>renderbufferStorage(target, internalformat, width, height)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetRenderbufferParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Texture objects</h4>

    <p>
        Texture objects provide storage and state for texturing operations. If no WebGLTexture is bound
        (e.g., passing null or 0 to bindTexture) then attempts to modify the texture object shall
        raise an exception. This is indicated in the functions below.
    </p>
     
    <dl class="methods">
        <dt><code>bindTexture(target, texture)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>copyTexImage2D(target, level, internalformat, x, y, width, height, border)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCopyTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>copyTexSubImage2D(target, level, xoffset, yoffset, internalformat, x, y, width, height)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCopyTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>createTexture()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenTextures.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLTexture object and initialize it with a texture object name as if by
            calling glGenTextures.
            
        <dt><code>deleteTexture(texture)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteTextures.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the texture object contained in the passed WebGLTexture as if by calling
            glDeleteTextures. If the texture has already been deleted the call has no effect.
            Note that the texture object will be deleted when the WebGLTexture object is destroyed.
            This method merely gives the author greater control over when the texture object is
            destroyed.
        <dt><code>generateMipmap(target)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenerateMipmap.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>getTexParameter(target, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetTexParameterfv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>TEXTURE_MAG_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_MIN_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_S</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_T</td><td>unsigned long</td></tr>
            </table>
        <dt><code>isTexture(buffer)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLObject is a WebGLTexture and false otherwise.
        <dt><code>texImage2D(target, level, internalformat, width, height, border, format, type, pixels)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If the passed <code>pixels</code> value is <code>null</code> a buffer of sufficient size
            initialized to 0 is passed.
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>texImage2D(target, level, image, flipY, asPremultipliedAlpha)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If the flipY parameter is false, the upper left pixel of the passed image is sent first and
            then transfer proceeds across and then down the image. If the flipY parameter is true, the
            lower left pixel of the passed image is sent first and then transfer proceeds across and then
            up the image.
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>texParameterf(target, pname, param)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexParameterf.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>texParameteri(target, pname, param)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexParameteri.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
        <dt><code>texSubImage2D(target, level, xoffset, yoffset, image, flipY, asPremultipliedAlpha)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If the flipY parameter is false, the upper left pixel of the passed image is sent first and
            then transfer proceeds across and then down the image. If the flipY parameter is true, the
            lower left pixel of the passed image is sent first and then transfer proceeds across and then
            up the image.
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            exception is raised.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Programs and Shaders</h4>

    <p>
        Rendering with OpenGL ES 2.0 requires the use of <i>shaders</i>, written in OpenGL's shading
        language, GLSL. Shaders must be loaded with a source string (shaderSource), compiled
        (compileShader) and attached to a <i>program</i> (attachShader) which must be linked
        (linkProgram) and then used (useProgram).
    </p>
     
    <dl class="methods">
        <dt><code>attachShader(program, shader)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glAttachShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>bindAttribLocation(program, index, name)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindAttribLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>compileShader(shader)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCompileShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>createProgram()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLProgram object and initialize it with a program object name as if by
            calling glCreateProgram.
            
        <dt><code>createShader(type)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLShader object and initialize it with a shader object name as if by
            calling glCreateShader.
            
        <dt><code>deleteProgram(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the program object contained in the passed WebGLProgram as if by calling
            glDeleteProgram. If the program has already been deleted the call has no effect.
            Note that the program object will be deleted when the WebGLProgram object is destroyed.
            This method merely gives the author greater control over when the program object is
            destroyed.
        <dt><code>deleteShader(shader)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the shader object contained in the passed WebGLShader as if by calling
            glDeleteShader. If the shader has already been deleted the call has no effect.
            Note that the shader object will be deleted when the WebGLShader object is destroyed.
            This method merely gives the author greater control over when the shader object is
            destroyed.
        <dt><code>detachShader(program, shader)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDetachShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getAttachedShaders(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetAttachedShaders.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the list of shaders attached to the passed program.
        <dt><code>getProgramParameter(program, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetProgramiv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed program. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>LINK_STATUS</td><td>boolean</td></tr>
                <tr><td>VALIDATE_STATUS</td><td>boolean</td></tr>
                <tr><td>INFO_LOG_LENGTH</td><td>long</td></tr>
                <tr><td>ATTACHED_SHADERS</td><td>long</td></tr>
                <tr><td>ACTIVE_ATTRIBUTES</td><td>long</td></tr>
                <tr><td>ACTIVE_ATTRIBUTE_MAX_LENGTH</td><td>long</td></tr>
                <tr><td>ACTIVE_UNIFORMS</td><td>long</td></tr>
                <tr><td>ACTIVE_UNIFORM_MAX_LENGTH</td><td>long</td></tr>
            </table>
        <dt><code>getProgramInfoLog(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetProgramInfoLog.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getShaderParameter(shader, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetShaderiv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed shader. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>SHADER_TYPE</td><td>unsigned long</td></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>COMPILE_STATUS</td><td>boolean</td></tr>
                <tr><td>INFO_LOG_LENGTH</td><td>long</td></tr>
                <tr><td>SHADER_SOURCE_LENGTH</td><td>long</td></tr>
            </table>
        <dt><code>getShaderInfoLog(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetShaderInfoLog.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getShaderSource(shader)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetShaderSource.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>isProgram(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLObject is a WebGLProgram and false otherwise.
        <dt><code>isShader(shader)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLObject is a WebGLShader and false otherwise.
            
        <dt><code>linkProgram(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLinkProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>shaderSource(shader, source)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glShaderSource.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>useProgram(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUseProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>validateProgram(program)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glValidateProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Uniforms and attributes</h4>

    <p>
        Values used by the shaders are passed in as uniform of vertex attributes.
    </p>
     
    <dl class="methods">
        <dt><code>disableVertexAttribArray(index)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDisableVertexAttribArray.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>enableVertexAttribArray(index)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glEnableVertexAttribArray.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getActiveAttrib(program, index)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetActiveAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Returns information about the size, type and name of the vertex attribute at the
            passed index of the passed program object.
        <dt><code>getActiveUniform(program, index)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetActiveUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Returns information about the size, type and name of the uniform at the
            passed index of the passed program object.
        <dt><code>getAttribLocation(program, name)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetAttribLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getUniform(program, location)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetUniformfv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the uniform value at the passed location in the passed program. The type returned is 
            dependent on the uniform type, as shown in the following table:
            <table class="foo">
                <tr><th>uniform type</th><th>returned type</th></tr>
                <tr><td>boolean</td><td>boolean</td></tr>
                <tr><td>int</td><td>long</td></tr>
                <tr><td>float</td><td>float</td></tr>
                <tr><td>vec2</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>ivec2</td><td>WebGLIntArray (with 2 elements)</td></tr>
                <tr><td>bvec2</td><td>WebGLUnsignedByteArray (with 2 elements)</td></tr>
                <tr><td>vec3</td><td>WebGLFloatArray (with 3 elements)</td></tr>
                <tr><td>ivec3</td><td>WebGLIntArray (with 3 elements)</td></tr>
                <tr><td>bvec3</td><td>WebGLUnsignedByteArray (with 3 elements)</td></tr>
                <tr><td>vec4</td><td>WebGLFloatArray (with 4 elements)</td></tr>
                <tr><td>ivec4</td><td>WebGLIntArray (with 4 elements)</td></tr>
                <tr><td>bvec4</td><td>WebGLUnsignedByteArray (with 4 elements)</td></tr>
                <tr><td>mat2</td><td>WebGLFloatArray (with 4 elements)</td></tr>
                <tr><td>mat3</td><td>WebGLFloatArray (with 9 elements)</td></tr>
                <tr><td>mat4</td><td>WebGLFloatArray (with 16 elements)</td></tr>
            </table>
        <dt><code>getUniformLocation(program, name)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetUniformLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>getVertexAttrib(index, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetVertexAttribfv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the information requested in pname about the vertex attribute at the passed index. The type returned is 
            dependent on the information requested, as shown in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_ENABLED</td><td>boolean</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_SIZE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_STRIDE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_TYPE</td><td>unsigned long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_NORMALIZED</td><td>boolean</td></tr>
                <tr><td>CURRENT_VERTEX_ATTRIB</td><td>WebGLFloatArray (with 4 elements)</td></tr>
            </table>
        <dt><code>getVertexAttribOffset(index, pname)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetVertexAttribfv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform1f(location, x)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform1fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform1fv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform1fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform1i(location, x)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform1iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform1iv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform1iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform2f(location, x, y)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform2fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform2fv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform2fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform2i(location, x, y)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform2iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform2iv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform2iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform3f(location, x, y, z)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform3fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform3fv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform3fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform3i(location, x, y, z)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform3iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform3iv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform3iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform4f(location, x, y, z, w)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform4fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform4fv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform4fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform4i(location, x, y, z, w)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform4iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniform4iv(location, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform4iv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniformMatrix2fv(location, transpose, value)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniformMatrix2fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniformMatrix3fv(location, transpose, value)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniformMatrix3fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>uniformMatrix4fv(location, transpose, value)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniformMatrix4fv.xml">
                (OpenGL ES 2.0 man page)
            </a>
       <dd>
            Each of the uniform* functions above sets the specified uniform or uniforms to the values 
            provided. The passed <code>location</code> must have been obtained from the currently used 
            program via an earlier call to <code>getUniformLocation</code>, or an exception will be 
            raised.
        <dt><code>vertexAttrib1f(index, x)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib1f.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>vertexAttrib1fv(index, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib1f.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>vertexAttrib2f(index, x)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib2f.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>vertexAttrib2fv(index, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib2f.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>vertexAttrib3f(index, x)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib3f.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>vertexAttrib3fv(index, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib3f.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>vertexAttrib4f(index, x)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib4f.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>vertexAttrib4fv(index, v)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib4f.xml">
                (OpenGL ES 2.0 man page)
            </a>
         <dt><code>vertexAttribPointer(index, size, type, normalized, stride, offset)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttribPointer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Assign the currently bound WebGLBuffer object to the passed vertex attrib index.
            Size is number of components per attribute. Stride and offset are in units of bytes.
            Passed stride and offset must be appropriate for the passed type and size or an
            exception shall be raised.
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Writing to the drawing buffer</h4>

    <p>
        OpenGL ES 2.0 has 3 calls which can render to the drawing buffer: <code>clear</code>, 
        <code>drawArrays</code> and <code>drawElements</code>. Furthermore rendering can
        be directed to the drawing buffer or to a Framebuffer object. When rendering is
        directed to the drawing buffer, making any of the 3 rendering calls shall 
        cause the drawing buffer to be presented to the HTML page compositor at the start
        of the next compositing operation.
    </p>
     
    <dl class="methods">
        <dt><code>clear(mask)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClear.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>drawArrays(mode, first, count)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDrawArrays.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>drawElements(mode, count, type, offset)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDrawArrays.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Draw using the currently bound index array.  The given
            offset is in bytes, and must be a valid multiple of the
            size of the given type or an exception is raised.
        <dt><code>finish()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFinish.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><code>flush()</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFlush.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Reading back pixels</h4>

    <p>
        Pixels in the current framebuffer can be read back into a WebGLArray object.
    </p>

    <dl class="methods">
        <dt><code>readPixels(x, y, width, height, format, type)</code>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glReadPixels.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return a WebGLArray with pixels within the passed rectangle. The specific subclass
            of WebGLArray returned depends on the passed type. If it is GL_UNSIGNED_BYTE, a
            WebGLUnsignedByteArray is returned, otherwise a WebGLUnsignedShortArray is 
            returned.
    </dl>
    
<!-- ======================================================================================================= -->

    <h3>Events</h3>

    <p>
        WebGL generates events when certain system activity occurs affecting the context.
        These events are sent to the corresponding HTMLCanvasElement through the
        <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html">DOM Event System</a>.
    </p>

<!-- ======================================================================================================= -->

    <h4>WebGLResourceLostEvent</h4>

    <p>
        This event occurs when some system activity external to WebGL occurs which
        causes one of more resources of the current context to be lost. The 
        <span class="prop-name">resource</span> attribute contains the resource
        that was lost, or null if all resources were lost. The 
        <span class="prop-name">context</span> attribute contains the 
        WebGLRenderingContext for which the resource was lost.
    </p>
    <pre class="idl">
interface <dfn id="WebGLResourceLostEvent">WebGLResourceLostEvent</dfn> : Event {
    readonly attribute WebGLObject resource;
    readonly attribute WebGLRenderingContext context;
    
    void initWebGLResourceLostEvent(in DOMString type,
                                    in boolean canBubble,
                                    in boolean cancelable,
                                    in WebGLObject resource,
                                    in WebGLRenderingContext context);
};</pre>

    <h5>Attributes</h5>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt><span class="prop-name">resource</span>
        <dd>
            The resource that was lost, or null if all resources were lost.
        <dt><span class="prop-name">context</span>
        <dd>
            The context for which the resource was lost.
    </dl>

    <h5 id="5.15.1.2"><span class=secno>5.15.1.2</span>
        Methods
    </h5>

    <p>
        The following methods are available:
    </p>

    <dl class="methods">
        <dt><code>initWebGLResourceLostEvent(type, canBubble, cancelable, resource, context)</code>
        <dd>
            Initialize the event created through the 
            <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-DocumentEvent">DocumentEvent</a> 
            interface. This method may only be called before the event has been dispatched via 
            the <code>dispatchEvent</code> method, though it may be called multiple times 
            during that phase if necessary. If called multiple times, the final invocation 
            takes precedence.
    </dl>

<!-- ======================================================================================================= -->

    <h2>References</h2>
    
    <h3>Normative references</h3>
    <dl>
    
http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.24.pdf

    
        <dt id="refsGLES20">[GLES20]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.24.pdf">
            OpenGL&reg; ES Common Profile Specification Version 2.0.24</a></cite>, 
            A. Munshi, J. Leech, April 2009.
        </dd>
        <dt id="refsGLES20GLSL">[GLES20GLSL]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">
            The OpenGL&reg; ES Shading Language Version 1.00</a></cite>, 
            R. Simpson, May 2009.
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
    </dl>



    <h3>Other references</h3>

<!-- ======================================================================================================= -->
    
    <h2>Acknowledgements</h2>
    <p>This specification is produced by the Khronos WebGL Working Group.</p>
    
    <p>
       Special thanks to: Jon Leech, Kenneth Russell (Google), Kenneth Waters (Google), Mark Callow (HI), Mark Steele (Mozilla), Oliver Hunt (Apple), Tim Johansson (Opera),
       Vangelis Kokkevis (Google), Vladimir Vukicevic (Mozilla)
    </p>
    <p>Additional thanks to: Alan Hudson (Yumetech), Arun Ranganathan (Mozilla), Bill Licea Kane (AMD), Dan Gessel (Apple), David Ligon (Qualcomm), Greg Ross (Nvidia),
    Jacob Strom (Ericsson), Kari Pulli (Nokia), Leddie Stenvie (ST-Ericsson), Neil Trevett (Nvidia), Per Wennerstein (Ericsson), Per-Erik Brodin (Ericsson),
    Tom Olson (ARM), Zhengrong Yao (Ericsson), and the members of the Khronos WebGL Working Group.
</p>

</body>
</html>
